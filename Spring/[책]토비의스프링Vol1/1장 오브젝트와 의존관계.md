> 출처 : 토비의 스프링 3.1 Vol.1 읽으면서 정리

# 1장 오브젝트와 의존관계
스프링의 핵심 철학  
자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고,
그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는것

## 1.1 초난감 DAO
DAO (Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

- 자바빈
    * 디폴트 생성자 : 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
    * 프로퍼티 : 자바빈의 속성 setter getter를 이용해 수정 또는 조회 할 수 있다.

## 1.2 DAO의 분리
관심사의 분리 (Seperation of Concerns 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고,
관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

템플릿 메소드 패턴  
상속을 통해 슈퍼클랙스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다.
변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다.
```java
public abstract class Super {
  public void templateMethod() {
    // 기본 알고리즘 코드
      hookMethod();
      abstractMethod();
      ....
  }

  protected void hookMethod() {} // 선택적으로 오버라이드 가능한 훅 메소드
  public abstract void abstractMethod(); //서브 클래스에서 반드시 구현해야 하는 추상 메소드
}

public class Sub1 extends Super {
  protected void hookMethod() {
    ...
  }

  public void abstractMethod() {
    ...
  }
}
```

팩토리 메소드 패턴  
상속을 통해 기능을 확장하게 하는 패턴이다. 
슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다.

## 1.3 DAO의 확장
### 1.3.1 클래스의 분리
### 1.3.2 인터페이스의 도입
### 1.3.3 관계설정 책임의 분리

### 1.3.4 원칙과 패턴
개방 폐쇄 원칙 (OCP , Open-Closed Principle)  
"클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다"

객체지향의 설계 원칙 (SOLID)
- SRP (The Single Responsibility Principle) : 단일 책임 원칙
- OCP (The Open Closed Principle) : 개방 폐쇄 원칙
- LSP (The Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP (The Interface Segregation Principle) : 인터페이스 분리 원칙
- DIP (The Dependency Inversion Principle) : 의존관계 역전 원칙

전략 패턴 (Strategy Pattern)  
자신의 Context에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리 시키고
이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

## 1.4 제어의 역전(Ioc)
### 1.4.1 오브젝트 팩토리

팩토리
객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 일을 하는 오브젝트를 흔히 팩토리라고 부름
### 1.4.2 오브젝트 팩토리의 활용
### 1.4.3 제어권 이전을 통한 제어관계 역전
제어의 역전이란 제어 흐름의 개념을 거꾸로 뒤집는 것이다.

라이브러리  
사용하는 애플리케이션 코드는 애플리케이션의 흐름을 직접 제어한다.
단지 동작하는 중에 필요한 기능이 있을때 능동적으로 라이브러리를 사용할 뿐이다.

프레임워크  
애플리케이션 코드가 프레임 워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고 
프레임 워크가 흐름을 주도하는 중 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.

## 1.5 스프링의 IoC
### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC
스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

@Configuration  
애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정 정보라는 표시

@Bean  
오브젝트 생성을 담당하는 IoC용 메소드라는 표시

### 1.5.2 애플리케이션 컨텍스트의 동작방식
애플리케이션 컨텍스트를 스프링에서는 IoC 컨테이터 , 스프링 컨테이너,빈팩토리 로 부르기도한다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다. 
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

### 1.5.3 스프링 IoC의 용어 정리
- 빈 Bean
    * 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다.
    * 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
    
- 빈 팩토리 Bean Factory
    * 스프링의 IoC를 담당하는 햄식 컨테이너를 가리킨다.
    * 빈을 등록하고, 생성하고 , 조회하고 돌려주고, 그외의 부가적인 빈 관리하는 기능을 담당한다.

- 애플리케이션 컨텍스트 application Context
    * 빈 팩토리를 확장한 IoC 컨테이너이다. 빈을 등록하고 관리하는 기본적인 기능은 빈팩토리와 동일하다.
    * 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
    * ApplicationContext는 BeanFactory를 상속한다.
  
- 설정정보/설정 메타정보 configuration metadata
    * 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타 정보를 말한다.
  
- 컨테이너 또는 IoC 컨테이너
    * IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈팩토리를 컨테이너 또는 IoC 컨테이너라고 한다.
  
- 스프링 프레임워크
    * IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할때 주로 사용한다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프
오브젝트의 동일성과 동등성  
동일성 identity  
완전히 같은 동일한 오브젝트  
== 연산자

동등성 equality : 동일한 정보를 담고 있는(equivalent) 오브젝트 equals() 메소드를 사용해 비교

스프링은 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.  

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
서블릿은 대부분의 멀티스레드 환경에서 싱글톤으로 동작한다.  

- 싱글톤 패턴(Singleton Pattern)
GoF 멤버 조차도 싱글톤 패턴은 매우 조심해서 사용해야 하거나 피해야 할 패턴이라고 말하기도 한다.
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴인다.

```java
public class UserDao {
  private static UserDao INSTANCE;

  private UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }

  public static synchronized UserDao getInstance() {
    if(INSTANCE == null) INSTANCE = new UserDao(???);
    return INSTANCE;
  }
}
```        

- private 생성자를 갖고 있기 때문에 상속 할 수 없다
- 싱글톤은 테스트하기가 힘들다.
- 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
- 싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.

싱글톤 레지스트리로 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
싱글톤 레지스트스리의 장점은 스태틱 메소드와 private 생성자를 사용해야하는 비정상적인 클래스가 아니라  평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점

### 1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 상태정보를 내부에 갖고 있지 않는 무상태 (stateless) 방식으로 만들어져야한다.

### 1.6.3 스프링의 빈의 스코프
스프링이 관리하는 오브텍트, 즉 빈이 생성되고,존재하고,적용되는 범위

스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다. 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 프로토타입(Prototype) 스코프가 있다.
프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할때마다 매번 새로운 오브젝트를 만들어준다. 그외에도 요청(request) 스코프가 있고 , 세션 (session) 스코프도 있다.

## 1.7 의존관계 주입(DI)
### 1.7.1 제어의 역전(IoC)과 의존관계 주입
스프링이 제공하는 IoC 방식을 핵심으로 짚어주는 의전관계 주입 (Dependency Injection)이라는, 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했다.
초기에 주로 IoC 컨테이너라고 불리던 스피링이 지금은 의존관계 주입 컨테이너 또는 DI 컨테이너라고 더 많이 불리고 있다.

### 1.7.2 런타임 의존관계 설정
DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어 맞는다.

### 1.7.3 의존관계 검색과 주입
의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

### 1.7.4 의존관계 주입의 응용
### 1.7.5 메소드를 이용한 의존관계 주입

## 1.8 XML을 이용한 설정
<beans> = @Configuration
<bean>  = @Bean

### 1.8.1 XML 설정
- 빈의 이름 : @Bean 메소드 이름이 빈의 이름이다. 이 이름은 getBean()에서 사용된다.   
- 빈의 클래스 : 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.
- 빈의 의존 오브젝트 : 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다.
```java
      @Bean                             // <bean
      public ConnectionMaker
      connectionMaker() {               // id = "connectionMaker"
        return new DConnectionMaker();  // class = "springbook...DConnectionMaker" />
      }
```

- XML에서는 <property> 태그를 사용해 의존 오브젝트와 관계를 정의한다.
- name과 ref 두개의 애트리뷰트를 같는데 name은 프로퍼티 이름이다. 이름으로 수정자 메소드를 알수있다.
- ref는 수정자 메소드를 통해 주입해줄 오브젝트 빈 이름이다. 

DTD와 스키마  
XML 문서는 미리 정해진 구조를 따라서 작성됐는지 검사 할 수 있다. XML 문서의 구조를 정의하는 방법에는 DTD와 스키마(schema)가 있다.

### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트
### 1.8.3 DataSource 인터페이스로 변환
### 1.8.4 프로퍼티 값의 주입
스프링 빈으로 등록될 클래스에 수정자 메소드가 정의되어 있다면 <property>를 사용해 주입할 정보를 지정할수
있다는 점에서 <property ref="">와 동일하다. 하지만 다른 빈 오브젝트의 레퍼런스(ref)가 아니라 단순 값(value)을 주입해주는 것이기 때문에
ref 애트리뷰트 대신 value 애트리뷰트를 사용한다.

## 1.9 정리