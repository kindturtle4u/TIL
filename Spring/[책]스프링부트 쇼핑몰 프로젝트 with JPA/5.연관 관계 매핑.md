> 출처 :  스프링 부트 쇼핑몰 프로젝트 with JPA 읽으면서 정리 (https://github.com/roadbook2/shop)

# 5장 연관 관계 매핑
## 5.1 연관 관계 매핑 종류
- JPA에서는 엔티티에 연관관계를 매핑해두고 필요할 때 해당 엔티티와 연관된 엔티티를 사용하여 좀더 객체지향적으로 프로그래밍 할 수 있도록 도와줍니다.
- 첫 번째로 기억해야 할 것은 연관 관계 매핑의 종류입니다.
    * 일대일(1:1): @OneToOne
    * 일대다(1:N): @OneToMany
    * 다대일(N:1): @ManyToOne
    * 다대다(N:M): @ManyToMany
- 두 번째로 중요한 것은 엔티티를 매핑할 때는 방향성을 고려해야 합니다.
  * 단방향
  * 양방향

### 5.1.1 일대일 단방향 매핑하기
- 장바구니(Cart) 엔티티를 만들고 회원 엔티티와 연관 관계 매핑을 설정하겠습니다.
- 엔티티를 조회할 때 해당 엔티티와 매핑된 엔티티도 한 번에 조회하는 것을 '즉시 로딩'이라고 합니다.
일대일(@OneToOne), 다대일(@ManyToOne)로 매핑할 경우 즉시 로딩을 기본 Fetch 전략으로 설정합니다.
- 일대일 매핑 관계를 맺어줄 때 따로 옵션을 주지 않으면 아래 코드와 같이 `FetchType.EAGER`(즉시로딩)로 설정하는 것과 동일합니다.

```java
@OneToOne(fetch = FetchType.EAGER)
@JoinColumn(name="member_id")
private Member member;
```

### 5.1.2 다대일 단반향 매핑하기
### 5.1.3 다대일/일대다 양방향 매핑하기
- 양방향 매핑이란 단방향 매핑이 2개 있다고 생각하시면 됩니다.
- 다대일과 일대다는 반대 관계라고 생각하시면 됩니다. 주문 상품 엔티티 기준에서 다대일 매핑이었으므로 주문 엔티티 기준에서는 주문 상품 엔티티와 일대다 관계로 매핑하면 됩니다.
- 또한 양방향 매핑에서는 '연관 관계 주인'을 설정해야 한다는 점이 중요합니다.
- 테이블은 외래키 하나로 양방향 조회가 가능합니다. 엔티티는 테이블과 다릅니다. 
엔티티를 양방향 연관 관계로 설정하면 객체의 참조는 둘인데 외래키는 하나이므로 둘 중 누가 외래키를 관리할지를 정해야 합니다.
  * 연관 관계의 주인은 외래키가 있는 곳으로 설정
  * 연관 관계의 주인이 외래키를 관리(등록, 수정, 삭제)
  * 주인이 아닌 쪽은 연관 관계 매핑 시 mappedBy 속성의 값으로 연관 관계의 주인을 설정
  * 주인이 아닌 쪽은 읽기만 가능
- 무조건 양방향으로 연관 관계를 매핑하면 해당 엔티티는 엄청나게 많은 테이블과 연관 관계를 맺게 되고 엔티티 클래스 자체가 복잡해지기 때문에 연관 관계 단방향 매핑으로 설계 후
나중에 필요할 경우 양방향 매핑을 추가하는 것을 권합니다.

### 5.1.4 다대다 매핑하기
- 결론부터 말씀드리면 다대다 매핑은 실무에서는 사용하지 않는 매핑 관계입니다. 관계형 데이터 베이스는 정규화된 테이블 2개로 다대다를 표현할 수 없습니다.
따라서 연결 테이블을 생성해서 다대다 관계를 일대다, 다대일 관계로 풀어냅니다.
- @ManyToMany 어노테이션을 사용해서 다대다 매핑이 가능합니다. 아래 코드는 프로젝트에 추가하지 않고, 다대다 매핑의 진행 방식 정도만 보고 가시면 됩니다.

```java
public class Item {
    @ManyToMany
    @JoinTable(
            name = "member_item"
            joinColumns = @JoinColumn(name = "member_id")
            inverseJoinColumns = @JoinColumn(name = "item_id")
    )
    private List<Member> member;
}
```
- 다대다 매핑을 사용하지 않는 이유는 연결 테이블에는 컬럼을 추가할 수 없기 때문입니다. 연결 테이블에는 조인 컬럼뿐 아니라 추가 컬럼들이 필요한 경우가 많습니다.
- 따라서 연결 테이블용 엔티티를 하나 생성한 후 일대다 다대일 관계로 매핑을 하면 됩니다.

## 5.2 영속성 전이
### 5.2.1 영속성 전이란?
- 영속성 전이랑 엔티티의 상태를 변경할 때 해당 엔티티와 연관된 엔티티의 상태 변화를 전파시키는 옵션입니다. 
- 이때 부모는 One에 해당하고 자식은 Many에 해당합니다. 예를 들어 Order 엔티티가 삭제되었을 때 해당 엔티티와 연관되어 있는 OrderItem 엔티티가 함께 삭제되거나, Order 엔티티를 저장할
때 Order 엔티티에 담겨있던 OrderItem 엔티티를 한꺼번에 저장할 수 있습니다.

| CASCASE 종류 | 설명                                          |
|------------|---------------------------------------------|
| PERSIST    | 부모 엔티티가 영속화될 때 자식 엔티티도 영속화                  |
| MERGE      | 부모 엔티티가 병합될 때 자식 엔티티도 병합                    |
| REMOVE     | 부모 엔티티가 삭제될 때 연관된 자식 엔티티도 삭제                |
| REFRESH    | 부모 엔티티가 refresh되면 연관된 자식 엔티티도 refresh       |
| DETACH     | 부모 엔티티가 detach 되면 연관된 자식 엔티티도 detach 상태로 변경 |
| ALL        | 부모 엔티티의 영속성 상태를 자식 엔티티에 모두 전이               |

- 영속성 전이 옵션을 무분별하게 사용할 경우 삭제 되니 말아야 할 데이터가 삭제될 수 있으므로 조심해서 사용해야 합니다.
- 영속성 전이 옵션은 단일 엔티티에 완전히 종속적이로 부모 엔티티와 자식 엔티티의 라이프 사이클이 유사할 때 cascade 옵션을 활용하시기 추천드립니다.

### 5.2.2 고아 객체 제거하기
- 부모 엔티티와 연관 관계까 끊어진 자식 엔티티를 고아 객체라고 합니다. 영속성 전이 기능과 같이 사용하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있습니다.
- 주의사항이 있습니다. 고아 객체 제거 기능은 참조하는 곳이 하나일 때만 사용해야 합니다. 다른 곳에서도 참조하고 있는 엔티티인데 삭제하면 문제가 생길 수 있습니다.
- @OneToOne, @OneToMany 어노테이션에서 옵션으로 사용하시면 됩니다.

## 5.3 지연로딩
- 일대일, 다대일로 매핑할 경우 기본 전략인 즉시 로딩을 통해 엔티티를 함께 가지고 옵니다.
- 실제 비지니스를 하고 있따면 매핑되는 엔티티의 개수는 훨씬 많습ㄴ디ㅏ. 그렇게 되면 개발자는 쿼리가 어떻게 실행될지 예측할 수 없습니다. 또한 사용하지 않는 데이터도 한꺼번에
조회하므로 성능 문제도 있을 수 있습니다. 따라서 즉시 로딩은 실무에서는 사용하기 힘듭니다.
- 지연로딩으로 설정하면 실제 엔티티 대신에 프록시 객체를 넣어둡니다. 프록시 객체는 실제로 사용되기 전까지 데이터 로딩을 하지 않고, 실제 사용 시점에 조회 쿼리문이 실행됩니다.
- `@OneToMany` 어노테이션의 경우는 기본 FetchType이 LAZY 방식으로 되어 있는 것을 확인할 수 있습니다.

## 5.4 Auditing을 이용한 엔티티 공통 속성 공통화
- Spring Data Jpa에서는 Auditing 기능을 제공하며 엔티티가 저장 또는 수정될 때 자동으로 등록일, 수정일, 등록자, 수정자를 입력해줍니다. Audit의 사전적 정의는 '감시하다' 입니다.
즉, 엔티티의 생성과 수정을 감시하고 있는 것입니다.