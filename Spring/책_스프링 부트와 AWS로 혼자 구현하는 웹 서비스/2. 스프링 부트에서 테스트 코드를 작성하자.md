> 출처 :  스프링 부트와 AWS로 혼자 구현하는 웹 서비스읽으면서 정리

# 2. 스프링 부트에서 테스트 코드를 작성하자
## 2.1 테스트 코드 소개
TDD와 단위테스트(Unit Test)는 다른 이야기 입니다.

TDD는 테스트가 주도하는 개발을 이야기 합니다. 테스트 코드를 먼저 작성하는 것부터 시작합니다.

#### 레드 그린 사이클
- 항상 실패하는 테스트를 먼저 작성하고(Red)
- 테스트가 통과하는 프로덕션 코드를 작성하고(Green)
- 테스트가 통과하면 프로덕션 코드를 리팩토링합니다.(Refactor)

반면 단위 테스트는 TDD의 첫번째 단계인 기능단위의 테스트 코드를 작성하는 것을 이야기합니다.
채수원 'TDD 실천법과 도구' 공개 PDF (https://repo.yona.io/doortts/blog/issue/1)

#### 단위테스트 코드를 작성함으로써 얻는 이점
- 단위 테스트 개발단계 초기에 문제를 발견하게 도와줍니다.
- 단위 테스트는 개발자가 나중에 코드를 리팩토링하거나 라이브러리 업그레이드 등에서 기존 기능이 올바르게 동작하는지 확인할 수 있습니다.(회귀테스트)
- 단위 테스트는 기능에 대한 북확실성을 감소시킬 수 있습니다.
- 단위 테스트는 시스템에 대한 실제 문서를 제공합니다. 즉, 단위 테스트 자체가 문서로 사용할 수 있습니다.

## 2.2 Hello Controller 테스트 코드 작성하기
@SpringBootApplication이 있는 위치부터 설정을 읽어가기 때문에 이 클래스는 항상 프로젝트의 최 상단에 위치해야만 합니다.

스프링 부트에서는 내장WAS를 사용하는 것을 권장하고 있습니다. 이유는 **언제 어디서나 같은 환경에서 스프링부트를 배포** 할 수 있기 때문입니다.

외장 WAS를 쓴다고 하면 모든 서버는 WAS의 종류와 버전, 설정을 일치시켜야만 합니다. 새로운 서버가 추가되면 모든 서버가 같은 WAS 환경을 구축해야만 합니다.
1대면 다행이지만, 30대의 서버에 설치된 WAS의 버전을 올린다고 하면 어떻게 될까요? 실수할 여지도 많고, 시간도 많이 필요한 큰 직업이 될 수도 있습니다.
하지만 이렇게 내장 WAS를 사용할 경우 이 문제를 모두 해결할 수 있습니다. 그래서 많은 회사에서 내장 WAS를 사용하도록 전환하고 있습니다.

간혹 내장WAS를 쓰면 성능상 이슈가 있지 않냐고 하시는 분들이 계십니다. 대표적인 WAS인 톰캣 역시 서블릿으로 이루어진 자바애플리케이션입니다.
똑같은 코드를 사용하고 있으므로 성능상 이슈는 크게 고려하지 않아도 됩니다.

#### @RunWith(SpringRunner.class)
- 테스트를 진행할때 Junit에 내장된 실행자 외에 다른 실행자를 실행시킵니다.
- 여기서는 SpringRunner라는 스프링 실행자를 사용합니다.
- 즉, 스프링 부트테스트와 Junit 사이에 연결자 역할을 합니다.

#### @WebMvcTest
- 여러 스프링 테스트 어노테이션 중, Web(Spring MVC)에 집중할 수 있는 어노테이션 입니다.
- 선언할 경우 @Controller, @ControllerAdvice 등을 사용할 수 있습니다.
- 단, @Service, @Component, @Repository등은 사용할 수 없습니다.
- 여기서는 컨트롤러만 사용하기 때문에 선언합니다.

#### pivate MockMvc mvc
- 웹 API를 테스트할 때 사용합니다.
- 스프링 MVC 테스트의 시작점입니다.
- 이클래스를 통해서 HTTP GET, POST 등에 대한 API 테스트를 할 수 있습니다.

#### mvc.preform(get("/hello"))
- MockMvc를 통해 /hello 주소로 HTTP GET 요청을 합니다.
- 체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언할 수 있습니다.

#### .andExpect(status().isOk())
- mvc.perform의 결과를 검증합니다.
- HTTP Header의 Status를 검증합니다.
- 우리가 흔히 알고 있는 200, 404, 500등의 상태를 검증합니다.
- 여기서 OK 즉, 200인지 아닌지를 검증합니다.

#### .andExpect(content().string(hello))
- mvc.perform의 결과를 검증합니다.
- 응답 본문의 내용을 검증합니다.
- Controller에서 "hello"를 리턴하기 때문에 이 값이 맞는지 검증합니다.

브라우저로 한 번씩 검증은 하시되, 테스트 코드는 꼭 따라 해야 합니다. 그래야만 견고한 소프트웨어를 만드는 역량이 성장할 수 있습니다.
추가로, 절대 수동으로 검증하고 테스트 코드를 작성하진 않습니다. 테스트 코드로 먼저 검증 후 , 정말 못 믿겠다는 생각이 들 땐 프로젝트를
실행해 확인한다는 점 명심해 주세요

## 2.3 롬복 소개 및 설치하기
## 2.4 Hello Controller 코드를 롬복으로 전환하기

#### assertThat
- assertj라는 테스트 검증 라이브러리의 검증 메소드 입니다.
- 검증하고 싶은 대상을 메소드 인자로 받습니다.
- 메스드 체이닝이 지원되어 isEqualTo와 같이 메소드를 이어서 사용할 수 있습니다.

#### isEqualTo
- assertj의 동등 비교 메소드 입니다.
- assertTaht에 있는 값과 isEqualTo 값을 비교해서 같을 때만 성공입니다.

aseertj 장점에 대한 자세한 설명은 백기선님의 유튜브 'assertJ가 JUnit의 assertThat 보다 편리한 이유' 참고 (http://bit.ly/30vm9Lg)

#### param 
- API 테스트할 때 사용될 요청 파라키터를 설정합니다.
- 단, 값은 String만 허용됩니다.
- 그래서 숫자/날짜 등의 데이터도 등록할 때는 문자열로 변경해야만 가능합니다.

#### jsonPath
- JSON 응답값을 필드별로 검증할 수 있는 메소드 입니다.
- $를 기준으로 필드명을 명시합니다.
- 여기서는 name과 amount를 검증하니 $.name , $.amount로 검증합니다.





