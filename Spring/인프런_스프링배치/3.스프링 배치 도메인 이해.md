> 출처 : 인프런 스프링 배치 (장수원)

# 3.스프링 배치 도메인 이해
## 목차 소개

## Job
- job은 사실 하나의 명세서 또는 약간의 설게도와 같은 역할을 한다.
- JobLauncher가 배치를 싱행 시키는 주체
  * job, parameter를 받아서 Job을 실행 시킴
- Job은 스프링 배치의 모든 내용을 다 담고 있다고 보면됨. 왜냐하면 step을 포함하기 때문

### 기본개념
- 배치 계층 구조에서 가장 상위에 있는 개념으로서 하나의 배치작업 자체를 의미함
- Job Configuration 을 통해 생성되는 객체 단위로서 배치작업을 어떻게 구성하고 실행할 것인지 전체적으로 설정하고 명세해 놓은 객체
- 배치 Job 을 구성하기 위한 최상위 인터페이스이며 스프링 배치가 기본 구현체를 제공한다
- 여러 Step 을 포함하고 있는 컨테이너로서 반드시 한개 이상의 Step으로 구성해야 함

### 기본 구현체
#### SimpleJob
- 순차적으로 Step 을 실행시키는 Job
- 모든 Job에서 유용하게 사용할 수 있는 표준 기능을 갖고 있음

#### FlowJob
- 특정한 조건과 흐름에 따라 Step 을 구성하여 실행시키는 Job
- Flow 객체를 실행시켜서 작업을 진행함

## JobInstance
- 실행 관점에서의 job, step, flow는 실제로 배치 job을 실행하고 구성하기 위한 용도
- 실제로 수행이 되면 그 단계, 시점 마다 metadata, job의 실행정보, 상태정보, step의 실행정보, 상태정보 등을
데이터베이스에 저장하기 위한 용도의 도메인들이 job instance나 job excution, step excution, job paramers입니다.
- JobRepository: job을 실행중에 발생하는 메타 데이터들을 데이터베이스에 저장하고 업데이트 역할을 하는 클래스
  * Job, JobParameter 값이 존재 -> 기존 JobInstance 리턴 -> 동일한 내용으로는 수행할 경우 예외를 내며 실행되지 않음
  * Job, JobParameter 값이 존재X -> 새로운 JobInstance 생성
- 설정 `batch.job.enabled` 스프링 부트 시작시 배치잡 자동 실행 여부

### 기본개념
- Job이 실행 될 때 생성되는 Job의 논리적 실행 단위 객체로서 고유하게 식별 가능한 작업실행을 나타냄
- Job의 설정과 구성은 동일하지만 Job이 실행되는 시점에 처리하는 내용은 다르기 때문에 Job의 실행을 구분 해야함
  * 예를 들어 하루에 한 번 씩 배치 Job이 실행된다면 매일 실행되는 각각의 Job 을 JobInstance 로 표현합니다. 
- JobInstance 생성 및 실행
  * 처음 시작하는 Job + JobParameter 일 경우 새로운 JobInstance 생성
  * 이전과 동일한 Job + JobParameter 으로 실행 할 경우 이미 존재하는 JobInstance 리턴
    + 내부적으로 JobName + jobKey (jobParametes 의 해시값) 를 가지고 JobInstance 객체를 얻음 
- Job 과는 1:M 관계

### BATCH_JOB_INSTANCE 테이블과 매핑
- JOB_NAME (Job) 과 JOB_KEY (JobParameter 해시값) 가 동일한 데이터는 중복해서 저장할 수 없음

## JobParameter
- Key와 Value로 구성된 Map형 자료구조를 가짐
- `java -jar springbatchlecture-0.0.1-SNAPSHOT.jar name=user1 seq(long)=2L date(date)=2021/01/01 age(double)=16.5`
```java
    public void run(ApplicationArguments args) throws Exception {

        JobParameters jobParameters = new JobParametersBuilder().addString("name", "user1")
                .addLong("seq", 1L)
                .addDate("date", new Date())
                .toJobParameters();

        jobLauncher.run(job, jobParameters);
    }
```
```java
@Bean
    public Step step1() {
        return stepBuilderFactory.get("step1")
                .tasklet(new Tasklet() {
                    @Override
                    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {

                        JobParameters jobParameters = contribution.getStepExecution().getJobParameters();
                        String name = jobParameters.getString("name");
                        long seq = jobParameters.getLong("seq");
                        Date date = jobParameters.getDate("date");

                        System.out.println("===========================");
                        System.out.println("name:" + name);
                        System.out.println("seq: " + seq);
                        System.out.println("date: " + date);
                        System.out.println("===========================");

                        Map<String, Object> jobParameters2 = chunkContext.getStepContext().getJobParameters();
                        String name2 = (String)jobParameters2.get("name");
                        long seq2 = (long)jobParameters2.get("seq");

                        System.out.println("step1 has executed");
                        return RepeatStatus.FINISHED;
                    }
                })
                .build();
    }
```

### 기본개념
- Job을 실행할 때 함께 포함되어 사용되는 파라미터를 가진 도메인 객체
- 하나의 Job에 존재할 수 있는 여러개의 JobInstance를 구분하기 위한 용도
- JobParameters와 JobInstance는 1:1 관계
- 
### 생성 및 바인딩
- 어플리케이션 실행 시 주입
  * Java -jar LogBatch.jar requestDate=20210101
- 코드로 생성
  * JobParameterBuilder, DefaultJobParametersConverter
- SpEL 이용
  * @Value(“#{jobParameter[requestDate]}”), @JobScope, @StepScope 선언 필수

### BATCH_JOB_EXECUTION_PARAM 테이블과 매핑
- JOB_EXECUTION 과 1:M 의 관계

## JobExecution

### 기본개념
- JobIstance 에 대한 한번의 시도를 의미하는 객체로서 Job 실행 중에 발생한 정보들을 저장하고 있는 객체
  * 시작시간, 종료시간 ,상태(시작됨,완료,실패),종료상태의 속성을 가짐
- JobIstance 과의 관계
  * JobExecution은 'FAILED' 또는 'COMPLETED‘ 등의 Job의 실행 결과 상태를 가지고 있음
  * JobExecution 의 실행 상태 결과가 'COMPLETED’ 면 JobInstance 실행이 완료된 것으로 간주해서 재 실행이 불가함
  * JobExecution 의 실행 상태 결과가 'FAILED’ 면 JobInstance 실행이 완료되지 않은 것으로 간주해서 재실행이 가능함
    + JobParameter 가 동일한 값으로 Job 을 실행할지라도 JobInstance 를 계속 실행할 수 있음
  * JobExecution 의 실행 상태 결과가 'COMPLETED’ 될 때까지 하나의 JobInstance 내에서 여러 번의 시도가 생길 수 있음
  
### BATCH_JOB_EXECUTION 테이블과 매핑
- JobInstance 와 JobExecution 는 1:M 의 관계로서 JobInstance 에 대한 성공/실패의 내역을 가지고 있음

## Step
- 실제 비즈니스 로직이 들어가는 도메인

### 기본개념
- Batch job을 구성하는 독립적인 하나의 단계로서 실제 배치 처리를 정의하고 컨트롤하는 데 필요한 모든 정보를 가지고 있는 도메인 객체
- 단순한 단일 태스크 뿐 아니라 입력과 처리 그리고 출력과 관련된 복잡한 비즈니스 로직을 포함하는 모든 설정들을 담고있다.
- 배치작업을 어떻게 구성하고 실행할 것인지 Job 의 세부 작업을 Task 기반으로 설정하고 명세해 놓은 객체
- 모든 Job은 하나 이상의 step으로 구성됨

### 기본 구현체
#### TaskletStep
- 가장 기본이 되는 클래스로서 Tasklet 타입의 구현체들을 제어한다
#### PartitionStep
- 멀티 스레드 방식으로 Step 을 여러 개로 분리해서 실행한다
#### JobStep
- Step 내에서 Job 을 실행하도록 한다
#### FlowStep
- Step 내에서 Flow 를 실행하도록 한다

#### TaskletStep - 직접 생성한 Tasklet 실행
```java
public Step taskletStep() {
    return this.stepBuilderFactory.get("step")
            .tasklet(myTasklet())
            .build();
}
```

#### TaskletStep - ChunkOrientedTasklet 을 실행
```java
public Step taskletStep() {
    return this.stepBuilderFactory.get("step")
            .<Member, Member>chunk(100).reader(reader())
            .writer(writer())
            .build();
}
```

#### JobStep - Step 에서 Job 을 실행
```java
public Step jobStep() {
    return this.stepBuilderFactory.get("step")
            .job(job())
            .launcher(jobLauncher)
            .parametersExtractor(jobParametersExtractor())
            .build();
}
```

#### FlowStep - Step 에서 Flow 를 실행
```java
public Step flowStep() {
    return this.stepBuilderFactory.get("step")
            .flow(myFlow())
            .build();
}
```


## StepExecution

## StepContribution

## ExecutionContext

## JobRepository

## JobLauncher
