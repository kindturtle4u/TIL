
인덱스 튜닝

  B-Tree 인덱스
    오라클은 디스크 소트(Disk Sort)와 테이블 풀 스캔을 회피하기 위해 인덱스를 이용합니다.
    '디스크 소트'는 정렬 작업을 메모리 내에서 완료하지 못할 정도로 용량이 커서 디스크 공간까지 활용한 정렬 연산

    일반적으로 널리 사용되는 인덱스는 B-Tree 인덱스 (그외 Bitmap ,함수기반 등)
    B-Tree 인덱스는 데이터가 정렬된 상태로 저장되어서 부하가 큰 sort 연산을 회피하는데 유용하게 이용됨

    단일 컬럼 인덱스 : 한개의 컬럼으로만 구성
    복합 컬럼 인덱스 : 2개 이상의 컬럼으로 구성된 인덱스

    선택도
      인덱스 스캔이 테이블 풀 스캔에 비해 반드시 유리한것은 아님
      선택도가 높은 컬럼은 풀스캔이 유리하다
      선택도(%) = (1/Distinct Value) x 100

    인덱스는 선택도가 낮은 컬럼에 생성하는 것이 유리
    인덱스와 테이블은 논리적/물리적으로 완전히 분리되어있는 각각의 Object

    인덱스가 생성된 컬럼은 NVL 또는 TRIM과 같은 내장 함수로 감싸면 해당 인덱스 사용이 불가능
    
    인덱스 수직 탐색
      루트 블록 (Root Block) , 리프 블록 (Leaf Block) 수직으로만 탐색하는 기법
    
    인덱스 수평 탐색
      인덱스의 리프 블록을 인덱스의 논리적 순서에 따라 수평으로 탐색하는 것

    테이블 랜덤 액세스 (Table Random Access)
      인덱스 스캔이 성공하면 해당 ROWID를 이용하여 테이블 액세스
    
      테이블 랜덤 액세스가 많아지면 시스템에 많은 부하를 주게됨. 테이블 랜덤 액세스를 줄이는것이인덱스 스캔 튜닝의 핵심 이슈가 됩니다.

      소량의 데이터라면 테이블 랜덤 액세스는 성능에 큰 지장을 주지 않지만
      대량의 데이터를 인덱스 스캔 후 테이블 랜덤 액세스 하는 횟수가 많아지면 시스템에 큰 부하

      테이블 랜덤 액세스 횟수로 인덱스 스캔의 효율을 평가하기도 함.
      특정 인덱스를 스캔하여 100건이 나왔고 테이블 랜덤 액세스 후의 결과도 100건이라면, 인덱스 스캔의 비효율은 없다고 평가

      액세스 후 결과가 1건이라면, 인덱스 스캔의 비효율이 크므로 다른 인덱스를 사용하거나 인덱스 조정 및 컬럼 추가를 해야함.

    인덱스 스캔 튜닝 관련 힌트
      INDEX
        사용자가 지정한 테이블과 인덱스를 선태갛여 인덱스를 스캔을 유도
        SELECT /*+ INDEX(테이블 인덱스) */

      FULL
        특정 테이블에 대해 인덱스 스캔이 아닌 테이블 풀 스캔을 하도록 유도합니다.
        SELECT /*+ FULL(테이블) */

      


      

        


      

      
        











