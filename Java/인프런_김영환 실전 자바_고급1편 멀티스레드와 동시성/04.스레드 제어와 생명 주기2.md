> 출처 : 인프런 김영한의 실전 자바 - 고급1편 멀티스레드와 동시성 (김영한)

# 04.스레드 제어와 생명 주기2
## 인터럽트 - 시작1
```java
public class ThreadStopMainV1 {

    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread thread = new Thread(task, "work");
        thread.start();

        sleep(4000);
        log("작업 중단 지시 runFlag=false");
        task.runFlag = false;
    }

    static class MyTask implements Runnable {

        volatile boolean runFlag = true;

        @Override
        public void run() {
            while (runFlag) {
                log("작업 중");
                sleep(3000);
            }
            log("자원 정리");
            log("자원 종료");
        }
    }
}
```
- `volatile` 키워드는 뒤에서 자세히 설명한다. 지금은 단순히 여러 스레드에서 공유하는 값에 사용하는 키워드 라고 알아두자.
- 참고로 `runFlag` 를 변경한 후 2초라는 시간이 지난 이후에 작업이 종료되는 이유는 `work` 스레드가 3초에 한 번씩 깨어나서 `runFlag` 를 확인하는데, `main` 스레드가 4초에 `runFlag` 를 변경했기 때문이다.

## 인터럽트 - 시작2
```java
public class ThreadStopMainV2 {

    public static void main(String[] args) {
        MyTask task = new MyTask();
        Thread thread = new Thread(task, "work");
        thread.start();

        sleep(4000);
        log("작업 중단 지시 thread.interrupt()");
        thread.interrupt();
        log("work 스레드 인터럽트 상태1 = " + thread.isInterrupted());
    }

    static class MyTask implements Runnable {

        @Override
        public void run() {
            try {
                while (true) {
                    log("작업 중");
                    Thread.sleep(3000);
                }
            } catch (InterruptedException e) {
                log("work 스레드 인터럽트 상태2 = " + Thread.currentThread().isInterrupted());
                log("interrupt message=" + e.getMessage());
                log("state=" + Thread.currentThread().getState());
            }
            log("자원 정리");
            log("자원 종료");
        }
    }
}
```
```log
2024-09-15 15:52:03.673 [     work] 작업중
2024-09-15 15:52:06.681 [     work] 작업중
2024-09-15 15:52:07.657 [     main] 작업 중단 지시 runFlag=false
2024-09-15 15:52:07.661 [     main] work 스레드 인터럽트 상태1 = true
2024-09-15 15:52:07.661 [     work] work 스레드 인터럽트 상태2 = false
2024-09-15 15:52:07.661 [     work] interrupt message=sleep interrupted
2024-09-15 15:52:07.662 [     work] state=RUNNABLE
2024-09-15 15:52:07.662 [     work] 자원 정리
2024-09-15 15:52:07.662 [     work] 자원 종료
```
- 인터럽트를 사용하면, `WAITING` , `TIMED_WAITING` 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 `RUNNABLE`상태로 만들 수 있다.
- `interrupt()` 를 호출했다고 해서 즉각 `InterruptedException` 이 발생하는 것은 아니다. 오직`sleep()` 처럼 `InterruptedException` 을 던지는 메서드를 호출 하거나 또는 호출 중일 때 예외가 발생한다.
- `thread.interrupt()` 를 통해 작업 중단을 지시를 하고, 거의 즉각적으로 인터럽트가 발생한 것을 확인할 수 있다.
- 이때 `work` 스레드는 `TIMED_WAITNG` `RUNNABLE` 상태로변경되면서 `InterruptedException` 예외 가 발생한다.
- 인터럽트가 적용되고, 인터럽트 예외가 발생하면, 해당 스레드는 실행 가능 상태가 되고, 인터럽트 발생 상태도 정상으로 돌아온다.

## 인터럽트 - 시작3

## 인터럽트 - 시작4

## 프린터 예제1 - 시작

## 프린터 예제2 - 인터럽트 도입

## 프린터 예제3 - 인터럽트 코드 개선

## yield - 양보하기

## 프린터 예제4 - yield 도입

## 정리
