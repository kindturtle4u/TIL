> 출처 : 자바 ORM 표준 JPA 프로그래밍 읽으면서 정리  

# 15. 고급 주제와 성능 최적화
## 15.1 예외처리
JPA 표준 예외들은 javax.presistence.PersistenceException의 자식 클래스다.
JPA 표준 예외는 크게 2가지로 나눌 수 있다.
- 트랜잭션 롤백을 표시하는 예외
- 트랜잭션 롤백을 표시하지 않는 예외

### 15.1.2 스프링 프레임워크의 JPA 예외 변환
스프링 프레임워크는 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.

### 15.1.3 스프링 프레임워크에 JPA 예외 변환기 적용
### 15.1.4 트랜잭션 롤백 시 주의사항
트랜잭션을 롤백하는 것은 데이터베이스 반영사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지는 않는다.

## 15.2 엔티티 비교
영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 있다. 이 1차 캐시는 영속성 컨텍스트와 생명주기를 같이한다.

### 15.2.1 영속성 컨텍스트가 같을 때 엔티티 비교
영속성 컨텍스트가 같으면 엔티티를 비교할때 다음 3가지 조건을 모두 만족한다.

- 동일성(identical): == 비교가 같다.
- 동등성(equinalent): equals()비교가 같다.
- 데이터베이스 동등성:@Id인 데이터베이스 식별자가 같다.

### 15.2.2 영속성 컨텍스트가 다를 때 엔티티 비교
- 동일성(identical): == 비교가 실패한다.
- 동등성(equinalent): equals()비교가 만족한다. 단 equals()를 구현해야 한다.
- 데이터베이스 동등성:@Id인 데이터베이스 식별자가 같다.

## 15.3 프록시 심화 주제
### 15.3.1 영속성 컨텍스트와 프록시
프록시를 반환하더라도 영속성 컨텍스트틑 자신이 관리하는 영속 엔티티의 동일성을 보장한다.

### 15.3.2 프록시 타입 비교
프록시는 원본 엔티티를 상속받아서 만들어지므로 타입 비교할 때는 == 비교를 하면 안되고 대신에 instanceof를 사용해야 한다.

### 15.3.2 프록시 동등성 비교
- 프록시의 타입 비교는 == 비교 대신에 instanceof를 사용해야한다.
- 프록시의 멤버 변수에 직접 접근하면 안되고 대신에 접근자 메소드를 사용해야한다.

### 15.3.4 상속관계와 프록시
프록시를 부모 타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성되는 문제가 있다.
- instanceof 연산을 사용할 수 없다.
- 하위 타입으로 다운 캐스팅을 할 수 없다.

상속관계에서 발생하는 프록시 문제 해결방법
- JPQL로 대상 직접 조회하기
- 프록시 벗기기
- 기능을 위한 별도의 인터페이스 제공
- 비지터 패턴 사용

## 15.4 성능 최적화
### 15.4.1 N+1 문제
- 페치 조인 사용
- 하이버네이트 @BatchSize: 조회할때 지정한 SIZE만큼 SQL의 IN절을 사용해서 조회한다.
- 하이버네이트 @Fetch(FetchMode.SUBSELECT): 연관된 데이터를 조회할 때 서브쿼리를 사용해서 N+1 문제를 해결한다.

#### N+1 정리
즉시 로딩은 사용하지 말고 지연로딩만 사용하는 것이다. 성능 최적화가 꼭 필요한 곳에는 JPQL 페치 조인을 사용하자.
- @OneToOne, @ManyToOne: 기본 페치 전략은 즉시 로딩
- @OneToMany, @ManyToMany: 기본 페치 전략은 지연 로딩

따라서 기본값이 즉시 로딩인 @OneToOne,@ManyToOne도 지연로딩 전략을 사용하도록 변경하자.

### 15.4.2 읽기 전용 쿼리의 성능 최적화
영속성 컨텍스트는 변경 감지를 위해 스탭샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다.
- 스칼라 타입으로 조회: 스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.
- 읽기 전용 쿼리 힌트 사용
- 읽기 전용 트랜잭션 사용
- 트랜잭션 밖에서 읽기

### 15.4.3 배치 처리
일반적인 방식으로 엔티티를 계속 조회하면 영속성 컨텍스트에 아주 많은 엔티티가 쌓이면서 메모리 부족 오류가 발생한다.
또한, 2차 캐스에 엔티티를 보관하지 않도록 주의해야 한다.

#### JPA 등록 배치
영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록 일정 단위마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화 해야한다.

#### JPA 페이징 배치 처리
#### 하이버네이트 scroll 사용
#### 하이버네이트 무상태 세션 사용
무산태 세션은 영속성 컨텍스트를 만들지 않고 심지어 2차 캐시도 사용하지 않는다.

### 15.4.4 SQL 쿼리 힌트 사용
SQL 힌트는 하이버 네이트 쿼리가 제공하는 addQueryHint() 메소드를 사용한다.
```java
session.createQuery("select m from Member m")
    .addQueryHint("FULL (MEMBER)") // SQL HINT 추가
    .list();
```
### 15.4.5 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
## 15.5 정리