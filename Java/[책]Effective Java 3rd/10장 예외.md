> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 10장 예외
## 아이템 69 - 예외는 진짜 예외 상황에만 사용하라
- 예외는( 그 이름이 말해주듯) 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.
- 더 일반화해 이야기하면 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라.
- 잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야한다.

## 아이템 70 - 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
- 자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세가지를 제공하는데, 
  언제 무엇을 사용해야 하는지 헷갈려 하는 프로그래머 들이 종종있다.
- 호출하려는 쪽에서 복구하리라 여겨지는 상황이면 검사 예외를 사용하라. 검사예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나
  더 바깥으로 전파하도록 강제하게 된다.
- 비검사 throwable은 두가지로, 바로 런타임 예외와 에러다. 이 둘은 프로그램에서 잡을 필요가 없거나 혹은 통상적으로는 잡지 말아야 한다.
  프로그램에서 비검사 예외나 에러를 던졌다는 것은 복구가 불가능하거나 더 실행해봐야 득보다 실이 많다는 뜻이다.
- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
- 에러는 보통 JVM이 자원 부족, 불변식 깨짐 등 더 이상 수행을 계속할 수 없는 상황을 나타낼 때 사용한다. Error클래스를 상속해 하위 클래스를 만드는 일은
  자제하기 바란다. 다시 말해 여러분이 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다.(직접적이든 간접적이든)
  Error는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다.(AssertionError는 예외다.)

## 아이템 71 - 필요없는 검사 예외 사용은 피하라
- 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다. 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환하면 된다.
- 또 다른 방법으로는, 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.
- 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다.

## 아이템 72 - 표준 예외를 사용하라
- 표준 예외를 재사용하면 얻는 게 많다. 그중 최고는 여러분의 API가 다른 사람이 익히고 사용하기 쉬워진다는 것이다.
- 가장 많이 재사용되는 예외는 **IllegalArgumentException**이다. 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외
- **IllegalStateException**도 자주 재사용된다. 이 예외는 대상 객체의 상태가 호출된 메서드 수행하기 적합하지 않을 때 주로 던진다.
  예컨대 제대로 초기화되지 않은 객체를 사용하려 할 때 던질 수 있다.
- null 값을 허용하지 않는 메서드에 null을 건네면 관례상 IllegalArgumentException이 아닌 **NullPointerException**을 던진다.
- 어떤 시퀀스의 허용 범위를 넘는 값을 건넬 때도 IllegalArgumentException보다는 **IndexOutOfBoundsException**을 던진다.
- **ConcurrentModificationException**은 단일 스레드엣 ㅓ사용하려고 설계한 개체를 여러 스레드가 동시에 수정하려 할 때 던진다.
- **UnsupportedOperationException** 이 예외는 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던진다.
- Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자. 이 클래스들은 추상 클래스라고 생각하길 바란다.
- 일반적인 규칙은 이렇다. 인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException을, 그렇지 않으면 IllegalArgumentException을 던지자.

## 아이템 73 - 추상화 수준에 맞는 예외를 던지라
- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던저야 한다.
  이를 예외 번역(exception translation)이라 한다.
```java
try {
    ... // 저수준 추상화를 이용한다.
} catch (LowerLevelException e) {
    throw new HigherLevelException(...);    
}
```
- 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄(exception chaining)를 사용하는 게 좋다. 예외 연쇄란 문제의 근본 원인(cause)인 
  저 수준 예외를 고수준 예외에 실어 보내는 방식이다. 그러면 별도의 접근자 메서드 (Throwable의 getCause 메서드)를 통해 필요하면 언제든 저수준 예외를 꺼내
  볼 수 있다. `throw new HigherLevelException(cause);`
- 무턱대고 예외를 전파하는 것보다야 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다. 
  가능하면 저수준 메서드가 반드시 성공하도록하여 아래 계층에서는 예외가 발생하지 않도록 하는것이 최선이다.

## 아이템 74 - 메서드가 던지는 모든 예외를 문서화하라
- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화하자.
- 극단적인 예로 메서드가 Exception이나 Throwable을 던진다고 선언해서는 안 된다. 메서드는 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못할 뿐더러,
  같은 맥락에서 발생할 여지가 있는 다른 예외들까지 삼겨버릴수 있어 API 사용성을 크게 떨어 뜨린다.
- 비검사 예외도 검사 예외처럼 정성껏 문서화해두면 좋다.
- 메서드가 던질 수 있는 예외를 각각 자바독 @throws 태그로 문서화하되, 비검사 예외는 메서드의 선언의 throws 목록에 넣지 말자.

## 아이템 75 - 예외의 상세 메시지에 실패 관련 정보를 담으라
- 실패 순간을 포착하려면 발생한 예외에 관련된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 한다.
  예컨데 IndexOutofBoundsException의 상세 메시지는 범위의 최솟값과 최댓값, 그리고 그 범위를 벗어났다는 인덱스의 값을 담아야 한다.
- 예외의 상세 메시지와 최종사용자에게 보여줄 오류 메시지를 혼동해서는 안된다. 최종사용자에게는 친절한 안내 메시지를 보여줘야 하는 반면, 
  예외 메시지는 가독성 보다는 담긴 내용이 훨씬 중요하다.

## 아이템 76 - 가능한 한 실패 원자적으로 만들가

## 아이템 77 - 예외를 무시하지 말라
