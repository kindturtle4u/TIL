> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 11장 동시성
## 아이템 78 - 공유 중인 가변 데이터는 동기화해 사용하라
- 동기화(syncrhonized)는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
- Thread.stop 메서드는 안전하지 않아 오래전에 사용 자제(deprecated) API로 지정되었다(이 메서드를 사용하면 데이터가 훼손될 수 있다).
- 쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다.
- volatile 한정자는 배타적 수행과는 상관없지만 하상 가장 최근에 기록된 값을 읽게 됨을 보장한다.
- java.util.concurretn.atomic 패키지의 AtomicLong을 사용해보자. 
  이 패키지에는 락 없이도 (lock-free;락-프리) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨있다. 
- 가변 데이터는 단일 스레드에서만 쓰도록 하자
- 여러 스레드가 가변데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야한다.

## 아이템 79 - 과도한 동기화는 피하라
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.

## 아이템 80 - 스레드보다는 실행자, 태스크, 스트림을 애용하라
- java.util.concurrent 이 패키지는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.
- 작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택일 것이다.
- 태스크에는 두가 지가 있다. 바로 Runnable과 그 사촌인 Callable이다(Callable은 Runable과 비슷하지만 값을 반환하고 임의이 예외를 던질수 있다.)

## 아이템 81 - wait와 notify보다는 동시성 유틸리티를 애용하라

## 아이템 82 - 스레드 안전성 수준을 문서화하라

## 아이템 83 - 지연 초기화는 신중히 사용하라

## 아이템 84 - 프로그램의 동작을 스레드 스케줄러에 기대하지 말라


