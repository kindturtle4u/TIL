> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  

# 6장 열거타입과 애너테이션
## 아이템 34 - int 상수 대신 열거 타입을 사용하라
- 정수 열거 패턴(int enum pattern) 기법에는 단점이 많다.
    * 타입 안전을 보장하는 방법이 없으며 표현력도 좋지 않다.
    * 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.
- 열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 만들어 public static final 필도로 공개한다.
- 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.
- 따라서 클라이언트가 인스턴스를 직접 생성하거나 확잘 할 수 없으니 열거 타입으로 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재한다.
- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면된다.
- 열거 타입은 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 정적 메서드인 values를 제공한다.
- 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만든다.
- 열거 타입은 상수별로 다르게 동작하는 코드를 구현하는 수단을 제공한다. 상수별 메서드 구현 
  `ex) PLUS("+") { public double apply(double x, double y){return x+y} //apply 는 추상메서드}`
- 필요한 원소를 컴파일 타입에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.

## 아이템 35 - ordinal 메서드 대신 인스턴스 필드를 사용하라
- ordinal 메서드: 해당 상수가 그 열거 타입에서 몇번째 위치인지를 반환하는 메서드
- 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지말고, 인스턴스 필드에 저장하자 `public enum Ensemble { SOLE(1), DUET(2) ... }`

## 아이템 36 - 비트 필드 대신 EnumSet을 사용하라
- 비트별 OR를 사용해 여러 상수를 하나의 집합으로 모을수 있으며, 이렇게 만들어진 집합을 비트 필드(bit field)라 한다.
  `text.applyStyles(STYLE_BOLD | STYLE_ITALIC)`
- EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공하고 열거 타입의 장점까지 선사하기 때문이다.

## 아이템 37 - 인덱싱 대신 EnumMap을 사용하라
-  배열의 인덱스를 얻기 위해 ordinal을 쓰는 것을 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.

## 아이템 38 - 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
- 기본 아이디어는 열거타입이 임의의 인터페이스를 구현할 수 있다는 사실을 이요하는 것이다.
- 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현한 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다.

## 아이템 39 - 명명 패턴보다 애너테이션을 사용하라
- 마커 애너테이션: 아무 매개변수 없이 단순히 대상에 마킹(marking)한다
- 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.
- 자바 프로그래머라면 예외 없이 자바가 제공하는 애너테이션 타입들을 사용해야 한다.

## 아이템 40 - @Override 애너테이션을 일관되게 사용하라
- @Override는 메서드 선언에만 달 수 있으며, 이 애너테이션이 달렸따는 것은 상위 타입의 메서드를 재정의 했음을 뜻한다.
- 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 애너테이션을 달자
- 재정의한 모든 메서드에 @Override 애너테이션을 의식적으로 달면 여러분이 실수했을때 컴파일러가 바로 알려줄 것이다.

## 아이템 41 - 정의하려는 것이 타입이라면 마케 인터페이스를 사용하라
- 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표지해주는 인터페이스를 마커 인터페이스라 한다.
  ex) Serializable은 자신이 구현한 클래스의 인스턴스는 ObjectOuputStream을 통해 쓸(write) 수 있다고, 즉 직렬화 할수 있다고 알려준다.
- 마커 인터페이스는 두가지 면에서 마커 애너테이션보다 낫다.
    * 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 애너테이션은 그렇지 않다.
    * 마커 인터페이스가 나은 점 두번째는 적용 대상을 더 정밀하게 지정할 수 있다.
- 클래스와 인터페이스 이외의 프로그램 요소(모듈,패키지,필드,지역변수 등)에 마킹해야 할 때 애너테이션을 쓸 수 밖에 없다.
- 마커를 클래스나 인터페이스에 적용해야한다면 "이 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을까?" 답이 "그렇다" 이면 
  마커 인터페이스를 써야한다.
_ 적용대상이 ElementType.TYPE인 마커 애너테이션을 작성하고 있다면, 잠시 여유를 갖고 정말 애너테이션으로 구현하는게 옳은지, 혹은
  마커 인터페이스가 낫지 않을지 곰곰이 생각해보자

