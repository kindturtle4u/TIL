> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 6장 열거타입과 애너테이션
## 아이템 34 - int 상수 대신 열거 타입을 사용하라
- 정수 열거 패턴(int enum pattern) 기법에는 단점이 많다.
    * 타입 안전을 보장하는 방법이 없으며 표현력도 좋지 않다.
    * 정수 열거 패턴을 사용한 프로그램은 깨지기 쉽다.
- 열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 만들어 public static final 필도로 공개한다.
- 열거 타입은 밖에서 접근할 수 있는 생성자를 제공하지 않으므로 사실상 final이다.
- 따라서 클라이언트가 인스턴스를 직접 생성하거나 확잘 할 수 없으니 열거 타입으로 선언으로 만들어진 인스턴스들은 딱 하나씩만 존재한다.
- 열거 타입 상수 각각을 특정 데이터와 연결지으려면 생성자에서 데이터를 받아 인스턴스 필드에 저장하면된다.
- 열거 타입은 자신 안에 정의된 상수들의 값을 배열에 담아 반환하는 정적 메서드인 values를 제공한다.
- 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고, 특정 톱레벨 클래스에서만 쓰인다면 해당 클래스의 멤버 클래스로 만든다.
- 열거 타입은 상수별로 다르게 동작하는 코드를 구현하는 수단을 제공한다. 상수별 메서드 구현 
  `ex) PLUS("+") { public double apply(double x, double y){return x+y} //apply 는 추상메서드}`
- 필요한 원소를 컴파일 타입에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.

## 아이템 35 - ordinal 메서드 대신 인스턴스 필드를 사용하라
- ordinal 메서드: 해당 상수가 그 열거 타입에서 몇번째 위치인지를 반환하는 메서드
- 열거 타입 상수에 연결된 값은 ordinal 메서드로 얻지말고, 인스턴스 필드에 저장하자 `public enum Ensemble { SOLE(1), DUET(2) ... }`

## 아이템 36 - 비트 필드 대신 EnumSet을 사용하라
- 비트별 OR를 사용해 여러 상수를 하나의 집합으로 모을수 있으며, 이렇게 만들어진 집합을 비트 필드(bit field)라 한다.
  `text.applyStyles(STYLE_BOLD | STYLE_ITALIC)`
- EnumSet 클래스가 비트 필드 수준의 명료함과 성능을 제공하고 열거 타입의 장점까지 선사하기 때문이다.

## 아이템 37 - 인덱싱 대신 EnumMap을 사용하라
-  배열의 인덱스를 얻기 위해 ordinal을 쓰는 것을 일반적으로 좋지 않으니, 대신 EnumMap을 사용하라.

## 아이템 38 - 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라
- 기본 아이디어는 열거타입이 임의의 인터페이스를 구현할 수 있다는 사실을 이요하는 것이다.
- 열거 타입 자체는 확장할 수 없지만, 인터페이스와 그 인터페이스를 구현한 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다.

## 아이템 39 - 명명 패턴보다 애너테이션을 사용하라
- 마커 애너테이션: 아무 매개변수 없이 단순히 대상에 마킹(marking)한다
- 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없다.
- 자바 프로그래머라면 예외 없이 자바가 제공하는 애너테이션 타입들을 사용해야 한다.

## 아이템 40 - @Override 애너테이션을 일관되게 사용하라
- @Override는 메서드 선언에만 달 수 있으며, 이 애너테이션이 달렸따는 것은 상위 타입의 메서드를 재정의 했음을 뜻한다.
- 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 애너테이션을 달자
- 재정의한 모든 메서드에 @Override 애너테이션을 의식적으로 달면 여러분이 실수했을때 컴파일러가 바로 알려줄 것이다.

## 아이템 41 - 정의하려는 것이 타입이라면 마케 인터페이스를 사용하라
- 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표지해주는 인터페이스를 마커 인터페이스라 한다.
  ex) Serializable은 자신이 구현한 클래스의 인스턴스는 ObjectOuputStream을 통해 쓸(write) 수 있다고, 즉 직렬화 할수 있다고 알려준다.
- 마커 인터페이스는 두가지 면에서 마커 애너테이션보다 낫다.
    * 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입으로 쓸 수 있으나, 마커 애너테이션은 그렇지 않다.
    * 마커 인터페이스가 나은 점 두번째는 적용 대상을 더 정밀하게 지정할 수 있다.
- 클래스와 인터페이스 이외의 프로그램 요소(모듈,패키지,필드,지역변수 등)에 마킹해야 할 때 애너테이션을 쓸 수 밖에 없다.
- 마커를 클래스나 인터페이스에 적용해야한다면 "이 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을까?" 답이 "그렇다" 이면 
  마커 인터페이스를 써야한다.
_ 적용대상이 ElementType.TYPE인 마커 애너테이션을 작성하고 있다면, 잠시 여유를 갖고 정말 애너테이션으로 구현하는게 옳은지, 혹은
  마커 인터페이스가 낫지 않을지 곰곰이 생각해보자

> 출처 : 백기선님의 라이브 스터디 - 자바 기초 스터디
# 인터페이스
- 모든 변수는(상수) public static final이 붙어야 하며, 생략시 컴파일러가 자동으로 추가해준다.
- 모든 메서드는 public absrtact이 붙어야 하며, 생략가능하다.
    * 단, static 메서드와 default 메서드는 예외이다. (JDK 1.8부터)
```java
public interface 인터페이스명 {
    // 상수
    타입 상수명 = 값;
    
    // 추상메소드
    타입 메소드명(매개변수, ...);
    
    // 디폴트 메소드
    default 타입 메소드명(매개변수, ...) {
        // 구현부
    }
    
    // 정정 메소드
    static 타입 메소드명(매개변수, ...) {
        // 구현부
    }
}
```
- 추상클래스는 "is-a : ~는 ~이다" 의 개념이다.
- 인터페이스는 "has-a: ~s는 ~를 할 수 있다."의 개념이다.

# Enum
- .values() 메소드의 반환 결과는 배열형태로 반환되는 것을 확인할 수 있다.
- .values() 메소드는 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 추가해준다.
    * 또한, .values() 메소드는 Enum 클래스의 Static Methods 이다.
    * Enum 클래스의 또다른 Static Method는 valueOf가 있다.
  
# 애노테이션
- 어노테이션은 주석이라는 뜻을 가지고 있다.
- @Target: 어노테이션이 적용 가능한 대상을 지정하는데 사용된다.
    * CONTRUCTOR: 생성자 선언시
    * FIELD: enum 상수를 포함한 필드(field) 값 선언시
    * LOCAL_VARIABLE: 지역 변수 선언시
    * METHOD: 메소드 선언시
    * PACKAGE: 패키지 선언시
    * PARAMETER: 매개 변수 선언시
    * TYPE: 클래스,인터페이스,enum등 선언시
- @Retention: 어노테이션이 유지되는 범위를 지정하는데 사용된다.
    * source로 사용되면 일반 주석처럼 사용된다는 뜻이다. 대표적으로 @Override를 들수 있다.
    * class 컴파일될때까지 어노테이션을 유지한다는 것을 의미한다.
    * runtime 실행시 어노테이션 정보가 가상 머신에 의해서 참조가능
- 어노테이션 프로세서
    * 자바 컴파일러의 컴파일 단계에서, 유저가 정의한 어노테이션의 소스코드를 분석하고 처리하기 위해 사용되는 훅이다.
    * 컴파일 에러나 컴파일 경고를 만드럭나, 소스코드(.java)와 바이트 코드(.class)를 내보내기도 한다.
    * 사용예) Lombok , @Override ...
  

  