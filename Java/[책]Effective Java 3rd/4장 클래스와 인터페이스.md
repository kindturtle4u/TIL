> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)

# 4장 클래스와 인터페이스
- 추상화의 기본 단위인 클래스와 인터페이스는 자바 언어의 심장과도 같다.
  
## 아이템 15 - 클래스와 멤버의 접근 권한을 최소화하라
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다.
- 정보 은닉의 장점
  * 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
  * 시스템 관리 비용을 낮춘다.
  * 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
  * 소프트웨어 재사용성을 높인다.
  * 큰 시스템을 제작하는 난이도를 낮춰준다.
- 기본원칙은 간단한다. 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.
- public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안된다.

## 아이템 16 - public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
- 패키지 바깥에서 접근할 수 있는 클래스라면 접근자를 제공
- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.
- public 클래스는 절대 가변 필드를 직접 노출해서는 안된다.

## 아이템 17 - 변경 가능성을 최소화하라
- 불변 클래스란 간단히 말해 그 인스턴스 내부 값을 수정할 수 없는 클래스다.
- 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다.(String,BigInteger,BigDecimal)
- 클래스를 불변으로 만들려면 다음 다섯가지 규칙을 따르면 된다.
    * 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.
    * 클래스를 확장할 수 없도록 한다.
    * 모든 필드를 final로 선언한다.
    * 모든 필드를 private으로 선언한다.
    * 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
- 불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다.
- 불변 클래스에도 단점은 있다. 값이 다르면 반드시 독립된 객체로 만들어야 한다는 것이다.
- 게터(getter)가 있다고 해서 무조건 세터(setter)를 만들지는 말자
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.

## **아이템 18 - 상속보다는 컴포지션을 사용하라**
- 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다.
- 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있으며, 그 여파로 코드 한줄 건드리지 않은 하위 클래스가 오동작 할 수 있다는 말이다.
- 기존 클래스가 새로운 클래스의 구성요소를 쓰인다는 뜻에서 이러한 설계를 컴포지션(composition)이라 한다.
- 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환한다. 이방식을 전달(forwarding)이라 하며, 
  새 클래스의 메서드들은 전달 메서드(forwarding method)라 부른다.
- 인스턴스를 감싸고(wrap) 있다는 뜻에서 InstrumentedSet 같은 클래스를 래퍼 클래스라 하며, 
  다른 Set에 계측 기능을 덧씌운다는 뜻에서 데코레이터 패턴(Decorator pattern)이라고 한다.
- 상속은 바드시 하위 클래스가 상위 클래스의 '진짜' 하위 타입인 상황에서만 쓰야한다.( is-a 관계)

## 아이템 19 - 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
- 상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 '유일' 하다.
- 상속용으로 설계한 클래스는 배포전에 반드시 하위 클래스를 만들어 검증해야 한다.
- Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다.
  둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않는 생각이다.
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

## 아이템 20 - 추상 클래스보다는 인터페이스를 우선하라
- 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두 가지다.
- 자바 8부터 인터페이스도 디폴트 메서드(default method)를 제공할 수 있게 되어 
  이제는 두 매커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.
- 인터페이스는 믹스인(mixin) 정의에 안성 맞춤이다.
    * 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.
- 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함계 제공하는 식으로 인터페이스와 추상 클래스의 장점을 모두 취하는 방법도 있다.
    * 인터페이스로는 타입을 정의하고,  필요하면 디폴트 메서드 몇 개도 함께 제공한다.
    * 골격 구현 클래스는 나무지 메서드들까지 구현다.
    * 이렇게 해두면 단순히 골격 구현을 확장하는 것만으로 이 인터페이스를 구현하는데 필요한 일이 대부분 완료된다. 바로 템플릭 메서드 패턴이다.
    * 좋은예로 컬렉션 프레임워크의 AbstractCollection, AbstractSet, AbstractList, AbstractMap
- equlas와 hashCode 같은 Object의 메서드는 디폴트 메서드로 제공하면 안된다
- 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함꼐 제공하는 방법을 꼭 고려해보자
    
