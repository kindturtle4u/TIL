> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 12장 직렬화
- 객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로 부터 다시 객체를 재구성하는(역질렬화) 메커니즘이다.
- 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역질렬화 할 수 있다.

## 아이템 85 - 자바 직렬화의 대안을 찾으라
- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 여러분이 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.
- 레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 대의 차선책은 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.
  특히, 신뢰할 수 없는 발신원으로부터의 RMI(Remote Method Invocation)는 절대 수용해서는 안된다.
- 직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체 역직렬화 필터링을 사용하자.(자바9) 
  데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다.
- 직렬화는 위험하니 피해야 한다. 시스템을 밑바닥부터 설계한다면 JSON이나 프로토콜 버퍼같은 대안을 사용하자.

## 아이템 86 - Serializable을 구현할지는 신중히 결정하라
- Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.
- Serializable 구현의 두번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점이다.
  객체는 생성자를 사용해 만드는게 기본이다. 즉, 직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법인 것이다.
- 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장해서는 안된다.
- 내부 클래스는 직렬화를 구현하지 말아야 한다. 내부 클래스에 대한 기본 직렬화 형태는 분명하지가 않다.
  단, 정적 멤버 클래스는 Serializable을 구현해도 된다.

## 아이템 87 - 커스텀 직렬화 형태를 고려해보라
- 먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때 많다.
- transient 한정자는 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시다.
- 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
  구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.
  
## 아이템 88 - readObject 메서드는 방어적으로 작성하라

## 아이템 89 - 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라

## 아이템 90 - 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
