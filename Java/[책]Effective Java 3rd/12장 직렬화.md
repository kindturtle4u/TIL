> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 12장 직렬화
- 객체 직렬화란 자바가 객체를 바이트 스트림으로 인코딩하고(직렬화) 그 바이트 스트림으로 부터 다시 객체를 재구성하는(역질렬화) 메커니즘이다.
- 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역질렬화 할 수 있다.

## 아이템 85 - 자바 직렬화의 대안을 찾으라
- 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 여러분이 작성하는 새로운 시스템에서 자바 직렬화를 써야 할 이유는 전혀 없다.
- 레거시 시스템 때문에 자바 직렬화를 완전히 배제할 수 없을 대의 차선책은 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는 것이다.
  특히, 신뢰할 수 없는 발신원으로부터의 RMI(Remote Method Invocation)는 절대 수용해서는 안된다.
- 직렬화를 피할 수 없고 역직렬화한 데이터가 안전한지 완전히 확신할 수 없다면 객체 역직렬화 필터링을 사용하자.(자바9) 
  데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능이다.
- 직렬화는 위험하니 피해야 한다. 시스템을 밑바닥부터 설계한다면 JSON이나 프로토콜 버퍼같은 대안을 사용하자.

## 아이템 86 - Serializable을 구현할지는 신중히 결정하라
- Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.
- Serializable 구현의 두번째 문제는 버그와 보안 구멍이 생길 위험이 높아진다는 점이다.
  객체는 생성자를 사용해 만드는게 기본이다. 즉, 직렬화는 언어의 기본 메커니즘을 우회하는 객체 생성 기법인 것이다.
- 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안되며, 인터페이스도 대부분 Serializable을 확장해서는 안된다.
- 내부 클래스는 직렬화를 구현하지 말아야 한다. 내부 클래스에 대한 기본 직렬화 형태는 분명하지가 않다.
  단, 정적 멤버 클래스는 Serializable을 구현해도 된다.

## 아이템 87 - 커스텀 직렬화 형태를 고려해보라
- 먼저 고민해보고 괜찮다고 판단될 때만 기본 직렬화 형태를 사용하라.
- 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태라도 무방하다.
- 기본 직렬화 형태가 적합하다고 결정했더라고 불변식 보장과 보안을 위해 readObject 메서드를 제공해야 할 때 많다.
- transient 한정자는 해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시다.
- 어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자.
  구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 직렬 버전 UID를 절대 수정하지 말자.
  
## 아이템 88 - readObject 메서드는 방어적으로 작성하라
- readObject 메서드가 실질적으로 또 다른 public 생성자이기 때문이다. 따라서 다른 생성자와 똑같은 수준으로 주의를 기울여야 한다.
- 보통의 생성자처럼 readObject 메서드에서도 인수가 유효한지 검사해야 하고 필요하다면 매개변수를 방어적으로 복사해야한다.
  쉽게말해, readObject는 매개변수로 바이트 스트림을 받는 생성자라 할 수 있다.
- 객체를 역질렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야 한다.
- readObject 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임해야 한다.

## 아이템 89 - 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라
- readResolve 기능을 이용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다.
- 역직렬화한 객체의 클래스가 readResolve 메서드를 적절히 정의해뒀다면, 역직렬화 후 새로 생성된 객체를 인수로 이 메서드가 호출되고,
  이 메서드가 반환한 객체 잠조가 새로 생성된 객체를 대신해 반환된다.
- 사실, readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.
- 불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용하자.

## 아이템 90 - 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
- Serializable을 구현하기로 결정한 순간 위험을 크게 줄여줄 기법이 하나 있다. 바로 직렬화 프록시 패턴이다.
- 제 3자가 확장할 수 없는 클래스라면 가능한 한 직렬화 프록시 패턴을 사용하자.
