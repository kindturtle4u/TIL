> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 11장 동시성
## 아이템 78 - 공유 중인 가변 데이터는 동기화해 사용하라
- 동기화(syncrhonized)는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
- Thread.stop 메서드는 안전하지 않아 오래전에 사용 자제(deprecated) API로 지정되었다(이 메서드를 사용하면 데이터가 훼손될 수 있다).
- 쓰기와 읽기 모두가 동기화되지 않으면 동작을 보장하지 않는다.
- volatile 한정자는 배타적 수행과는 상관없지만 하상 가장 최근에 기록된 값을 읽게 됨을 보장한다.
- java.util.concurretn.atomic 패키지의 AtomicLong을 사용해보자. 
  이 패키지에는 락 없이도 (lock-free;락-프리) 스레드 안전한 프로그래밍을 지원하는 클래스들이 담겨있다. 
- 가변 데이터는 단일 스레드에서만 쓰도록 하자
- 여러 스레드가 가변데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야한다.

## 아이템 79 - 과도한 동기화는 피하라
- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.

## 아이템 80 - 스레드보다는 실행자, 태스크, 스트림을 애용하라
- java.util.concurrent 이 패키지는 실행자 프레임워크(Executor Framework)라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.
- 작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택일 것이다.
- 태스크에는 두가 지가 있다. 바로 Runnable과 그 사촌인 Callable이다(Callable은 Runable과 비슷하지만 값을 반환하고 임의이 예외를 던질수 있다.)

## 아이템 81 - wait와 notify보다는 동시성 유틸리티를 애용하라
- wait와 notifiy는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.
- java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다. 
  바로 실행자 프레임워크, 동시성 컬렉션(concurrent collection), 동기화 장치(synchronizer)다.
- 동시성 컬렉션은 List, Queue, Map 같은 표준 커렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다.
- 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며, 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.
- 이제는 Collection.synchronizedMap 보다는 ConcurrentHashMap을 사용하는게 훨씬 좋다.
- 시간 간격을 잴 때는 항상 System.currentTimeMillis가 아닌 System.nanoTime을 사용하자

## 아이템 82 - 스레드 안전성 수준을 문서화하라
- 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않는다. 
- 멀티스레드 환경에서도 API를 안전하게 사요하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.
- 스레드 안전성 애너테이션(@Immutable, @ThreadSafe, @NotThreadSafe)
- 모든 클래스가 자신의 스레드 안전성 정보를 명확히 문서화해야 한다. 정확한 언어로 명확히 설명하거나 스레드 안전성 애너테이션을 사용할 수 있다.

## 아이템 83 - 지연 초기화는 신중히 사용하라
- 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫다.
- 지연초기화가 초기화 순환성(initialzation circularity)을 깨뜨릴 것 같으면 synchronized를 단 접근자를 사용하자.
- 성능때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스(lazy initialization holder class)관용구를 사용하자.
- 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사(double-check) 관용구를 사용하라.

## 아이템 84 - 프로그램의 동작을 스레드 스케줄러에 기대하지 말라
- 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.
- 견고하고 빠릿하고 이식성 좋은 프로그램을 작성하는 가장 좋은 방법은 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지
  않도록 하는 것이다.
- Therad.yield(다른 스레드에게 실행 양보)를 써서 문제를 고쳐보려는 유혹을 떨쳐내자

