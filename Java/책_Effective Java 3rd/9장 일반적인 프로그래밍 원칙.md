> 출처 : Effectvie Java, 3rd Edition 읽으면서 정리(저자:조슈아 블로크)  
# 9장 일반적인 프로그래밍 원칙
## 아이템 57 - 지역변수의 범위를 최소화하라
- 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다.
- 지역변수의 범위를 줄이는 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다.
- 거의 모든 지역변수는 선언과 동시에 초기화 해야한다. try-catch문은 이규칙에서 예외다.
- 메서드를 작게 유지하고 한가지 기능에 집중하는 것이다.

## 아이템 58 - 전통적인 for 문보다는 for-each 문을 사용하라
- for-each 문을 사용할 수 없는 상황이 세가지 존재한다.
    * 파괴적인 필터링(destructive filtering) - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove메서드를 호출해야 한다.
    * 변형(transforming) - 리스트나 배열을 순회하면서 그 원소값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야한다.
    * 병렬반복(parallel iteration) - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야한다.
- for-each 문은 컬렉션과 배열은 물론 Iterable 인터페이스를 구현한 객체라면 무엇이든 순회 할 수 있다.
- 전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해준다.

## 아이템 59 - 라이브러리를 익히고 사용하라
- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
- 자바 7부터는 Random을 더이상 사용하지 않는 게 좋다. TheadLocalRandom으로 대체하면 대부분 잘 작동한다.
- 아마도 라이브러리에 그런 기능이 있는지 모르기 때문일 것이다. 메이저 릴리즈마다 주목할 만한 수많은 기능이 라이브러리에 추가된다.
  자바는 메이저 릴리스마다 새로운 기능을 설명하는 웹페이지를 공시하는데, 한 번쯤 읽어 볼만한다.
- 자바 프로그래머라면 적어도 java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다.
- 컬렉션 프레임워크와 스트림 라이브러리, java.util.concurrent의 동시성 기능도 마찬가지로 알아두면 큰 도움이 된다.
- 자바 표준 라이브러리에서 원하는 기능을 찾지 못하면, 그 다음 선택지는 고품질의 서드파티 라이브러리가 될 것이다.
  구글의 멋진 **구아바(Guava)** 라이브러리가 대표적이다.

## 아이템 60 - 정확한 답이 필요하다면 float와 double은 피하라 
- float와 double은 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 세심하게 설계되어있다.
  따라서 정확한 계산 결과가 필요할 때는 사용하면 안된다. 
- float와 double 타입은 특히 금융관련 계산과는 맞지 않는다.
- 금융계산에는 BigDecimal,int 혹은 long을 사용해야 한다.
- BigDecimal은 기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느리다. 
- 열여덟자리 십진수로 표현할 수 있다면 long을 사용하라. 열여덟 자리를 넘어가면 BigDecimal을 사용해야 한다.

## 아이템 61 - 박싱된 기본 타입보다는 기본 타입을 사용하라
- 기본 타입과 박싱된 기본 타입의 주된 차이는 크게 세가지다.
    * 기본타입은 값만 가지고 있으나, 박신된 기본타입은 값에 더해 식별성이란 속성을 갖는다. 박싱된 기본 타입의 두 인스턴스는 값이 같아도
      서로 다르다고 식별될 수 있다.
    * 기본 타입의 값은 언제나 유효하나, 박싱된 기본타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
    * 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.
- 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다.
- 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 
  그리고 null 참조로 언박싱 하면 NullPointerException이 발생한다.
- 박싱된 기본 타입은 언제 써야 하는가?
    * 첫번째, 컬렉션의 원소, 키, 값으로 쓴다.
      더 일반화 해 말하면, 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야한다.
    * 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.
- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라.
- 오토 박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만, 그 위험까지 없애주지는 않는다.

## 아이템 62 - 다른 타입이 적절하다면 문자열 사용을 피하라
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
- 문자열은 열거 타입을 대신하기에 적합하지 않다. 
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
- 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 쓰고 싶은 유혹을 뿌리쳐라.
  문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고,오류 가능성도 크다. 문자열을 잘못사용하는 흔한 예로는 기본 타입,열거 타입,혼합 타입이 있다.

## 아이템 63 - 문자열 연결은 느리니 주의하라
- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n<sup>2</sup>에 비례한다.
- 성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용하자.
- 많은 문자열 연결할 때는 문자열 연결 연산자(+)를 피하자. 대신 StringBuilder의 append 메서드를 사용하라.

## 아이템 64 - 객체는 인터페이스를 사용해 참조하라
- 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
```java
// 좋은 예. 인터페이스를 타입으로 사용했다.
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예. 클래스를 타입으로 사용했다!
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```
- 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.
- 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자

## 아이템 65 - 리플렉션보다는 인터페이스를 사용하라
- 리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
- Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 
  이어서 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.
- 나아가 Constructor, Mehoed, Field 인스턴스를 이용해 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있다. 이 인스턴스들을 통해
  해당 클래스의 인스턴스를 생성하거나, 메서드를 호출하거나, 필드에 접근할 수 있다는 뜻이다.
- 리플렉션을 이용하면 컴파일 당시에 존재하지 않던 클래스도 이용할 수 있는데 물론 단점이있다.
    * 컴파일 타입 검사가 주는 이점을 하나도 누릴 수 없다.
    * 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
    * 성능이 떨어진다.
- 리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할수 있다.
- 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자.
- 리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 강력한 기능이지만, 단점도 많다. 
  컴파일타입에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야 할 것이다.
  
## 아이템 66 - 네이티브 메서드는 신중히 사용하라
- 자바 네이티브 인터페이스(Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.
  여기서 네이티브 메서드란 C나 C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다.
- 전통적으로 네이티브 메서드의 주요 쓰임은 다음 세가지다.
    * 레지스트리 같은 플랫폼 특화 기능을 사용한다
    * 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 레거시 데이터를 사용하는 레거시 라이브러리가 그 예다.
    * 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.
- 자바 9는 새로 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었따.
- 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않는다.
- 정말로 고성능의 다중 정밀 영산이 필요한 자바 프로그래머라면 이제 네이티브 메서드를 통해 GMP를 사용하는걸 고려해도 좋다.
- 네이티브 메서드에는 심각한 단점이 있다.
    * 네이티브 메서드로 사용하는 애플리케잇녀도 메모리 훼손 오류로 부터 더 이상 안전하지 않다.
    * 네이티브 언어는 자바보다 플랫폼을 많이 타서 이식성도 낮다.
    * 디버깅도 더 어렵다.
    * 주의하지 않으면 속도가 오히려 느려질 수도 있다.
    * 가지비 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적조차 할 수 없다.
    * 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가된다.
    * 네이트비 메서드와 자바코드 사이의 '접착 코드'를 작성해야 하는데, 이는 귀찮은 작업이기도 하기니와 가독성도 떨어진다.
  
## 아이템 67 - 최적화는 신중히 하라
- 최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽고, 섣불리 진행하면 특히 더 그렇다. 
  빠르지도 않고 제대로 동작하지도 않으면서 수정하기는 어려운 소프트웨어를 탄생시키는 것이다.
- 성능 때문에 견고한 구조를 희생하지 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라.
- 성능을 제한하는 설계를 피하라. 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식이다.
  API, 네트워크 프로토콜, 영구 저장용 데이터 포맷 등이 대표적이다.
- API를 설계할 때 성능에 주는 영향을 고려하라. 잘 설계된 API는 성능도 좋은 게 보통이다. 그러니 성능을 위해 API를 왜곡하는 건 매우 안좋은 생각이다.
- 시스템 규모가 커질수록 프로파일러가 더 중요해진다. 건초더미에서 바늘 찾기와 비슷하다. 건초더미가 거대해질수록 금속탐지기가 더 절실해진다.
  그외에도 jmh도 언급해둘 만한 도구다. 프로파일러는 아니지만 자바 코드의 상세한 성능을 알기 쉽게 보여주는 마이크로 벤치마팅 프레임워크다.

## 아이템 68 - 일반적으로 통용되는 명명 규칙을 따르라
- 자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 그중 많은 것이 자바 언어 명세에 기술되어 있다. 자바의 명명 규칙은 크게 철자와 문법, 두범주로 나뉜다.
- 타입 매개변수 이름은 보통 한문자로 표한한다
    * 임의의 타입엔 T
    * 컬렉션 원소의 타입은 E
    * 맵의 키와 값에는 K와 V
    * 예외에는 X
    * 메서드의 반환 타입에는 R을 사용한다.
    * 그 외에 임의 타입의 시퀀스에는 T,U,V 혹은 T1,T2,T3를 사용한다.
- 객체를 생성할 수 있는 클래스(열거 타입 포함)의 이름은 보통 단수 명사나 명사구를 사용한다.(Thread, PriorityQueue, ChessPiece 등)
- 객체를 생성할 수 없는 클래스는 보통 복수형 명사로 짓는다(Collectors, Collections 등)
- 인터페이스 이름은 클래스와 똑같이 짓거나(Collection, Comparator 등), able 혹은 ible로 끝나는 형용사로 짓는다.(Runable, Iterable, Accessible)
- 애너테이션은 워낙 다양하게 활용되어 지배저인 규칙이 없이 명사,동사,전치사,형용사가 두루 쓰인다.
- 어떤 동작을 수행하는 메서드 이름은 동사나(목적어를 포함한) 동사구로 짓는다(append, drawImage).
- boolean 값을 반환한느 메서드라면 보통 is나 (드물게) has로 시작하고 명사나 명사구, 혹은 형용사로 기능하는 아무 단어나 구로 끝나도록 짓는다.
  (isDigit, isProbablePrime, isEmpty, is Enabled, hasSiblings)
- 반환 타입이 boolean이 아니거나 해당 인스턴스 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, 혹은 get으로 시작하는 동사구로 짓는다.(size,hashCode,getTime등)
- 객체의 타입을 바꿔서, 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 toType형태로 짓는다(toString, toArray 등).
- 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType 형태로 짓는다.(asList 등). 
- 객체의 값을 기본 타입 값으로 반환하는 메서드 이름은 보통 typeValue 형태로 짓는다.
- 마지막으로 정적 팩터리의 이름은 다양하지만 from, of, valueOf, instance, getInstance, newInstance, getType, newType을 흔히 사용한다.
