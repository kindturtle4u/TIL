> 출처 : 모던 자바 인 액션 읽으면서 정리

# PART Ⅴ 개선된 자바 동시성
# Chapter 15 CompletableFuture와 리액티브 프로그래밍 컨셉의 기초
## 15.1 동시성을 구현하는 자바 지원의 진화
자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원한다.  
다양한 웹 서비스를 이용하고 이들 정보를 실시간으로 조합해 사용자에게 제공하거나 추가 웹 서비스를
통해 제공하는 종류의 애플리케이션을 개발하는데 필수적인 기초 모델과 툴킷을 제공한다. 이과정을 리액티브 프로그래밍이라고 부르며
자바 9에서는 발행-구독 프로토콜(java.util.concurrent.Flow 인터페이스추가)로 이를 지원한다.  
CoompletableFuture와 java.util.concurrent.Flow의 궁국적인 목표는 가능한한 동시에 실행할 수 있는 독립적인 태스크를
가능하게 만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다.

### 15.1.1 스레드와 높은 수준의 추상화
### 15.1.2 Executor와 스레드 풀
자바 5는 Excutor 프레임워크와 스레드 풀을 통해 스레드의 힘을 높은 수준으로 끌어 올리는  
즉 자바 프로그래머가 테스크 제출과 실행을 분리할 수 있는 기능을 제공했다.

- 스레드의 문제
- 스레드 풀 그리고 스레드 풀이 더 좋은 이유
- 스레드 풀 그리고 스레드 풀이 나쁜 이유

### 15.1.3 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출
자바 스레드는 setDaemon() 메서드를 이용해 `데몬` 또는 비데몬으로 구분시킬 수 있다.
데몬 스레드는 애플리케이션이 종료될 때 강제로 종료되므로 디시크의 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용하게 활용할 수 있는 반면,
main() 메서드는 모든 비데몬 스레드가 종료될 때 까지 프로그램을 종료하지 않고 기다린다.

### 15.1.4 스레드에 무엇을 바라는가?

## 15.2 동기 API와 비동기 API
### 15.2.1 Future 형식 API
### 15.2.2 리액티브 형식 API
### 15.2.3 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주
### 15.2.4 현실성 확인
네트워크 서버의 블록/비블록 API를 일관적으로 제공하는 Netty(https://netty.io/)같은 새로운 라이브러리를 사용하는 것도  
도움이 된다.

### 15.2.5 비동기 API에서 예외는 어떻게 처리하는가?

## 15.3 박스와 채널 모델
## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성
자바 8에서는 Future 인터페이스의 구현인 CompletableFuture를 이용해 Future를 조합할 수 있는 기능을 추가했다.

## 15.5 발행-구독 그리고 리액티브 프로그래밍
자바 9에서는 java.util.concurrent.Flow의 인터페이스에 발행-구독모델(줄여서 pub-sub이라 불리는 프로토콜)을 적용해
리액티브 프로그래밍을 제공한다.

### 15.5.1 두 플로를 합치는 예제
### 15.5.2 역압력
### 15.5.3 실제 역압력의 간단한 형태

## 15.6 리액티브 시스템 vs 리액티브 프로그래밍
## 15.7 마치며
