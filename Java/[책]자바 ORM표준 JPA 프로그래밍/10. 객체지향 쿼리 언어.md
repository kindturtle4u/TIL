> 출처 : 자바 ORM 표준 JPA 프로그래밍 읽으면서 정리  

# 10. 객체지향 쿼리 언어 
JPQL은 가장 중요한 객체지향 쿼리 언어다.
이장에서 다루는 Criteira나 QueryDSL은 결국 JPQL을 편히하게 사용하도록 도와주는 기술이므로
JPA를 다루는 개발자라면 JPQL을 필수로 학습해야 한다.

## 10.1 객체지향 쿼리 소개
JPQL은 다음과 같은 특징이 있다.
- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.

SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면 JPQL은 엔티티 객체를 대상으로 하는
객체지향 쿼리다. JPQL을 사용하면 JPA는 이 JPQL을 분석한 다음 적절한 SQL을 만들어서 데이터베이스를 조회한다.
그리고 조회한 결과로 엔티티 객체를 생성해서 반환한다.

JPA가 공식 지원하는 기능
- JPQL(java Persistence Query Language)
- Criteria 쿼리 (Criteria Query) : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
- 네이티브 SQL(Native SQL) : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.
- QueryDSL : Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음. 비표준 오픈소스 프레임워크다.
- JDBC 직접사용, MyBatis 같은 SQL 매퍼 프레임워크 사용 : 필요하면 JDBC를 직접 사용할 수 있다.

### 10.1.1 JPQL 소개
- JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.

### 10.1.2 Criteria 쿼리 소개
Criteria는 JPQL을 생성하는 빌더 클래스다.
Criteria의 장점은 문자가 아닌 query.select(m).where(...)처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점이다.

- 컴파일 시점에 오류를 발견할 수 있다.
- IDE를 사용하면 코드 자동완성을 지원한다.
- 동적 쿼리를 작성하기 편한다.

Criteria가 가진 장점이 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다.
따라서 사용하기 불편한 건 물론이고 Criteria로 작성한 코드도 한눈에 들어오지 않는다는 단점이 있다.

### 10.1.3 QueryDSL 소개
QueryDSL도 Criteria처럼 JPQL 빌더 역할을 한다. QueryDSL의 장점은 코드 기반이면서 단순하고 사용하기 쉽다.

### 10.1.4 네이티브 SQL 소개
JPQL을 사용해도 가끔은 특정 데이터베이스에 의존하는 기능을 사용해야 할 때가 있다.  
EX) 오라클 데이터베이스만 사용하는 CONNECT BY 기능 이나 SQL 힌트 같은 것

### 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용
JDBC나 마이바티스를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시 해야한다.

문제는 JPA를 우회하는 SQL에 대해서는 JPA가 전혀 인식하지 못한다는 점이다.  
최악의 시나리오는 영속성 컨텍스트와 데이터베이스 불일치 상태로 ㅁ나들어 데이터 무결성을 훼손할 수 있다.  
이런 이슈를 해결하는 방법은 JPA를 우회해서 SQL을 싱행하기 직전에 영속성 컨텍스트를 수동으로 플러시해서 데이터 베이스와
영속성 컨텍스트를 동기화 하면 된다.

참고로 스프링 프레임워크를 사용하면 JPA와 마이바티스를 손쉽게 통합할 수 있다.

## 10.2 JPQL
- JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.

### 10.2.1 기본 문법과 쿼리 API
JPQL도 SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용할 수 있다. 
참고로 엔티티를 저장할 때는 EntityManager.persist() 메소드를 사용하면 되므로 INSERT문은 없다.
```jpaql
select_문 :: =
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]
    
update_문 :: update_절 [where_절]
delete_문 :: delete_절 [where_절]

SELECT m FROM Member AS m where m.username = 'Hello'
```

### 10.2.2 파리미터 바인딩
- 이름 기준 파라미터 : 이름기준 파라미터는 앞에 :를 사용한다.
`SELECT m FROM Member m where m.username = :username`
- 위치 기준 파라미터 : ? 다음에 위치 값을 주면 된다.
`SELECT m FROM Member m where m.username = ?1`

### 10.2.3 프로젝션
#### 엔티티 프로젝션
SELECT 절에 조회할 대상을 지정하는 것을 프로젝션(projection)이라 하고 [SELECT {프로젝션대상} FROM] 으로 대상을 선택한다.
프로젝션 대상은 엔티티, 엠비디드 타입, 스칼라 타입이 있다.

#### 임베디드 타입 프로젝션
JPQL에서 임베디드 타입은 엔티티와 거의 비슷하게 사용된다. 임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다.

#### 스칼라 타입 프로젝션
숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라 한다.

#### 여러 값 조회
프로젝션에 여러 값을 선택하면 TypeQuery를 사용할 수 없고 대신에 Query를 사용해야 한다.

#### NEW 명령어
`SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m`

### 10.2.4 페이징 API
JPA는 페이징을 다음 두 API로 추상화 했다.
- setFirstResult(int startPosition): 조회 시작 위치(0부터 시작한다)
- setMaxResults(int maxResult): 조회할 데이터 수

### 10.2.5 집합과 정렬
#### 집합함수
- COUNT: 결과 수를 구한다.
- MAX, MIN: 최대, 최소값을 구한다.
- AVG: 평균값을 구한다.
- SUM: 합을 구한다. 숫자타입만 사용할 수 있다.

#### 집합 함수 사용 시 참고사항
- NULL 값은 무시하므로 통계에 잡히지 않는다.
- 만약 값이 없는데 SUM, AVG, MAX, MIN 함수를 사용하면 NULL값이 된다.
단 COUNT는 0이 된다.
- DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다.  
`ex) select COUNT( DISTINCT m.age ) from Member m`
- DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다.

#### GROUP BY, HAVING
#### 정렬(ORDER BY)

### 10.2.6 JPQL 조인
#### 내부조인
`SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName`

JPQL 조인의 가장 큰 특징은 연관 필드를 사용한다는 것이다.

#### 외부조인
`SELECT m FROM Member m Left [OUTER] JOIN m.team t`

#### 컬렉션 조인
일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 조인하는 것을 컬렉션 조인이라 한다.
`SELECT t, m FRoM Team t LEFT JOIN t.members m`

#### 세타 조인
WHERE 절을 사용해서 세타 조인을 할 수 있다. 참고로 세타 조인은 내부 조인만 지원한다.

#### JOIN ON절(JPA 2.1)
JPA 2.1 부터 조인할 때 ON 절을 지원한다.

### 10.2.7 페치 조인
페치(fetch) 조인은 SQL에서 이야기하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능이다.  
페치 조인을 사용하면 연관된 엔티티도 함께 조회한다.

페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로

#### 엔티티 페치 조인
`SELECT m FROM Member m join fetch m.team`
회원을 조회할때 팀도 같이 조회함. 따라서 지연로딩이 일어나지 않음

#### 컬렉션 페치 조인
`SELECT t FROM Team t JOIN FETCH t.members where t.name = '팀A'`
연관된 회원도 JOIN하여 같이 조회하므로 team데이터 중복이 발생한다.

#### 페치 조인과 DISTINCT
`SELECT distinct t FROM Team t JOIN FETCH t.members where t.name = '팀A'`

#### 페치 조인의 특징과 한계
엔티티에 직접 적용하는 로딩 전략은 애플리케이션 전체에 영향을 미치므로 글로벌 로딩 전략이라 부른다.
페치 조인은 글로벌 로딩 전략보다 우선한다.

### 10.2.8 경로 표현식
경로표현식이라는 것은 쉽게 이야기해서 .(점)을 찍어 객체 그래프를 탐색하는 것이다.

### 10.2.9 서브쿼리
(제약사항)서브쿼리를 WHERE, HAVING 절에만 사용할 수 있고 SELECT, FROM 절에서는 사용할 수 없다.

### 서브 쿼리 함수
- [NOT] EXISTS (subquery)
- {ALL | ANY | SOME}(subquery)
- [NOT] IN (subquery)

### 10.2.10 조건식
- 문자 : 'HELLO'
- 숫자 : 10L , 10D, 10F (L:Long 타입, D:Double 타입, F:Float 타입)
- 날짜 : {d '2012-03-24'} , {t '10-11-11'}, {ts '2012-03-24 10-11-11.123'} (DATE: d , TIME: t, DATETIME: ts)
- Boolean : TRUE, FALSE
- Enum : 패키지명을 포함한 전체 이름을 사용해야한다. jpabook.MemberType.Admin
- 엔티티 타입 : 엔티티의 타입을 표현한다. 주로 상속과 관련해서 사용한다. TYPE(m) = Member

#### 컬렉션 식
##### 빈컬렉션 비교식
- 문법: {컬렉션 값 연관 경로} IS [NOT] EMPTY
- 설명: 컬렉션에 값이 비어있으면 참

##### 컬렉션의 멤버식
- 문법: {엔티티나 값} [NOT] MEMBER [OF] {컬렉션 값 연관 경로}
- 설명: 엔티티나 값이 컬렉션에 포함되어 있으면 참

#### 날짜함수
- CURRENT_DATE: 현재날짜
- CURRENT_TIME: 현재시간
- CURRENT_TIMESTAMP: 현재 날짜 시간

#### COALESCE
- 문법: COALESCE(<스칼라식> {,<스칼라식>}+)
- 설명: 스칼라식을 차례대로 조회해서 null이 아니면 반환한다.
  `select coalesce(m.username, '이름없는회원') from Member m`

#### NULLIF
- 문법: NULLIF(<스칼라식>, <스칼라식>)
- 설명: 두 값이 같으면 null을 반환하고 다르면 첫 번째 값을 반환한다.
  `select NULLIF(m.username,'관리자') from Member m` 사용자 이름이 관리자면 null을 반환하고 나머지는 본인 이름 반환
  
### 10.2.11 다형성 쿼리
JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회한다.

#### TYPE 
TYPE은 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용한다.
`select i from Item i where type(i) IN (Book, Movie)`

#### TREAT(JPA 2.1)
TREAT는 JPA 2.1에 추가된 기능인데 자바의 타입 캐스팅과 비슷하다.  
상속 구조에서 부모 타입을 특정 자식타입으로 다룰 때 사용한다.
`select i from Item i where treat(i as Book).author = 'kim'`

### 10.2.12 사용자 정의 함수 호출(JPA2.1)
- 문법: function_invocation::= FUNCTION(function_name{, function_arg}*)

### 10.2.13 기타 정리
- enum은 = 비교 연산만 지원한다.
- 임베디드 타입은 비교를 지원하지 않는다.

### 10.2.14 엔티티 직접 사용
### 10.2.15 Named쿼리: 정적 쿼리
JPQL 쿼리는 크게 동적 쿼리와 정적 쿼리로 나눌 수 있다.
- 동적 쿼리: em.createQuery("select..")처럼 JPQL을 문자로 완송해서 직접 넘기는 것을 동적 쿼리라 한다.
- 정적 쿼리: 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용할 수 있는데 이것을 Named 쿼리라 한다.

- Named 쿼리는 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해 둔다.
- Named 쿼리는 @NamedQuery 어노테이션을 사용해서 자바 코드에 작성하거나 또는 XML 문서에 작성할 수 있다.

## 10.3 Criteria
## 10.4 QueryDSL
## 10.5 네이티브 SQL
## 10.6 객체지향 쿼리 심화
## 10.7 정리
