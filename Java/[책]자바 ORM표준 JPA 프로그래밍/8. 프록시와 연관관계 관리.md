> 출처 : 자바 ORM 표준 JPA 프로그래밍 읽으면서 정리  

# 8. 프록시와 연관관계 관리
- 프록시와 즉시로딩, 지연로딩
- 영속성 전이 고아 객체

## 8.1 프록시
- 지연로딩   
엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 엔티티에 필요한 데이터를 조회하는것
지연로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 한다.
  
### 8.1.1 프록시 기초
엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 EntityManager.getReference() 메소드를 사용하면된다.

- 프록시의 특징  
프록시는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다. 
프록시 객체는 실제 객체에 대한 참조(target)를 보관한다. 그리고 프록시 객체의 메소드를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
  
- 프록시 객체의 초기화
실제 사용될 때 데이터베이스를 조회해서 실제엔티티 객체를 생성하는데 이것을 프록시 객체의 초기화라 한다.
  
- 프록시의 특징
    * 처음사용할때 한번만 초기화 된다.
    * 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다. 프록시 객체가 초기화되면 프록시 객체를 통해서 
    실제 엔티티에 접근할 수 있다.
    * 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크시 주의해서 사용해야 한다.
    * 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없으므로 em.getRefernce()를 호출해도 프록시가 아닌
    실제 엔티티를 반환한다.
    * 초기화는 영속성 컨텍스트의 도움을 받아야 가능하다. 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태의 프록시를 초기화하면
    문제가 발생한다. 하이버네이트는 org.hibernate.LazyInitializationException 예외를 발생시킨다.
      
- 준영속 상태와 초기화

### 8.1.2 프록시와 식별자
엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.

### 8.1.3 프록시 확인
JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있따.
 
프록시 강제 초기화  
하이버네이트의 initialize() 메소드를 사요하면 프록시를 강제로 초기화 할 수 있다.

## 8.2 즉시 로딩과 지연 로딩
- 즉시 로딩
    * 예) em.find(Member.class, "member1")를 호출할 때 회원 엔티티와 연관된 팀 엔티티도 함께 조회한다.
    * 설정 방법 : @ManyToOne(fetch = FetchType.EAGER)
    
- 지연 로딩
    * 예) member.getTeam().getName() 처럼 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해서 팀 엔티티를 조회한다.
    * 설정 방법 : @ManyToOne(fetch = FetchType.LAZY)
    
### 8.2.1 즉시로딩
참고 : NULL 제약조건과 JPA 조인 전략  
nullable 설정에 따른 조인 전략  
@JoinColumn(nullable=true) : NULL허용(기본값), 외부조인 사용
@JoinColumn(nullable=false) : NULL 허용하지 않음. 내부조인 사용
또는 다음처럼 @ManyToOne.optional = false로 사용해도 내부조인을 사용한다.

### 8.2.2 지연로딩
지연로딩 LAY LODING을 사용하려면 @ManyToOne의 fetch 속성을 FetchType.LAZY로 지정한다.

참고  
조회대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 프록시가 아닌 실제 객체를 사용한다.

### 8.2.3 즉시 로딩,지연 로딩 정리
- 지연로딩(LAZY) : 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- 즉시 로딩(EAGER) : 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한번에 조회한다.

## 8.3 지연 로딩 활용
### 8.3.1 프록시와 컬랙션 래퍼
하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가
제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라 한다.

엔티티를 지연로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하지만 주문내역같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해준다.
참고로 member.getOrders()를 호출해도 컬렉션을 초기화되지 않는다. 컬렉션은 member.getOrders().get(0)처럼 컬렉션에서 실제 데이터를 조회할때
데이터 베이스를 조회해서 초기화 한다.

### 8.3.2 JPA 기본 패치 전략
fetch 속성의 기본 설정값은 다음과 같다.
- @ManyToOne, @OneToOne : 즉시 로딩(FetchType.EAGER)
- @OneToMany, @ManyToMany : 지연 로딩(FetchType.LAZY)

추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다. 그리고 애플리케이션 개발이 어느정도 완료단계에 왔을때
실제 사용하는 상황을 보고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 최적화 하면된다.

### 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않는다.
- 컬렉션 즉시 로딩은 항상 외부 조인(OUTER JOIN)을 사용한다.

- @ManyToOne, @OneToOne
  * (optional = false): 내부조인
  * (optional = true) : 외부조인
    
- @OneToMany, @ManyToMany
  * (optional = false) : 외부조인
  * (optional = true) : 외부조인
    
## 8.4 영속성 전이 : CASCASE
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 된다.

JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야한다. 

### 8.4.1 영속성 전이 : 저장
@OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)

영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없다. 단지 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다.

### 8.4.2 영속성 전이 : 삭제
CascaseType.REMOVE로 설정하고 삭제하면 연관된 엔티티도 함꼐 삭제된다.

### 8.4.3 CASCADE의 종류
```java
public enum CascadeType {
    ALL,        //모두적용
    PERSIST,    //영속
    MERGE,      //병합
    REMOVE,     //삭제
    REFRESH,    //REFRESH
    DETACH      //DETACH
}
```

## 8.5 고아 개체
JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체(ORPHAN)제거라 한다.

@OneToMany(mappedBy = "parent", orphanRemoval = true)  
참조가 제거된 엔티티는 다른곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.  
orphanRemoval은 @OneToOne, @OneToMany에만 사용할 수 있다.

## 8.6 영속성 전의 + 고아 객체, 생명주기
## 8.7 정리

## 실전예제






