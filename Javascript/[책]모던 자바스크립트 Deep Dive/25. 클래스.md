> 출처 : 모던 자바스크립트 Deep Dive (저자: 이웅모)
# 25. 클래스
## 25.1 클래스는 프로토타입의 문법적 설탕인가?
- 자바스크립트는 프로토타입 기반 객체지향 언어다. 프로토타입 기반 객체지향 언어는 클래스가 필요 없는 객체지향 프로그래밍 언어다.
- ES6에서 도입된 클래스는 기존 프로토타입 기반 객체지향 프로그래밍보다 자바나 C#과 같은 클래스 기반 객체지향 프로그래밍에
  익숙한 프로그래머가 더욱 빠르게 학습할 수 있도록 클래스 기반 객체지향 프로그래밍 언어와 매우 흡사한 새로운 객체 생성 
  매커니즘을 제시한다.
- ES6의 클래스가 기존의 프로토타입 기반 객체지향 모델을 폐지하고 새롭게 클래스 기반 객체지향 모델을 제공하는 것은 아니다.
- 사실 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕 이라고 볼수있다.
- 문법적설탕(Syntactic sugar)
    * 사람이 이해 하고 표현하기 쉽게 디자인된 프로그래밍 언어 문법
    * 사람이 프로그래밍 언어를 sweeter하게 사용 할 수 있도록 도와주는 문법
    * 더욱 더 간결하고 명확하게 표현이 가능한 문법을 뜻 한다.
    * TypeScript를 Syntactic sugar의 특징을 가졌다고도 한다.
- 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지는 않는다.
  클래스는 생성자 함수보다 엄격하며 생성자 함수에서는 제공하지 않는 기능도 제공한다.
- 클래스는 생성자 함수와 매우 유사하게 동작하지만 다음과 같이 몇가지 차이가 있다.
    * 클래스는 new 연산자 없이 호출하면 에러가 발생한다.
    * 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
    * 클래스는 호이스팅이 발생하지 않는것처럼 동작한다.
    * 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 strict mode를 해제할 수 없다.
    * 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 false다.
      다시 말해, 열거되지 않는다.
- 클래스는 생성자 함수 기반의 객체 생성 방식보도 견고하고 명료하다. 특히 클래스의 extends와 super 키워드는 상속 관계 구현을 더욱
  간결하고 명료하게 한다.
- 따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 새로운 객체 생성 매커니즘으로 보는 것이 좀더 합당하다.

## 25.2 클래스의 정의
- 클래스는 `class` 키워드를 사용하여 정의한다. 클래스 이름은 생성자 함수와 마찬가지로 파스칼케이스를 사용하는 것이 일반적이다.
```javascript
// 클래스 선언문
class Person {}

// 익명 클래스 표현식
const Person = class {} ;

// 기명 클래스 표현식
const Person = class MyClass {};
```
- 클래스는 일급 객체로서 다음과 같은 특징을 갖는다.
    * 무명의 리터럴로 생성할 수 있다. 즉 런타임 생성이 가능하다.
    * 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
    * 함수의 매개변수에게 전달할 수 있다.
    * 함수의 반환값으로 사용할 수 있다.
- 좀더 자세히 말하자면 클래스는 함수다. 따라서 클래스는 값처럼 사용할 수 있는 일급 객체다.
- 클래스 몸체에 정의할 수 있는 메서드는 constructor(생성자) , 프로토타입 메서드, 정적 메서드의 세가지가 있다.
```javascript
// 클래스 선언문
class Person {
    // 생성자
    constructor(name) {
        // 인스턴스 생성 및 초기화
        this.name = name; // name 프로퍼티는 public 하다.
    }
    
    // 프로토 타입 메서드
    sayHi() {
        console.log(`Hi! My name is ${this.name}`);
    }
    
    // 정적 메서드
    static sayHello() {
        console.log('Hello!');
    }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee

// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee

// 정적 메서드 호출
Person.sayHello(); //Hello!
```

## 25.3 클래스 호이스팅
- 클래스는 함수로 평가된다.
```javascript
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```
```javascript
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

// 클래스 선언문
class Person {}
```
- 클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다. 단 클래스는 let, const 키워드로 선언한
변수처럼 호이스팅된다. 따라서 클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는것처럼 동작한다.
- var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자는 호이스팅 된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.

## 25.4 인스턴스 생성
- 클래스 생성자는 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.
- 기명 클래스 표현식의 클래스 이름(MyClass)을 사용해 인스턴스를 생성하면 에러가 발생한다.
```javascript
const Person = class MyClass {};

// 함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person();

// 클래스 이름 MyClass는 함수와 동일하게 클래스 몸체 내무에서만 유효한 식별자다.
console.log(MyClass); // ReferenceError: MyClass is not defined

const you = new MyClass(); // ReferenceError: MyClass is not defined
```

## 25.5 메서드





