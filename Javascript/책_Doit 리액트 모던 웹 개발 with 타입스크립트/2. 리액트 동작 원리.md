> 출처 : Do it 리액트 모던 웹 개발 with 타입스크립트 (저자: 전예홍)

# 2. 리액트 동작 원리
## 2.1 가상 DOM 이해하기
- 리액트 프레임워크를 구성하는 기본 3요소는 `가상 DOM`, `JSX구문`, 그리고 `컴포넌트` 입니다.

### index.tsx 파일 살펴보기
```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

```
- React.StrictMode는 코드가 잘못되었는지 판단하여 적절한 오류 메세지를 보여 주는 컴포넌트 입니다.
- reportWebVitals은 앱의 성능을 측정하는 기능으로, 리액트 개발과는 직접 관련이 없습니다.

### react와 react-dom 패키지
- 리액트 프로젝트는 항상 `react`와 `react-dom` 패키지가 필요합니다.
- 이 가운데 `react`는 리액트 앱이 동작하는 환경과 무관하게 공통으로 사용하는 기능을 제공하는 패키지 입니다.
- `react-dom/clinet`, `react-dom/server`, `react-native` 등 이른바 렌더러 라고 하는 패키지는 앱이 동작하는 환경(플랫폼)에 종속적인 기능을 제공하는데 특화된 패키지 입니다.
- CSR(Client-side rendering): `react` + `react-dom/client`
- SSR(Server-side rendering): `react` + `react-dom/server`
- 모바일 앱: `react` + `react-native`

### XML 마크업 언어

#### 문서 객체 모델이란?
- 웹 브라우저는 HTML 형식의 문자열을 화면에 출력할 때 문자열을 분석하여 어떤 특별한 형식의 자바스크립트 객체 조합으로 바꿉니다.
  * `head` -> `HTMLHeadElement`
  * `meta` -> `HTMLMetaElement`
  * `body` -> `HTMLBodyElement`
  * `div` -> `HTMLDivElement`
- 이 특별한 형식의 자바스크립트 객체는 모두 자신의 특징에 맞는 인터페이스를 구현하는데, 이들 인터페이스를 총칭하여 문서 객체 모델 (Document Object Model, DOM)이라고 합니다.
- 웹 브라우저의 자바스크립트 엔진은 window라는 이름의 전역 변수를 기본으로 제공합니다.
- 여기서 window는 웹 브라우저의 특정 웹 페이지를 의미하는 객체 입니다. 
- window 객체는 Window타입 객체로서 Window 타입을 브라우저 객체 모델 (browser object model, BOM) 이라고 합니다.

### document 객체
- 웹 페이지가 HTML 문서를 화면에 출력할때 window 객체는 document라는 이름의 속성 객체로 HTML 문서 기능을 사용할 수 있게 해줍니다.
- HTML 문서의 html요소(`<html></html>`)는 오직 1개만 있어야 하므로, `window.docment`(혹은 줄여서 그냥 `document`)는 html요소를 의미합니다.

### document.head와 document.body 객체
- 그리고 HTML 문서의 html 요소는 `head`와 `body` 태그를 1개씩만 가질 수 있습니다. 
- document 객체는 이런 조건에 맞추어 head 요소를 의미하는 head 속성 객체와 body 요소를 의미하는 body 속성 객체를 제공합니다.

### document.createElement 메서드
- 웹 브라우저는 DOM의 다양한 인터페이스를 각각의 목적에 맞게 구현한 객체로 생성할 수 있도록 document.createElement 메서드를 제공합니다.
- `let element = document.createElement(tagName[, options])`

### HTMLElement 인터페이스
- HTMLElement는 모든 종류의 HTML 요소가 구현하는 인터페이스 입니다. 
- 대부분 HTMLElement를 상속한 자신들의 인터페이스를 구현합니다. 
- 이름규칙: `HTML요소명Element`

### HTMLElement의 부모 요소 상속 구조
- HTMLElement는 부모 인터페이스 3개를 상속합니다. (HTMLElement -> Element -> Node -> EventTarget)
- `Node`는 appendChild 메서드를 제공합니다. `HTMLElement`는 모든 HTML 태그의 부모 인터페이스므로 모든 HTML 태그는 appendChild 메서드를 가집니다.
- `let aChild = element.appendChild(aChild)`

```javascript
let p = document.createElement("p"); // <p> 요소 생성
// <p> 요소를 <body>의 마지막 자식 요소로 추가
document.body.appendChild(p); // 렌더링
```
- appendChild는 생성된 DOM 객체를 웹 브라우저 화면에 출력해 주는 역할을 합니다. 여기서 DOM 객체를 웹 브라우저 화면에 나타나게 하는 것을 **렌더링(rendering)**이라고 합니다.
- DOM 객체는 appendChild 호출을 거쳐 부모/자식 관계로 얽힌 거대한 트리 구조가 생성됩니다. 
- 웹 브라우저에서는 이 DOM 객체들의 구조를 **DOM 트리** 라고 합니다.

#### 자바스크립트만 사용하는 프런트엔드 개발(물리 DOM)
```tsx
import React from 'react'

let pPhysicalDom = document.createElement('p')
pPhysicalDom.innerText = 'Hello physical DOM world!'
document.body.appendChild(pPhysicalDom)
```
- pPhysicalDom 은 리액트와 상관없으므로 그냥 DOM 객체라고 합니다. 리액트 가상 DOM 객체와 구분하려면 물리 DOM 객체라고 할 수 있습니다.

#### 리액트를 사용하는 프런트엔드 개발(가상 DOM)
- 웹 브라우저의 document.createElement와 유사하게 react 패키지는 createElement라는 함수를 제공합니다.
```ts
function createElement<P extends {}>(
        type: FunctionComponent<P> | ComponentClass<P> | string,
        props?: Attributes & P | null,
        ...children: ReactNode[]
): ReactElement<P>;
```
- 첫번째 매개변수 type의 타입은 `FunctionComponent<P>`, `ComponentClass<P>`, string 중 하나 일 수 있습니다.
- 2번째 매개변수는 props 변수 이름 뒤에 ?가 붙었으므로 생략할 수 있는 선택 매개 변수 입니다.
- `<p>` 요소 생성: `const p = React.createElement('p')`
- `<p>Hello world!</p>` 형태의 HTML을 생성하려고 할 때 XML 구문에서 'Hello World!' 문자열은 유효한 HTML 요소이므로, 이 문자열은 `<p>`요소의 자식 요소가 될 수 있습니다.
- `const pVirtualDom = React.createElement('p', null, 'Hello world!')`

```tsx
import React from 'react'
import ReactDOM from "react-dom/client";

const pVirtualDOM = React.createElement('p', null, 'Hello virtual DOM world!');
const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)

root.render(pVirtualDOM);
```

#### root.render 메서드
- `document.body.appendChild(pVirtualDOM)`과 같은 코드는 만들 수 없음. pVirtualDOM은 document.body.appendChild가 이해할 수 있는 DOM 객체가 아니기 때문
- `root.render` 함수가 가상 DOM을 물리 DOM으로 전환해 주는 기능을 합니다.
- 리액트에서 가상 DOM 객체의 렌더링은 `react-dom` 렌더러가 수행합니다. 
- `root.render(pVirtualDOM)` 부분이 가상 DOM 객체를 화면에 렌더링 하려고 시도하는 부분입니다.
- `root.render` 메서드는 변환한 가상 DOM 객체를 부착할 물리 DOM 객체가 필요합니다.(index.html 파일에는 id속성값이 root인 `<div>`요소)

#### `document.getElementById` 메서드
- 이 메서드는 이미 생성된 특정 물리 DOM 객체를 찾아주는 역할을 합니다.

#### index.tsx 코드 의미 알아보기
- 리액트는 React.createElement 함수로 다양한 HTML 요소를 가상 DOM 트리 구조로 구현한 뒤, render 메서드가 호출되는 순간 이 가상 DOM 트리를 물리 DOM 트리로 변환해 줍니다.
- 최소 렌더링 이후 가상 DOM 트리 구조에 변화가 생겨, 다시 렌더링되는 상황을 생각하면 물리 DOM 트리 세계에서는 어려움.

## 02.2 JSX 구문 이해하기
- 오늘날 리액트 프레임워크가 널리 사용될 수 있는 것은 JSX가 결정적인 역할을 했기 때문입니다.
- ch02_2 프로젝트 생성

### React.createElement 호출의 복잡성 문제
- React.createElement는 가상 DOM 객체를 만들어 주는 함수지만, 다음처럼 HTML 요소가 부모/자식 관계로 구성되면 코드가 지나치게 복잡해지는 문제가 있습니다.
```html
<ul>
  <li>
    <a href='http://www.google.com'>
      <p>go to google</p>
    </a>
  </li>
</ul>
```
```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'

const CE = React.createElement

const rootVirtualDOM = CE('ul', null, [
    CE('li', null, [
        CE('a', {href: 'http://www.google.com', target: '_blank'}, [
            CE('p', null, 'go to google')
        ])
    ])
])

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)
root.render(rootVirtualDOM)
```
- 리액트 팀은 이러한 React.createElement 호출의 복잡성을 해결하고자 자바스크립트 언어에 없는 JSX 기능을 언어 확장(language extension) 형태로 추가 했습니다.
- JSX버전
```tsx
import ReactDOM from 'react-dom/client'

const rootVirtualDOM = (
        <ul>
          <li>
            <a href="http://www.google.com" target="_blank">
              <p>go to Google</p>
            </a>
          </li>
        </ul>
)

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)
root.render(rootVirtualDOM);
```

### JSX = JavaScript + XML
- JSX는 'JavaScript XML'의 줄임말로서 XML 구문에 자바스크립트 코드를 결합하는 용도로 만들어진 구문
- JSX는 React.createElement 호출 코드를 간결하게 하려고 고안한 것으로, 자바스크립트 언어를 확장하는 방식으로 구현되었습니다.

### XML(혹은 HTML5) 표준 준수
- 리액트에서 JSX 구문을 작성할 때는 XML 규약을 엄격하게 준수해야 합니다.
```html
<!--잘못 구현한 예-->
<input type="text">
<img src="some url">

<!--옳게 구현한 예-->
<input type="text"/>
<img src="some url"/>
```

### JSX 구문에서 중괄호의 의미
- JSX는 XML 구조에 중괄호 {}를 사용하여 자바스크립트 코드를 감싸는 형태의 문법을 제공합니다.
- `<p>{/* javascript code */}</p>`
- JSX 구문에서 중괄호 안의 자바스크립트 코드는 반드시 return 키워드 없이 값만을 반환해야 합니다. 이처럼 return 키워드 없이 값만 반환하는 구문을 표현식이라고 합니다.

### 표현식과 실행문, 그리고 JSX
- 표현식(expression)이란 return 키워드 없이 어떤 값을 반환하는 코드를 뜻합니다. (ex: 1, true, 'Hello world!')
- 실행문(excution statment)은 그 자체로 '값'이 아닙니다.(ex if ~, switch~case, for, console.log)
- JSX코드를 구성하는 한 줄 한줄 모두 React.createElement 호출 코드로 반환되어야 하는데, 실행문(console.log)는 React.createElement 호출로 변환할 수 없어서 오류 발생

### 배열과 JSX 구문
- JSX 구문은 단순화된 React.createElement 호출이므로 반환값은 가상 DOM 객체 입니다. 따라서 변수나 배열에 담을 수 있습니다.
```tsx
export default function App()  {
  const children = [
    <li>
      <a href="http://www.google.com" target="_blank">
        <p>go to Google</p>
      </a>
    </li>,
    <li>
      <a href="http://www.facebook.com" target="_blank">
        <p>go to facebook</p>
      </a>
    </li>,
    <li>
      <a href="http://www.twitter.com" target="_blank">
        <p>go to twitter</p>
      </a>
    </li>,
  ];

  const rootVirtualDOM = <ul>{children}</ul>

  return rootVirtualDOM;
}
```

### 배열을 JSX 문으로 만들 때 주의 사항
- JSX 역시 XML 이므로 컴포넌트 여러개를 배열로 담은 children 변수가 부모 컴포넌트 없이 {children} 형태로 존재 할수 없습니다.
```tsx
  const children = [
    <li>
      <a href="http://www.google.com" target="_blank">
        <p>go to Google</p>
      </a>
    </li>,
    <li>
      <a href="http://www.facebook.com" target="_blank">
        <p>go to facebook</p>
      </a>
    </li>,
    <li>
      <a href="http://www.twitter.com" target="_blank">
        <p>go to twitter</p>
      </a>
    </li>,
  ];

  const rootVirtualDOM = {children}

  return rootVirtualDOM; // <- 에러 발생
```

### 데이터 배열을 컴포넌트 배열로 만들기
```tsx
const childen = [0,1,2].map((n: number) => <h3>Hello world! {n}</h3>)
const rootVirtualDOM = <div>{childen}
```

## 02-3 컴포넌트 이해하기
- 컴포넌트는 가상 DOM, JSX와 함께 리액트의 핵심 기능입니다.
- 리액트에서 컴포넌트는 두종류로 클래스 컴포넌트와 함수 컴포넌트가 있습니다.
- 프로젝트 만들기 ch02_3
