> 출처 : Do it 리액트 모던 웹 개발 with 타입스크립트 (저자: 전예홍)

# 3.컴포넌트 CSS 스타일링
## 03-1 리액트 컴포넌트의 CSS 스타일링
- ch03_1 프로젝트 생성

### 컴포넌트 스타일링
#### 부트스트랩 사용해 보기
- public 디렉터리의 index.html 파일에 다음처럼 붙여 넣기
```html
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
```

#### 부트스트랩 컴포넌트 구현하기
- 오류가 있는 부트스트랩 스타일링 코드
```tsx
export default function Bootstrap() {
    return <form>
        <div class="mb-3">
            <label for="exampleInputEmail1" class="form-label">Email address</label>
            <input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp">
                <div id="emailHelp" class="form-text">We'll never share your email with anyone else.</div>
        </div>
        <div class="mb-3">
            <label for="exampleInputPassword1" class="form-label">Password</label>
            <input type="password" class="form-control" id="exampleInputPassword1">
        </div>
        <div class="mb-3 form-check">
            <input type="checkbox" class="form-check-input" id="exampleCheck1">
                <label class="form-check-label" for="exampleCheck1">Check me out</label>
        </div>
        <button type="submit" class="btn btn-primary">Submit</button>
    </form>
}
```

#### 리액트 className과 htmlFor 속성
- 자바스크립트(혹은 타입스크립트) 키워드인 class와 for가 혼란을 줍니다.
  * `class` -> `className`
  * `for` -> `htmlFor`

### 웹팩과 CSS 파일 임포트
- 리액트 프로젝가 내부적으로 사용하는 웹팩은 `.css` 파일을 좀 더 쉽게 사용할 수 있게 도와줍니다.
- 웹팩은 타입스크립트 코드에서 import 문 형태로 CSS 파일을 `<link>` 태그 없으 이용할 수 있게 해줍니다.
```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css';
```
- 이 코드는 웹펙이 같은 디렉터리의 index.css 파일을 포함하여 배포하도록 합니다.

### CSS 기본 구문
- `-apple-system` 처럼 붙임표(hyphen) 기호 '-'로 시작하는 속성이나 값을 벤더 접두사라고 합니다.
- 벤더 접두사는 구글, 애플 등 웹 브라우저 제작업체에서 만든 CSS 기능으로, W3C 표준에는 없는 비표준 기능입니다.


### 선택자란?
- 전체 선택자: `*`
- 유형 선택자: `h1`, `h2`
- 클래스 선택자: `.wrapper`

### @import 규칙으로 아이콘 사용하기
- CSS는 `@import`, `@media` 등 @으로 시작하는 구문을 제공하는데, 이런 구문을 앳 규칙이라고 합니다.
- CSS의 `@import` 규칙은 `<link rel='stylesheet' href>` 대신 .css 파일에서 다른 .css 파일을 사용하고자 할 때 적용합니다.
- 다음은 `@import`로 구글 머티리얼 아이콘 세트를 사용하는 코드입니다.
  * `@import url('https://fonts.googleapis.com/icon?family=Material+Icons`);

> 참고: @규칙(At-Rule) https://uxkm.io/publishing/css/03-cssMiddleclass/07-css_atrule#gsc.tab=0
#### `@Charset`
- 스타일 시트에 쓰이는 문자 인코딩을 지정합니다.
- 스타일 시트의 첫 번째 요소여야 하며 어떤 문자가 선행되지 않아야 합니다. `@charset "utf-8";`

#### `@import`
- 스타일 시트에서 다른 스타일 규칙을 가져올 때 쓰입니다.
- 이 규칙은 `@charset` 규칙을 제외하고 모든 다른 종류의 규칙보다 선행해야 합니다.

```css
@import [ <string> | <url> ] [ <media-query-list> ];
```

#### `@namespace`
- CSS 스타일 시트에서 사용되는 XML 네임스페이스를 정의하는 at-규칙입니다.

#### `@supports`
- 하나 이상의 특정 CSS 기능에 대한 브라우저의 지원에 따라 선언을 지정할 수 있습니다. 이를 기능 쿼리라고합니다.

#### `@media`
- 장치가 미디어 질의(media query)를 사용하여 정의된 조건의 기준을 만족하면 해당 콘텐츠를 적용하는 조건부 그룹 규칙입니다.
- min-width 또는 max-width 를 활용하여 반응형 레이아웃(Responsive layout)을 구현할 수 있습니다.

#### `@page`
- 문서를 인쇄할 때 일부 CSS 속성을 수정하는 데 쓰입니다. @page로 모든 CSS 속성을 바꿀 수는 없습니다.

#### `@font-face`
- 텍스트를 표시 할 사용자 정의 글꼴을 지정합니다. 글꼴은 원격 서버나 로컬 컴퓨터에서 사용자 컴퓨터에로드 할 수 있습니다.
- 우선 웹 폰트를 서버에 올려놓고, CSS 파일에 @font-face 규칙을 사용하여 웹 폰트를 정의하고 추가합니다.
  그러면 해당 웹 페이지에 접속하는 모든 웹 브라우저는 자동으로 서버에서 웹 폰트를 내려받아 해당 글꼴을 표시하게 됩니다.
- CSS3에서 @font-face 규칙을 사용하려면 다음과 같이 지정을 해야 합니다.
  * font-family : 사용할 웹 폰트의 이름을 지정합니다. 이 이름은 폰트 파일의 이름과 일치하지 않아도 상관없습니다. 하지만 비슷하게 설정하는 것이 유지 보수에 좋습니다.
  * src : 폰트 파일의 경로와 폰트의 형식을 지정합니다. url에 폰트 파일의 경로를 설정하고, format에 폰트 파일의 형식을 설정합니다.
- @font-face 규칙을 설정한 다음 웹 폰트가 필요한 선택자(selector)의 font-family 속성에서 사용할 웹 폰트의 이름을 호출해 사용합니다.
- 만약 웹 폰트 로딩이 실패하면 다음에 선언된 폰트가 렌더링됩니다. 이 폰트를 폴백 폰트(fallback font)라 합니다.

```css
@font-face {
  font-family: MyFont;
  src: url("https://a.com/fonts/myFont.woff2") format("woff2");
}

.text {
  font-family: MyFont, sans-serif;
}
```

#### `@keyframes`
- 애니메이션 시퀀스를 따라 키 프레임 (또는 웨이 포인트)의 스타일을 정의하여 CSS 애니메이션 시퀀스의 중간 단계를 제어합니다.

#### index.css
```css
@import url('https://fonts.googleapi.com/icon?family=Material+Icons');

.meterial-icons {
  font-family: 'Material Icons';
  display: inline-block;
}
```

#### Icon.tsx
```tsx
export default function Icon() {
    return (
        <div>
            <h3>Icon</h3>
            <span className="meterial-icons">home</span>
            <span className="meterial-icons">check_circle_outline</span>
        </div>
    )
}
```

#### 아이콘 이름은 어떻게 알 수 있나요?
- 구글 머터리얼 아이콘 사이트(fonts.google.com/icons)에 나와 있습니다.
- `Check Circle Outline` 타입스크립트 코드에서 사용할 때는 `check_circle_outline`처럼 밑줄 표기법으로 작성해야 합니다.

### style 속성을 사용한 인라인 스타일링
- HTML 요소는 sytle이라는 속성에 문자열로 된 CSS 코드를 설정할 수 있으며 렌더링 때 해당 코드가 반영됩니다.
  * `<div style='width: 100px; height: 100px; background-color: blue; />`
- 리액트 컴포넌트에서는 style 속성에 설정하는 값은 문자열이 아닌 객체여야 합니다. 
  * `<div style={{width: '100px', height: '100px', backgroundColor: 'blue'}} />`

#### Style.tsx
```tsx
export default function Style() {
    return (
        <div>
            <h3>Style</h3>
            <span className="material-icons" style={{color: 'blue'}}>home</span>
            <span className="material-icons" style={{fontSize: '50px', color: 'red'}}>
                check_circle_outline
            </span>
        </div>
    )
}
```

### Node.js 패키지 방식으로 아이콘 사용하기
- `@import` 방식의 한 가지 문제점은 다른 사이트에 호스팅된 외부 CSS 파일을 가져오므로 네트워크 속도에 영향을 받을 수 있습니다.
- 대부분 웹 애플리케이션은 Node.js 패키지 형태로 구현된 CSS 프레임워크를 내장하는 형태로 배포합니다.

#### 웹 안전 글꼴과 fontsource
- `@import` 규칙은 웹에 안전한 글꼴, 즉 웹 안전 글꼴을 사용해야 한다는 제약이 있습니다.
- 여기서 웹 안전 글꼴은 데스크톱, 모바일 등 모든 장치에서 동작하는 모든 브라우저에 적용할 수 있는 글꼴입니다.
- 웹 안전 글꼴은 사용자 컴퓨터에 설치되지 않은 때에도 웹 페이지에 항상 올바르게 표시되는 글꼴을 의미합니다.
- 구글이 제공하는 모든 글꼴은 웹 안전 글꼴이므로 `@import` 규칙을 적용할 수 있습니다.
- fontsource(fontsource.org)는 구글 글꼴와 같은 오픈소스 웹 안전 글꼴을 패키지 형태로 설치해 줍니다.
  * `npm i @fontsource/스테이크-표기법-글꼴명`

#### 머터리얼 아이콘 설치하기
- https://fontsource.org/fonts 웹페이지에서 material 이란 이름이 있는 패키지를 검색하여 그 중 Material Icons 선택
- `npm i @fontsource/material-icons`

#### 머터리얼 아이콘 사용하기
- `import '@fontsource/material-icons'`

### Icon 사용자 컴포넌트 구현하기
#### component/index.ts
```ts
export * from './components'
```

#### component/Icon.tsx
```tsx
import {CSSProperties, FC} from "react";

export type IconProps = {
  name: string
  style?: CSSProperties
}

export const Icon: FC<IconProps> = ({name, style}) => {
  return <span className="material-icons" style={style}>{name}</span>
}
```

#### pages/UsingIcon.tsx
```tsx
import {Icon} from "../components";

export default function UsingIcon() {
    return (
        <div>
            <h3>UsingIcon</h3>
            <Icon name="home" style={{color: 'blue'}}/>
            <Icon name="check_circle_outline" style={{fontSize: '50px', color: 'red'}}/>
        </div>
    )
}
```

### Icon 컴포넌트 개선하기
#### 전개 연산자(spread operator)
```javascript
const obj1 = { a: 1 };
const obj2 = { b: 2, c: 3 };

const obj3 = { ...obj1, ...obj2 };

console.log(obj3) // { a: 1, b: 2, c: 3 }
```
#### 잔여 연산자(rest operator)
```javascript
function func({ a, ...otherProps }) {
  console.log(a) // 1
  console.log(otherProps) // { b: 2, c: 3 }
}

func({ a: 1, b: 2, c: 3 })
```

#### 클래스 선택자 사용하기
#### App.css
```css
.text-blue { color: blue;}
.text-red { color: red;}
```

#### pages/UsingIconWithCssClass.tsx
```tsx
import {Icon} from "../components";

export default function UsingIconWithCSSClass() {
    return (
        <div>
            <h3>UsingIconWithCSSClass</h3>
            <Icon name="home" className="text-blue" />
            <Icon name="check_circle_outline" className="text-red" style={{fontSize: '50px'}} />
        </div>
    )
};
```

#### 리액트가 제공하는 DetailedHTMLProps와 HTMLAttributes 타입
- span 요소 정의: `React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>`
- `<span>` 요소의 모든 속성을 표현하는 타입
```tsx
import type {FC, DetailedHTMLProps, HTMLAttributes} from 'react'
type ReactSpanProps = DetailedHTMLProps<HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>
```

#### 타입스크립트 교집합 타입 구문
- 함수형 언어에서는 `|` 기호를 쓰는 합집합 타입(union type)과 `&` 기호를 쓴느 교집합 타입(intersection type)이란 구문을 제공합니다.
- `A|B`는 'A 또는 B인 타입'이란 의미
- `A&B`는 'A이고 B인 타입'
- 다음 IconProps 타입은 ReactSpanProps 타입이면서 동시에 특별히 이름을 짖지 않은 `{name: string}`인 타입입니다.
```tsx
export type IconProps = ReactSpanProps & { name: string}
```
- IconProps가 이 2가지 타입의 교집합 타입이므로 다음처럼 `{name: string}` 타입의 name 속성과 ReactSpanProps 타입 props를 잔여 연산자 구문으로 각기 얻을 수 있습니다.
- `export const Icon: FC<IconProps> = ({name, ...props}) => {}`

#### 타입스크립트에서 매개변수 이름 바꾸기
- 타입스크립트는 매개변수 이름 뒤에 콜론(:)을 붙이는 방식으로 매개변수 이름을 다른 이름으로 바꿀 수 있습니다.
- `export const Icon: FC<IconProps> = ({name, className: _className, ...props}) => {}`

#### 완성된 Icon 컴포넌트
```tsx
import {CSSProperties, DetailedHTMLProps, FC, HTMLAttributes} from "react";

type ReactSpanProps = DetailedHTMLProps<HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>

export type IconProps = ReactSpanProps & { name: string}

export const Icon: FC<IconProps> = ({name, className: _className, ...props}) => {
    const className = ['material-icons', _className].join(' ')
    return <span {...props} className={className} >{name}</span>
}

```

## 03-2 테일윈드CSS 리액트 프로젝트 만들기
- 프로젝트 생성 ch03_2

### PostCSS가 탄생한 배경
- PostCSS는 ESNext 자바스크립트의 바벨이 그러하듯이 다양한 플러그인을 자유롭게 장착할 수 있도록 하여, CSS 표준에 추가되기를 요청하는 많은 기능을
표준화 이전에 실험해 볼 수 있게 하였습니다.
- PostCSS는 웹팩이 1차로 만든 CSS를 가공하여 최종 CSS를 생성해 내는 방법으로 동작합니다.
- PostCSS는 웹팩의 플러그인이면서 그 자체는 자신의 PostCSS 플러그인을 동작시키는 프로그램입니다.
- 테일윈드CSS는 PostCSS 플러그인 방식으로 동작하는 진보된 CSS 프레임워크 입니다.
- `autoprefixer`: 벤더 접두사 문재를 해결해주는 플러그인

### 테일윈드CSS 사용하기
- 테일윈드CSS는 2017년 11월에 '유틸리티 최우선'을 가치로 만든 CSS프레임워크
- 테일윈드CSS는 PostCSS 버전 8의 플러그인 형태로 동작합니다.
- 테일윈드CSS는 그 자체로도 훌륭한 프레임워크지만 테일윈드CSS를 바탕으로 한 약 16종의 고수준 CSS 프레임워크가 있다는 장접이 있습니다.

#### PostCSS와 autoprefixer, 그리고 테일윈드 CSS 설치하기
- CSS 관점에서 브라우저 호환성 문제는 `-webkit`, `-moz`, `-ms` 등으로 대표되는 벤더 접두사 문제입니다.
- CSS 표준은 `linear-gradient`지만 구글 크롬이나 애플 사파리 브라우저에서는 `-webkit-linear-gradient`, 마이크로소프트 브라우저에서는 `-ms-linear-gradient`와 같은 이름으로 사용해야하는 문제입니다.
- autoprefixer는 대표적인 PostCSS 플러그인으로 이런 벤더 접두사 문제를 해결해 주는 역할을 합니다.
- autoprefixer는 사용자 CSS가 젠더 접두사를 붙이지 않더라도 후처리 과정에서 자동으로 벤더 접두사가 붙은 CSS를 생성해 줍니다.
- autoprefixer는 테일윈드CSS와 마찬가지로 PostCSS의 플러그인 형태로 동작하므로 autoprefixer 기능을 사용하려면 PostCSS도 함께 설치해야 합니다.
  * `npm i -D postcss autoprefixer tailwindcss`
  
#### 구성파일 만들기
- 테일윈드CSS는 PostCSS의 플러그인 형태로 동작하며 PostCSS가 테일윈드CSS를 플러그인으로 동작시키려면 postcss.config.js 파일에 테일윈드CSS를 등록해야 합니다.
- 그리고 테일윈드CSS는 PostCSS와는 별도로 자신만의 구성 파일이 있어야 합니다.
- 테일윈드 CSS는 이처럼 2가지 구성파일을 쉽게 생성할 수 있도록 다음 명령을 제공합니다. `npx tailwindcss init -p`

##### postcss.config.js
```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

##### tailwind.config.js
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

#### daisyui 패키지 설치하기
- 테일윈드CSS는 부트스트랩과 같은 CSS 프레임워크를 쉽게 개발할 수 있게 해주는 저수준 프레임워크 입니다. 이에 따라 테일윈드 자체에는 `btn` `btn-primary`처럼 사용하는 소위 CSS 컴포넌트들을 제공하지 않습니다.
- 테일윈드CSS 사용해 부트스트랩처럼 CSS 컴포넌트를 제공하는 다양한 테일윈드 CSS컴포넌트가 있으며 이들은 모두 테일윈드CSS의 플러그인 형태로 동작합니다.
- 이 중 무료로 제공하는 컴포넌트가 가장 많은 daisyui 플러그인이 있습니다.
- `npm i -D daisyui`

#### tailwindcss/line-clamp 플러그인 설치하기
- 테일윈드CSS는 기본으로 제공하는 기능 외에도 다양한 새 기능을 추가할 수 있게 하는 플러그인 시스템도 제공합니다.
- 테일윈드CSs 플러그인 이름에 `@tailwindcss/`라는 접두사가 붙은 패키지는 테일윈드CSS 제작사가 직접 만들어 제공하는 것입니다.
- 이 패키지는 테일윈드CSS 기본에는 없는 기능을 추가로 사용할 수 있게 합니다.
- 여러 줄의 텍스트를 지정한 줄 수로 잘라서 표시해 주는 `@tailwindcss/line-clamp` 플러그인을 사용하겠습니다.
- `npm i -D @tailwindcss/line-clamp`
  
#### 테일윈드 구성 파일 수정하기
##### tailwind.config.js
```js
module.exports = {
  content: [
      "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [require('@tailwindcss/line-clamp', require('daisyui'))],
}
```

#### 테일윈드CSS 기능 반영하기
##### index.css
```css
@tailwind base;
@tailwind component;
@tailwind utilities

/*...*/
```

#### 테일윈드 CSS 테스트코드 작성하기
- `line-clamp-3`: 텍스트가 아무리 길어도 3줄을 넘지 말라는 의미
- `bg-black/70`: 불투명도가 70%dls rjawjd
- `text-gray-50`: 텍스트 생상은 약간 회색빛이 나는 흰색으로 표시

### 색상을 설정하는 방법
#### CSS 색상 모델과 rgb, hsl 함수
- `RGB`: 빨강-초록-파랑으로 표현
- `HSL`: 색상-채도-명도 형태의 실린더형 좌표로 표현

##### 색상 표현방식
- 검정: `rgb(0, 0, 0)`, `#000000`, `hsl(0, 100%, 0%)`
- 흰색: `rgb(255, 255, 255)`, `#ffffff`, `hsl(0, 100%, 100%)`
- 빨강: `rgb(255, 0, 0)` , `#ff00000`, `hsl(0, 100%, 50%)`

#### CSS의 opacity 스타일 속성과 rgba, hsla CSS 함수
- CSS는 색상의 불투명도를 표현할 수 있도록 opacity라는 이름의 스타일 속성을 제공합니다.
- 불투명도는 알파값으로 불리기도 하는데, 불투명도는 알파값 0~1 사이의 소수로 표현합니다. 
  * 0이면 완전히 투명함.
  * 1이면 완전희 불투명함
- CSS는 색상과 알파값을 동시에 표현할 수 있는 rgba와 hsla라는 CSS함수도 제공합니다.
  * `rgba(0, 0, 0, 0.4)`

#### 테일윈드 CSS 색상 클래스
- `bg-black/70` , `text-white`, `text-gray-50`
- 무채색 이름 규칙: `접두사-색상명/불투명도` ,불투명도 생략가능
- 유채색 이름 규칙: `접두사-색상_이름-채도/불투명도`
- 접두사는 배경색을 의미하는 `bg`, 텍스트 색상을 의미하는 `text`, 경계 색상을 의미하는 `border`등을 사용할 수 있습니다.
- 검은색과 흰색은 무채색이므로 채도 라는 개념이 없습니다. `bg-black/70` `접두사-(black 혹은 white)/불투명도`
- 빨강,파랑 등 유채색은 채도 개념이 도입되어 `text-gray-50` `접두사-색상-채도/불투명도` 형태의 이름을 가진 클래스를 제공합니다.
- 테일윈드CSS 색상의 채도 부분은 50, 100, 200, 300, 400, 500, 600, 700, 800, 900 등 10개 번호로 세분합니다. 숫자가 클수록 어두운 색상입니다.
- 불투명도는 20~100 사이에서 5나 10씩 증가하는 숫자로 제한합니다. 

##### Color.tsx
```tsx
export function Color() {
    return (
        <div className="p-4 bg-sky-700">
            <p className="w-full p-4 text-3xl text-white">Color</p>
            <div className="mb-4">
                <p className="text-white">Email address</p>
                <input type="email" className="text-gray-900 border-sky-200 border-4" />
                <p className="text-rose-500">This field is required</p>
            </div>
        </div>
    );
}
```

### 텍스트를 설정하는 방법
- `em`: 부모요소의 폰트 사이즈에 의해 자식요소의 폰트 사이즈가 결정되는 방식 (M 문자의 높이를 의미함)
- `rem`: Root의 폰트 사이즈에 의해 결정되는 방식(Root란 html이라는 선택자 또는 body 선택자를 말함, body를 Root로 잡아도 되지만 일반적으로 body 보다는 더 상위 선택자인 html 선택자를 Root로 사용합니다.) M 문자의 높이를 의미함

#### 글자 크기 설정하기
- `font-size`: 글꼴의 크기, 즉 글자의 높이를 의미
- `line-height`: 글자의 높이에 여분의 높이를 더한 값을 설정 라인의 높이
- 웹브라우저는 텍스트 표시를 담당하는 `<h1>`~`<h6>`, `<p>` 요소에 각기 다른 font-size와 ling-height 값을 기본으로 설정해 놓습니다.
- 그런데 웹 브라우저마다 이 기본 설정 값이 조금씩 달라서 디자인한 웹 페이지가 모든 브라우저에서 똑같이 보이지 않는다는 문제가 있습니다.
- 이 때문에 테일윈드CSS는 `<h1>`~`<h6>`, `<p>` 요소에 기본으로 설정된 글자 크기를 모두 초기화 합니다.
- 글자 크기를 설정하는 클래스를 제공하여 태그와 상관없이 글자 크기를 조절할 수 있게 해줍니다.
  * `text-xs`: `font-size: 0.75rem; line-height: 1rem;`
  * `text-sm`: `font-size: 0.875rem; line-height: 1.25rem;`
  * `text-base`: `font-size: 1rem; line-height: 1.5rem;`
  * `text-lg`: `font-size: 1.125rem; line-height: 1.75rem;`
  * `text-xl`: `font-size: 1.25rem; line-height: 1.75rem;`
  * `text-2xl`: `font-size: 1.5rem; line-height: 2rem;`
  * `text-3xl`: `font-size: 1.825rem; line-height: 2.25rem;`
  * `text-4xl`: `font-size: 2.25rem; line-height: 2.5rem;`
  * `text-5xl`: `font-size: 3rem; line-height: 1;`

#### 글자 굵기 설정하기
- `font-normal` 클래스는 font-weight 속성값을 400으로 설정하며 보통은 이 값이 각 글자의 굵기 입니다.
- 400보다 낮은 숫자일수록 글자가 옅게 보이며, 400보다 높을수록 글자가 진하게 보입니다.
  * `font-thin`: `font-weight: 100;`
  * `font-light`: `font-weight: 300;`
  * `font-normal`: `font-weight: 400;`
  * `font-medium`: `font-weight: 500;`
  * `font-bold`: `font-weight: 700;`
  * `font-black`: `font-weight: 900;`

#### 기울임꼴 설정하기
- `italic`: `font-style: italic;`
- `non-italic`: `font-style: normal`

#### 줄바꿈 문자 설정하기
- 줄바꿈문자 `\n`은 HTML 에서는 `화이트 스페이스(white space)`로 간주되어 무시 됩니다.
- 하지만 CSS에서는 white-space 스타일 속성값으로 웹 브라우저가 어떻게 해석할지 설정할 수 있습니다.
  * `whitespace-normal`: `white-space: normal;`
  * `whitespace-nowrap`: `white-space: nowrap;`
  * `whitespace-pre`: `white-space: pre;`
  * `whitespace-pre-line`: `white-space: pre-line;`
  * `whitespace-pre-wrap`: `white-space: pre-wrap;`
- 참고: https://developer.mozilla.org/ko/docs/Web/CSS/white-space

#### 텍스트 표시 줄 수 조절하기
- `@tailwindcss/line-clamp` 플러그인
- `line-clamp-숫자`: `line-clamp-3` 텍스트가 아무리 길어도 최대 3줄로 출력하고, 텍스트 멘 뒤에 생략 문자열 (...)을 붙이라는 의미

#### 텍스트 관련 컴포넌트 구현하기
- Title, Subtitle, Summary, Paragraph 컴포넌트를 만들어 보겠습니다.

##### components/textUtil.ts
```ts
export const makeClassName = (setting: string, _className?: string, numberOfLines?: number) =>
    [setting, numberOfLines ? `line-clamp-${numberOfLines}` : '', _className].join(' ');

```

##### components/Texts.tsx
```tsx
import {DetailedHTMLProps, FC, HTMLAttributes} from "react";
import {makeClassName} from "./textUtil";

type TextProps = DetailedHTMLProps<HTMLAttributes<HTMLParagraphElement>, HTMLParagraphElement>

export type TitleProps = TextProps & {
    numberOfLines?: number
}

export const Title: FC<TitleProps> = ({
                                          className: _className,
                                          numberOfLines,
                                          ...props
                                      }) => {
    const className = makeClassName(
        'font-bold text-5xl text-center whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}

export type SubtitleProps = TitleProps & {};
export const Subtitle: FC<SubtitleProps> = ({
                                                className: _className,
                                                numberOfLines,
                                                ...props
                                            }) => {
    const className = makeClassName(
        'font-semibold text-3xl text-center whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}

export type SummaryProps = SubtitleProps & {};
export const Summary: FC<SubtitleProps> = ({
                                               className: _className,
                                               numberOfLines,
                                               ...props
                                           }) => {
    const className = makeClassName(
        'text-sm whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}

export type ParagraphProps = SummaryProps & {};
export const Paragraph: FC<ParagraphProps> = ({
                                                  className: _className,
                                                  numberOfLines,
                                                  ...props
                                              }) => {
    const className = makeClassName(
        'font-normal text-base whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}
```

##### page/TextsTest.tsx
```tsx
import * as D from '../data'
import {Paragraph, Subtitle, Summary, Title} from "../components";

const paragraphs = D.makeArray(2).map(D.randomParagraphs).join('\n\n');
const summary = D.makeArray(3).map(D.randomSentence).join('\n')
export default function TextsTest() {
    return (
        <div>
            <Title>TextsTest</Title>
            <div>
                <Title className="text-blue-600">{D.randomTitleText()}</Title>
                <Subtitle className="text-blue-400">{D.randomSentence()}</Subtitle>
                <p className="text-xl italic text-center text-gray-900 text-bold">
                    {D.randomName()}
                </p>
                <Paragraph numberOfLines={5}>{paragraphs}</Paragraph>
                <Summary className="text-center text-gray-500">{summary}</Summary>
                <p className="text-center text-pink-400">
                    {D.randomDayMonthYear()} ({D.randomRelativeDate()})
                </p>
            </div>
        </div>
    )
}
```

## 03-3 CSS 상자 모델 이해하기
- ch03_3 프로젝트 생성

### 상자 모델이란?
- 상자모델은 HTML 태그가 웹 브라우저 화면에 모두 상자 모양으로 보이는 것을 모델링 한 것
- 이 모델에 따라 HTML 요소는 width와 height라는 스타일 속성을 가집니다.
- CSS 상자 모델 표준은 레벨 1, 2, 3이 있으며 CSS1, CSS2, CSS3등의 이름으로 레벨에 따른 CSS를 구분합니다.

### with와 height 스타일 속성
- 두 속성은 `auto`, `inherit`, `initail`, `unset` 등의 CSS 키워드값을 설정하거나
- 숫자 뒤에 픽셀을 의미하는 `px` 또는 `퍼센트`, `em`, `rem`등 단위를 붙입니다.
- 단위를 생략하면 `px` 단위로 간주합니다.

### Div 컴포넌트 구현하기
#### WidthHeight.ts
```ts
export type WidthHeight = {
  width?: string
  height?: string
}
```
#### Div.tsx
```tsx
import {DetailedHTMLProps, FC, HTMLAttributes, PropsWithChildren} from "react";
import {WidthHeight} from "./WidthHeight";

export type ReactDivProps = DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>

export type DivProps = ReactDivProps & PropsWithChildren<WidthHeight>

export const Div: FC<DivProps> = ({
                                      width,
                                      height,
                                      style: _style,
                                      ...props
                                  }) => {
  const style = {..._style, width, height}
  return <div {...props} style={style} />
}

```

#### DivTest.tsx
```tsx
import {Title, Subtitle, Div, Icon} from '../components'

export default function DivTest() {
    return (
        <section className="mt-4">
            <Title>DivTest</Title>
            <Div className="text-center text-blue-100 bg-blue-600" height="6rem">
            {/*<Div className="text-center text-blue-100 bg-blue-600">*/}
                <Icon name="home" className="text-3xl" />
                <Subtitle>Home</Subtitle>
            </Div>
        </section>
    )
}
```

### 컨테이너와 콘텐츠, 그리고 box-sizing 스타일 속성
- HTML에서는 부모요소, 자식 요소처럼 관계를 표현하지만 CSS에서는 부모요소를 **컨테이너(container)**, 자식요소를 **콘텐츠(content)** 라고 표현합니다.
- 컨테이느의 크기를 테두리 내부 영역이라고 하면 '컨테이너 크기 = 테두리 두께 + 패딩 두께 + 콘텐츠 영역 크기'
- 전통적으로 CSS에서는 테두리와 패딩을 무시한 콘텐츠 영역의 크기만 컨테이너 크기로 보아왔습니다.
- 이 때문에 CSS표준은 box-sizing이란 스타일 속성을 제공하여 컨테이너 크기를 결정하게 합니다.
- `box-sizing: content-box | padding-box | border-box | inherit`
- 테일윈드 CSS
  * `content-box`: `box-content`
  * `border-box`: `box-border` 
- **요즘은 box-sizing 속성값을 border-box로 설정하는 추세입니다.**

#### 참고 tailwindCSS preflight
- @tailwind baseCSS에 포함하면 Tailwind에서 자동으로 다음 스타일을 삽입합니다 .
```
@tailwind base; /* Preflight will be injected here */
@tailwind components;
@tailwind utilities;
```
- `box-sizing` 기본으로 `boder-box` 설정
- Tailwind 프로젝트를 위한 독창적인 기본 스타일 세트입니다.
- https://tailwindcss.com/docs/preflight

### 케스케이딩 알아보기
- 아이콘과 텍스트 색상값을 각각 설정하지 않고, 부모 컴포넌트인 Div에 설정했는데 이것이 CSS의 **캐스케이딩**입니다.
```html
<Div className="text-center text-blue-100 bg-blue-600">
  <Icon name="home" className="text-3xl" />
  <Subtitle>Home</Subtitle>
</Div>
```
- `cascading`이라는 단어는 "위에서 아래로 물이 계단을 따라 흘러내린다" 라는 의미로 해석 할 수 있습니다.

### 뷰포트 알아보기
- 뷰포트는 웹 페이지에서 사용자가 볼 수 있는 영역입니다. 
- 뷰포트는 모바일, 태블릿, 데스크톱 등 웹 브라우저가 동작하는 장치의 화면 크기가 각각 달라서 생긴 개념입니다.
- 뷰포트의 관점에서 HTML 요소의 넓이는 'viewport width'라는 의미로 `vw`, 높이는 'viewport height'라는 의미로 `vh`라는 단위를 사용합니다.
- `vw`와 `vh`는 각각 1~100까지의 값을 가지며 이 값은 퍼센트 개념과 같습니다.
- 즉 `100vw`는 웹브라우저가 동작하는 디스플레이 장치의 100% 넓이를 의미하고, `100vh`는 100% 높이를 의미합니다.
- 테일윈드CSSsms 뷰포트 크기를 지정하는 클래스 2개를 제공합니다.
  * `w-screen`: `width 100vw;`
  * `h-screen`: `height: 100vh;`

#### ViewportTest.tsx
```tsx
import {Title} from '../components'

export default function ViewportTest() {
    return (
        <section className="w-screen h-screen mt-4 bg-indigo-900">
            <Title className="text-white">ViewportTest</Title>
        </section>
    )
```
- 테일윈드CSS는 vw, vh 단위 대신 퍼센트 단위를 사용하는 w-full, h-full 클래스도 제공합니다.
  * `w-full`: `width: 100%;`
  * `h-full`: `height: 100%`
- w-full과 h-full은 부모 요소를 기준으로 100%로 설정됩니다.

### 테일윈드CSS의 길이 관련 클래스
- width 의미하는 'w', height를 의미하는 'h'뒤에 숫자를 쓰는 표기법을 가진 클래스들도 제공합니다.
  * `w-숫자`
  * `w-분자/분모`
  * `h-숫자`
  * `h-분자/분모`
- 여기서 숫자 단위는 rem입니다. `w-4`는 1rem, `h-4`도 1rem입니다. (1당 0.25rem)
- `w-1/2`, `h-1/2` 각각 부모 요소의 width와 height의 `50%`인 값을 설정합니다.

#### HeightTest.tsx
```tsx
import {Title, Div} from '../components'

export default function HeightTest() {
    return (
        <section className="mt-4">
            <Title>HeightTest</Title>
            <Div className="h-40 text-center bg-blue-500 mt-4">
                <Div className="bg-blue-500 h-1/2">
                    <p className="text-center text-red-50">h-1/2</p>
                </Div>
                <Div className="bg-red-500 h-1/2">
                    <p className="text-center text-red-50">h-1/2</p>
                </Div>
            </Div>
        </section>
    )
}
```

### padding 스타일 속성
- `p(x | y | t | l | b | r)-숫자`

### margin 스타일 속성
- `m(x | y | t | l | b | r)-숫자 | 분자/분모`

### background-image 스타일 속성
- `<img>`는 HTML 요소 중 유일하게 width와 height 속성이 있습니다. 이 속성은 이미지를 가로 세로 화면 비율에 맞춰 화면에 표시합니다.
- `<img src={src} className="bg-gray-300" width="400" height="400" />`
  * 이미지가 로딩되기 전에는 400x400 영역에 바탕색이 보이지만, 실제 이미지가 로딩되면 이미지의 높이가 줄어드는 현상을 볼 수 있습니다.
  * 이는 이미지가 왜곡되어 보지이 않도록 웹 브라우저가 화면 비율을 고려해 height 값을 계산 했기 때문입니다.
  * `<img>`의 이런 특성은 이미지를 특정 높이로 고정하기 어렵게 하므로 디자이너들은 대부분 CSS의 background-image 스타일 속성을 선호합니다.
- `background-image: url(이미지_URL)`
  * background-image 스타일 속성은 다음처럼 url이란 CSS함수에 이미지를 URL을 매개변수로 사용하는 형태로 사용합니다.
  * 이 형태는 이미지 URL 부분을 타입스크립트 코드애서 결정하려고 할 때 조금 번거롭습니다.
  * 앞서 구현한 Div 컴포넌트에 src 속성을 추가하여 background-image 스타일 속성을 좀 더 쉽게 사용할 수 있게 만들겠습니다.

#### Div 컴포넌트에 src 속성 추가
```tsx
import {DetailedHTMLProps, FC, HTMLAttributes, PropsWithChildren} from "react";
import {WidthHeight} from "./WidthHeight";

export type ReactDivProps = DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>

export type DivProps = ReactDivProps & PropsWithChildren<WidthHeight> & {
    src?: string
}

export const Div: FC<DivProps> = ({
                                      width,
                                      height,
                                      style: _style,
                                      src,
                                      className: _className,
                                      ...props
                                  }) => {
    const style = {..._style, width, height, backgroundImage: src && `url(${src})`};
    const className = ['box-sizing', src && 'bg-gray-300', _className].join(' ')
    return <div {...props} className={className} style={style}/>
}
```

### background-size 스타일 속성
- `bg-auto`: `background-size: auto;`
- `bg-cover`: `background-size: cover;`
- `bg-contain`: `background-size: bg-contain;`

### border 스타일 속성
- css: `border: border-width || boder-style || boder-color`
- 테일윈드CSS
  * `border`: `border-width: 1px`
  * `border-t`: `border-top-width: 1px`
  * `border-r`: `border-right-width: 1px`
  * `border-b`: `border-bottom-width: 1px`
  * `border-l`: `border-left-width: 1px`
  * `border-(0 | 2 | 4 | 8)` 픽셀
  * `border-t-(0 | 2 | 4 | 8)` 픽셀
  * `border-r-(0 | 2 | 4 | 8)` 픽셀
  * `border-b-(0 | 2 | 4 | 8)` 픽셀
  * `border-l-(0 | 2 | 4 | 8)` 픽셀
  * `border-solid` : `border-style: solid;`
  * `border-dashed`: `border-style: dashed;`
  * `border-dotted`: `border-style: dotted;`
  * `border-double`: `border-style: doulbe;`
  * `border-none`: `border-style: none;`
  * `border-transparent` : `border-color: transparent`
  * `border-black` : `--tw-border-opacity: 1; border-color: rgba(0, 0, 0, var(--tw-border-opacity)`
  * `border-white` : `--tw-border-opacity: 1; border-color: rgba(255, 255, 255, var(--tw-border-opacity)`
  * `border-색상_이름-색상_번호`
  
### border-radius 스타일 속성
- CSS는 모서리를 둥글게 만드는 border-radius 스타일 속성을 제공합니다.
- 이 스타일 속성 값은 픽셀, 퍼센트, em, rem 등의 단위를 설정할 수 있습니다.
- `rounded` : `border-radius: 0.25rem;`
- `rounded-full`: `border-radius: 9999px`
- `rounded-sm`: `boder-radius: 0.125rem;`
- `rounded-md`: `border-raidus: 0.375rem;`
- `rounded-lg`: `border-radius: 0.5rem;`
- `rounded-xl`: `border-radius:0.75rem;`
- `rounded-2xl`: `border-radius: 1rem;`
- `rounded-(t | b)-(sm | md | lg | xl | 2xl ...)`
- `rounded-(tl | tr | bl | br)-(sm | md | lg | xl)`

### Avatar 컴포넌트 만들기
#### Avatar.tsx
```tsx
import {Div, DivProps} from "./Div";
import {FC} from "react";

export type AvatarProps = DivProps & {
    size?: string
}

export const Avatar: FC<AvatarProps> = ({
                                            className: _className,
                                            style,
                                            src,
                                            size,
                                            ...props
                                        }) => {
    const w_or_h = size ?? '3rem'
    const className = ['rounded-full bg-cover bg-gray-300', _className].join(' ')
    return (
        <Div
            {...props}
            src={src}
            width={w_or_h}
            height={w_or_h}
            className={className}
            style={style}/>
    )
}
```

#### AvatarTest.tsx
```tsx
import {Avatar, Div, Title} from '../components'
import * as D from '../data'

export default function AvatarTest() {
    const avatars = D.range(0, 10).map(index => (
        <Avatar
        className="inline-block border-4 border-white -ml-6"
        key={index}
        src={D.randomAvatar()}
        />
    ))

    return (
        <section className="mt-4">
            <Title>AvatarTest</Title>
            <Div className="px-12 py-4 m-8 bg-blue-300">{avatars}</Div>
        </section>
    )
}
```

### display 스타일 속성
- inline 요소는 더 이상 수평으로 배치할 수 없을 때 줄을 바꾼다음 왼쪽에서 오른쪽으로 배치됩니다. `<span>`
- inline 요소는 width와 height 스타일 속성값을 명시적으로 설정할 수 없습니다. 설정할 수는 있지만 반영되지는 않습니다.
- block 요소는 수직으로 배치되는 HTML 요소들의 의미하여 `<div>` 가 대표적입니다. block 요소는 width와 height 스타일 속성값을 명시적으로 설정할 수 있고, 이 설정에 따라 자신의 
넓이와 높이를 설정할 수 있습니다.
- inline-block 요소는 inline과 block의 특성을 결합한 것입니다. inline이므로 수평으로 배치되지만, block이므로 width와 height 스타일 속성값을 설정할 수 있습니다.

#### DisplayTest.tsx
```tsx
import {Title, Subtitle} from '../components'
import * as D from '../data'

export default function DisplayTest() {
    const inlineChildren = D.range(1, 5 + 1).map(number => (
        <div key={number} className="inline w-8 h-8 m-4 text-center text-gray-700 bg-sky-300">
            {number}
        </div>
    ))

    const blockChildren = D.range(1, 5 + 1).map(number => (
        <div key={number} className="block w-8 h-8 m-4 text-center text-gray-700 bg-sky-300">
            {number}
        </div>
    ))

    const inlineBlockChildren = D.range(1, 5 + 1).map(number => (
        <div key={number} className="inline-block w-8 h-8 m-4 text-center text-gray-700 bg-sky-300">
            {number}
        </div>
    ))

    return (
        <section className="mt-4">
            <Title>DisplayTest</Title>
            <div>
                <Subtitle>dispaly: inline</Subtitle>
                {inlineChildren}
            </div>
            <div>
                <Subtitle>dispaly: block</Subtitle>
                {blockChildren}
            </div>
            <div>
                <Subtitle>dispaly: inline-block</Subtitle>
                {inlineBlockChildren}
            </div>
        </section>
    )
}
```

### visibility 스타일 속성
- `display: none`인 요소의 크기는 화명에 반영되지 않지만, `visibility: hidden`은 화면에 보이지 않아도 요소의 크기는 그대로 반영됩니다.
- `visible` : `visibility: visible;`
- `invisible`: `visibility: hidden;`

#### DisplayNoneTest.tsx
```tsx
import {Title} from '../components'

export default function DisplayNoneTest() {
    return (
        <section className="mt-4">
            <Title>DisplayNoneTest</Title>
            <div className="mt-4">
                <p className="visible">visibility: visible text</p>
                <p className="invisible">visibility: hidden text</p>
                <p className="hidden">display: none text</p>
            </div>
        </section>
    )
}
```

### position과 left, top, right, bottom 스타일 속성
- CSS는 left, right, top, bottom 등 HTML 요소의 위치를 표현하는 스타일 속성을 제공합니다. 그런데 위치 관련 스타일 속성은 그냥 사용할 수 없고 position 스타일 속성에 
absolute 라는 값이 설정되어 있어야 합니다.
- 테일윈드 position
  * `absolute`: `position: absolute;`
  * `relative`: `position: relative;`
  * `static`: `position: static;`
  * `fixed`: `position: fixed;`
  * `sticky`: `position: sticky;`

#### PositionTest.tsx
```tsx
import {Div, Title, Icon} from '../components'
import * as D from '../data'

const src = D.randomImage(800, 500)
// prettier-ignore
export default function PositionTest() {
    const icons = ['home', 'search', 'settings', 'favorite'].map(name => (
        <Icon key={name} name={name} className="mr-2" />
    ))
    return (
        <Div>
            <Title>PositionTest</Title>
            <Div className="relative border-2 border-gray-500"
                 src={src} height="10rem">
                <Div className="absolute p-2 text-white bg-red-500"
                     left="1rem" top="1rem">{icons}</Div>
                <Div className="absolute p-2 text-white bg-blue-500"
                     right="1rem" top="1rem">{icons}</Div>
                <Div className="absolute p-2 text-white bg-pink-500"
                     left="1rem" bottom="1rem">{icons}</Div>
                <Div className="absolute p-2 text-white bg-yellow-500"
                     right="1rem" bottom="1rem">{icons}</Div>
            </Div>
        </Div>
    )
}
```

### z-index 스타일 속성
- position 스타일 속성값이 relative이거나 absolute로 설정된 여러 HTML 요소가 있으면, 해당 HTML 요소들에는 '쌓임 맥락(stacking context)'이란 매커니즘이 발생합니다.
- 쌓임 맥락은 z축을 사용한 HTML 요소의 3차원 개념화입니다. z축은 모니터를 보는 사람의 눈 사이의 가상 축을 의미합니다.
- `z-index` 속성값이 0이면 모니터 표면에 근접한 것이고, 그 값이 클수록 사람의 눈 쪽에 가까운 것을 의미합니다.

### Overlay 컴포넌트 만들기
- 모달 대화 상자가 나타나면 웹 페이지의 다른 곳을 사용자가 임의로 클릭할 수 없게 하는 화면 UI를 `오버레이(overlay)`라고 합니다.

#### Overlay.tsx
```tsx
import {Div, ReactDivProps} from "./Div";
import {FC} from "react";

export type OverlayProps = ReactDivProps & {
    opacityClass?: string
}

export const Overlay: FC<OverlayProps> = ({
    className: _className,
    opacityClass,
    children,
    ...props
                                             }) => {
    const className = [
        _className,
        'absolute z-50 w-screen h-screen',
        opacityClass ?? 'bg-black/70',
        'flex items-center justify-center'
    ].join(' ')

    return (
        <Div {...props} className={className} top="0" left="0">{children}</Div>
    )
}
```

#### OverlayTest.tsx
```tsx
import {Title, Div, Icon, Overlay} from '../components'

export default function OverlayTest() {
    return (
        <section className="mt-4">
            <Title>OverlayTest</Title>
            <Overlay opacityClass="bg-black/70">
                <Div className="relative flex items-center justify-center p-8 bg-white h-1/2">
                    <Div className="absolute" right="1rem" top="1rem">
                        <Icon name="close" className="text-gray-500" />
                    </Div>
                    <p className="text-5xl">modal dialog box</p>
                </Div>
            </Overlay>
        </section>
    )
}
```
## 03-4 플렉스 레이아웃 이해하기
- 플렉스 레이아웃은 다양한 HTML 요소를 화면에 간편하게 배치할 수 있게 하는 표준입니다.
- 프로젝트 생성 ch03_4

### 플렉스박스 레이아웃이란?
- **플렉스박스 레이아웃(flexbox layout)** 이란 display 스타일 속성에 flex라고 설정하고 그 안에 콘텐츠 아이템을 배치한 것을 의미합니다.
- 이때 플렉스 컨테이너는 콘텐츠 아이템의 inline과 block 성질을 완전히 무시합니다.
- 어떤 HTML 요소에 `dispaly: flex;`로 설정하면 해당 요소를 플렉스 컨테이너로 만들 수 있습니다.
- 테일윈드CSS
  * `flex`: `dispaly: flex`

### flex-direction 스타일 속성
- 이 속성은 display 설정 값이 flex일 때만 사용할 수 있습니다.
- `flex-row`: `flex-direction: row;`
- `flex-row-reverse`: `flex-direction: row-reverse;`
- `flex-col`: `flex-direction: column;`
- `flex-col-reverse`: `flex-direction: column-reverse;`
- 
#### DirectionTest.tsx
```tsx
import {Div, Title, Subtitle} from '../components'
import * as D from '../data'

export default function DirectionTest() {
  const boxes = D.range(1, 9 + 1).map(number => {
    return (
      <p key={number} className={`border-2 border-blue-300 p-1 mt-1 ml-1`}>
        {number}
      </p>
    )
  })
  return (
    <section className="mt-4">
      <Title>DirectionTest</Title>
      <Div className="flex flex-row mt-4">
        <Div className="mr-2">
          <Subtitle>flex-row</Subtitle>
          <Div className="flex flex-row p-4">{boxes}</Div>
        </Div>
        <Div className="mr-2">
          <Subtitle>flex-row-reverse</Subtitle>
          <Div className="flex flex-row-reverse p-4">{boxes}</Div>
        </Div>
        <Div className="mr-2">
          <Subtitle>flex-col</Subtitle>
          <Div className="flex flex-col p-4">{boxes}</Div>
        </Div>
        <Div className="mr-2">
          <Subtitle>flex-col-reverse</Subtitle>
          <Div className="flex flex-col-reverse p-4">{boxes}</Div>
        </Div>
      </Div>
    </section>
  )
}
```
### overflow 스타일 속성
- 컨테이너의 크기가 고정되었을 때 콘텐츠의 크기가 컨테이너보다 크면 **오버플로(overflow)** 가 발생합니다.
- 테일윈드 CSS
  * `overflow-auto` : `overflow: auto;`
  * `overflow-hidden`: `overflow: hidden;`
  * `overflow-visible`: `overflow: visible;`
  * `overflow-scroll`: `overflow: scroll;`

### flex-wrap 스타일 속성
- 사람의 글은 수평으로 진행하며 글을 쓸 여분이 없으면 줄바꿈을 하여 계속 글을 씁니다. 
- CSS는 이런 방식을 랩(wrap)이라고 표현하며, 어떤 스타일 속성을 wrap으로 설정하면 콘텐츠를 더 이상 수평으로 배치할 수 없을 때 자동으로 다음줄에 배치합니다.
- CSS는 플렉스 컨테이너로 하여금 이런 랩 방식을 흉내 낼 수 있도록 flex-wrap 스타일 속성을 제공합니다.
  * `flex-wrap`: `flex-wrap: wrap` 순서대로 진행
  * `flex-wrap-reverse`: `flex-wrap-reverse` 반대로 진행
  * `flex-nowrap`: `flex-wrap: nowrap` wrap하지 않음 (기본값)
- 수직 방향으로 flex-wrap을 동작 시키려면 컨테이너의 height와 height의 최소 크기를 나타내는 min-height 스타일 속성값을 똑같이 설정해 줘야 합니다.

#### WrapTest.tsx
```tsx
import {Div, Title, Subtitle} from '../components'
import * as D from '../data'

export default function WrapTest() {
  const boxes = D.range(1, 30 + 1).map(number => {
    return (
      <p key={number} className={`border-2 border-blue-300 p-1 mt-1 ml-1`}>
        {number}
      </p>
    )
  })
  return (
    <div className="mt-4">
      <Title>WrapTest</Title>
      <Div className="flex flex-col w-1/2 mt-4 bg-gray-200">
        <Div className="mt-2">
          <Subtitle>flex-row flex-wrap</Subtitle>
          <Div className="flex flex-row flex-wrap p-4">{boxes}</Div>
        </Div>
        <Div className="mt-2">
          <Subtitle>flex-row flex-wrap-reverse</Subtitle>
          <Div className="flex flex-row flex-wrap-reverse p-4">{boxes}</Div>
        </Div>
        <Div className="mt-2 ">
          <Subtitle>flex-row flex-nowrap</Subtitle>
          <Div className="flex flex-row p-4 overflow-hidden flex-nowrap">{boxes}</Div>
        </Div>
      </Div>
      <Div className="flex flex-row mt-4 bg-gray-200">
        <Div className="mr-8">
          <Subtitle>flex-column flex-wrap</Subtitle>
          <Div className="flex flex-col flex-wrap h-40 p-4 min-h-40">{boxes}</Div>
        </Div>
        <Div className="mr-8">
          <Subtitle>flex-column flex-wrap-reverse</Subtitle>
          <Div className="flex flex-col flex-wrap-reverse h-40 p-4 min-h-40">{boxes}</Div>
        </Div>
        <Div className="mr-8">
          <Subtitle>flex-column flex-nowrap</Subtitle>
          <Div className="flex flex-col h-40 p-4 overflow-hidden flex-nowrap min-h-40">
            {boxes}
          </Div>
        </Div>
      </Div>
    </div>
  )
}
```

### min-width와 max-width 스타일 속성
- 부모 컨테이너의 크기에 대응하는 콘텐츠의 최소, 최대 크기를 설정
- `min-w-숫자`, `max-w-숫자`, `min-h-숫자`, `max-h-숫자`

#### MinMaxTest.tsx
```tsx
import {Div, Title} from '../components'
import * as D from '../data'

export default function MinMaxTest() {
  // prettier-ignore
  return (
    <section className="mt-4">
      <Title>MinMaxTest</Title>
      <Div className="p-4 bg-gray-300">
        <Div src={D.randomImage(800, 300)} className="bg-cover">
          <Div className="w-1/2 bg-blue-500 h-80"
            minWidth="300px" maxWidth="500px"/>
        </Div>
      </Div>
    </section>
  )
}
```

### justify-content와 align-items 스타일 속성
- `justify-content` 스타일 속성으로 플렉스 컨테이너의 콘텐츠 요소들을 수평으로 조정합니다.
  * `justify-start`: `justify-content: flex-start;`
  * `justify-end`: `justify-content: flex-end;`
  * `justify-center`: `justify-content: center;`
  * `justify-between`: `justify-content: space-between;`
  * `justify-around`: `justify-content: space-around;`
  * `justify-evenly`: `justify-content: space-evenly;`
- `align-items`: 스타일 속성으로 플렉스 컨테이너의 콘텐츠 요소들을 수직으로 조정합니다.
  * `items-start`: `align-items: flex-start;`
  * `items-end`: `align-items: flex-end;`
  * `items-center`: `align-items: center;`
  * `items-baseline`: `align-items: baseline;`
  * `items-stretch`: `align-items: stretch;`
- `justify-*` 와 `item-*` 클래스는 플렉스 컨테이너의 방향에 따라 적용되는 방향이 반대입니다.
- 즉 수평 방향 플렉스 컨테이너에서 `justify-*`는 콘텐츠 아이탬을 수평으로 정렬 하지만, 수직 방향 플렉스 컨테이너에서는 `justify-*`는 수직으로 정렬합니다.

#### JustifyCenterTest.tsx
```tsx
import {Div, Title, Subtitle} from '../components'
import * as D from '../data'

export default function JustifyCenterTest() {
  const boxes = D.range(0, 5).map(index => (
    <Div key={index} className="w-4 h-4 m-1 bg-black" minHeight="auto" />
  ))

  return (
    <section className="p-4 mt-4">
      <Title>JustifyCenterTest</Title>
      <div className="mt-4">
        <Subtitle>flex flex-row justify-center</Subtitle>
        <div className="flex flex-row justify-center h-40 bg-gray-300">{boxes}</div>
      </div>
      <div className="mt-4">
        <Subtitle>flex flex-col justify-center</Subtitle>
        <div className="flex flex-col justify-center h-40 bg-gray-300">{boxes}</div>
      </div>
    </section>
  )
}

```

#### AlignTest.tsx
```tsx
import {Title, Subtitle} from '../components'
import * as D from '../data'

export default function AlignTest() {
  const boxes = D.range(0, 5).map(index => {
    return <div key={index} className="w-4 h-4 m-1 bg-black" />
  })
  const boxesForStretch = D.range(0, 10).map(index => {
    return <div key={index} className="w-4 m-4 bg-black" />
  })
  // prettier-ignore
  const justifies = ['justify-start', 'justify-center', 'justify-end',
    'justify-between', 'justify-around', 'justify-evenly'].map(justify => (
    <div key={justify} className="mt-4">
      <Subtitle>flex flex-row {justify}</Subtitle>
      <div  className={`flex flex-row ${justify} p-2 bg-gray-300`}>{boxes}</div>
    </div>
  ))
  const items = ['items-start', 'items-center', 'items-end'].map(item => (
    <div key={item} className="p-2 ml-4">
      <Subtitle>flex flex-row {item}</Subtitle>
      <div className={`flex flex-row ${item} h-20 bg-gray-300`}>{boxes}</div>
    </div>
  ))

  return (
    <section className="p-4 mt-4">
      <Title>AlignTest</Title>
      {justifies}
      {items}
      <div className="p-2 ml-4">
        <Subtitle>flex flex-row items-stretch</Subtitle>
        <div className="flex flex-row items-stretch h-20 bg-gray-300">
          {boxesForStretch}
        </div>
      </div>
    </section>
  )
}
```

### User 컴포넌트 만들기
#### User.tsx
```tsx
import type {FC} from 'react'
import type {DivProps} from '../components'
import * as D from '../data'
import {Div, Avatar} from '../components'

export type UserProps = DivProps & {
  user: D.IUser
}
const User: FC<UserProps> = ({user, ...props}) => {
  const {name, email, jobTitle, avatar} = user
  return (
    <Div {...props}>
      <div className="flex p-2">
        <Avatar src={avatar} size="2rem" />
        <div className="ml-2">
          <p className="font-bold line-clamp-1">{name}</p>
          <p className="text-gray-500 line-clamp-1">{jobTitle}</p>
          <p className="text-blue-500 underline">{email}</p>
        </div>
      </div>
    </Div>
  )
}
export default User
```

#### UserContainer.tsx
```tsx
import {Title} from '../components'
import * as D from '../data'
import User from './User'

export default function UserContainer() {
  const children = D.makeArray(10)
    .map(D.makeRandomUser)
    .map(user => (
      <User
        key={user.uuid}
        user={user}
        className="m-2 text-xs border-2 border-blue-300 rounded-lg "
        minWidth="15rem"
        width="15rem"
      />
    ))
  return (
    <section className="mt-4">
      <Title>UserContainer</Title>
      <div className="flex flex-wrap items-center justify-start p-4 mt-4">
        {children}
      </div>
    </section>
  )
}
```

### Card 컴포넌트 만들기
#### Card.tsx
```tsx
import type {FC} from 'react'
import type {DivProps} from '../components'
import {Div, Icon} from '../components'
import * as D from '../data'
import User from './User'

export type CardProps = DivProps & {
  card: D.ICard
}
const Card: FC<CardProps> = ({card, ...props}) => {
  const {writer, image, title, paragraphs, dayMonthYearDate, relativeDate} = card
  const icons = ['home', 'search', 'settings', 'favorite'].map(name => (
    <Icon key={name} name={name} className="mr-2 text-3xl" />
  ))

  return (
    <Div {...props}>
      <div className="flex flex-col">
        <Div src={image} className="h-60" />
        <Div className="p-4" minHeight="16rem" height="16rem" maxHeight="16rem">
          <p className="mt-2 text-3xl text-center text-bold">{title}</p>
          <Div className="flex justify-between">
            <User user={writer} className="mt-2" />
            <Div className="mt-2">
              <p className="text-gray-500">{relativeDate}</p>
              <p className="text-gray-500">{dayMonthYearDate}</p>
            </Div>
          </Div>
          <p className="mt-2 line-clamp-4">{paragraphs}</p>
          <Div className="flex flex-row items-center justify-between p-2 mt-2 text-red-500 ">
            {icons}
          </Div>
        </Div>
      </div>
    </Div>
  )
}
export default Card
```
- 카드 아래쪽은 round-xl 효과가 분명히 보이지만 위쪽은 그렇지 않다는 점입니다.
- 그 이유는 `<Div>`에 설정한 이미지가 카드 영역 바깥으로 보이는 부분을 그대로 허용했기 때문입니다.
- 이 문제는 overflow-hidden 값을 추가해 카드 영역 바깥에 보이는 부분을 잘라 주면 해결할 수 있습니다.
#### CardContainer.tsx
```tsx
import {Title} from '../components'
import * as D from '../data'
import Card from './Card'

export default function CardContainer() {
    const children = D.makeArray(10)
        .map(D.makeRandomCard)
        .map(card => (
            <Card
                key={card.uuid}
                card={card}
                className="m-2 overflow-hidden text-xs border-2 shadow-lg rounded-xl "
                minWidth="30rem"
                width="30rem"
            />
        ))
    return (
        <section className="mt-4">
            <Title>CardContainer</Title>
            <div className="flex flex-wrap items-center justify-center p-4 mt-4">
                {children}
            </div>
        </section>
    )
}

```
## daisyui CSS 컴포넌트 라이브러리 이해하기
- 프로젝트 생성 ch03_5

### CSS 컴포넌트란?
- 부트스트랩등 거의 모든 CSS 프레임워크는 `btn`, `btn-primary` 형태로 원하는 HTML 요소의 스타일링을 쉽게 하는 CSS클래스를 제공하는데, 이들 CSS프레임워크(혹은 CSS라이브러리)는 이를 'CSS 컴포넌트'라고 부릅니다.

### 색상 테마
- 웹 디자인에서 웹페이지에서 가장 많이 사용되는 색상을 주 색상(primary color)이라고 합니다.
- 두 번째로 많이 사용되는 색상을 보조 색상(secondary color)이라고 합니다.
- 색상은 주 색상과 보조 생상만으로 구분하지 않고 필요에 따라 다양한 색상을 사용할 수 있습니다.
- daisyui 플러그인 색상 테마로서 강조(accent), 정보(infomation, info), 경고(warning), 오류(error) 색상 등을 제공합니다.
- 보통 이런 색상들을 한꺼번에 부를 때 색상 테마라고 합니다.

### Button 컴포넌트 구현하기
- `<button className="btn btn-primary">button</button>`
- `<Button className="btn-primary">button</Button>` 리액트 컴포넌트가 있을경우
- `<Button>button</Button>` 아무런 설정도 하지 않으면 기본값이 적용되도록 한다면 더 간결하게 사용할 수 있습니다.

#### Button.tsx
```tsx
import type {FC, DetailedHTMLProps, ButtonHTMLAttributes, PropsWithChildren} from 'react'

export type ReactButtonProps = DetailedHTMLProps<
  ButtonHTMLAttributes<HTMLButtonElement>,
  HTMLButtonElement
>

export type ButtonProps = ReactButtonProps & {}

export const Button: FC<PropsWithChildren<ButtonProps>> = ({
  className: _className,
  ...buttonProps
}) => {
  const className = ['btn', _className].join(' ')
  return <button {...buttonProps} className={className} />
}
```

#### Basic.tsx
```tsx
import {Button} from '../../theme/daisyui'

export default function Basic() {
  return (
    <section className="mt-4">
      <h2 className="font-bold text-3xl text-center">Basic</h2>
      <div className="mt-4 flex justify-evenly">
        <button className="btn btn-primary">daysiui button</button>
        <Button className="btn btn-primary">Button</Button>
      </div>
    </section>
  )
}
```

#### 버튼의 크기 설정하기
- daisyui의 button 컴포넌트는 크기를 설정하는 4가지 클래스를 제공합니다.
  * `btn-lg`
  * `btn-md`
  * `btn-sm`
  * `btn-xs`

#### Size.tsx
```tsx
import {Button} from '../../theme/daisyui'

export default function Size() {
  return (
    <section className="mt-4">
      <h2 className="font-bold text-3xl text-center">Size</h2>
      <div className="mt-4 flex justify-evenly">
        <Button className="btn-lg btn-primary">size lg</Button>
        <Button className="btn-md btn-secondary">size md</Button>
        <Button className="btn-sm btn-accent">size sm</Button>
        <Button className="btn-xs btn-info">size xs</Button>
      </div>
    </section>
  )
}
```

### Icon 컴포넌트 구현하기
#### Icon.tsx
```tsx
import type {FC} from 'react'
import type {ButtonProps} from './Button'
import type {IconProps as CIconProps} from '../../components'
import {Button} from './Button'
import {Icon as CIcon} from '../../components'

export type IconProps = ButtonProps &
  CIconProps & {
    iconClassName?: string
  }

export const Icon: FC<IconProps> = ({name, iconClassName, className, ...buttonProps}) => {
  const btnClassName = ['btn-circle', className].join(' ')
  return (
    <Button {...buttonProps} className={btnClassName}>
      <CIcon className={iconClassName} name={name} />
    </Button>
  )
}
```

### Input 컴포넌트 구현하기
#### Input.tsx
```tsx
import type {FC, DetailedHTMLProps, InputHTMLAttributes} from 'react'

export type ReactInputProps = DetailedHTMLProps<
  InputHTMLAttributes<HTMLInputElement>,
  HTMLInputElement
>

export type inputProps = ReactInputProps & {}

export const Input: FC<inputProps> = ({className: _className, ...inputProps}) => {
  const className = ['input', _className].join(' ')
  return <input {...inputProps} className={className} />
}
```

### 모달 컴포넌트 구현하기
- 사용자의 선택을 입력받는 대화 상자는 크게 모덜리스(modeless)와, 모달(modal) 2가지 종류가 있습니다.
- 모달리스 대화상자는 영역 바깥쪽을 클릭할 수 있지만, 모달 대화 상자는 영역 바깥 쪽의 UI가 동작하지 않습니다.
- daisyui 모달 대화 상자는 크게 `modal`, `modal-box`, `modal-action`등 3가지 클래스로 구성하며, `modal` 클래스에 `modal-open` 클래스를 추가하면 대화 상자가 화면에 나타납니다.
```tsx
<div className="modal modal-open">
  <div className="modal-box">
    <p>modal content</p>
    <div className="modal-action">
      <button className="btn btn-primary">Accept</button>
      <button className="btn">Close</button>
    </div>
</div>
```

#### Modal.tsx
```tsx
import type {FC} from 'react'
import type {ReactDivProps} from '../../components'
import {Div} from '../../components'
import {Icon} from './Icon'

export type ModalProps = ReactDivProps & {
  open?: boolean
}
export const Modal: FC<ModalProps> = ({open, className: _className, ...props}) => {
  const className = ['modal', open ? 'modal-open' : '', _className].join(' ')
  return <div {...props} className={className} />
}

export type ModalContentProps = ReactDivProps & {
  onCloseIconClicked?: () => void
  closeIconClassName?: string
}
export const ModalContent: FC<ModalContentProps> = ({
  onCloseIconClicked,
  closeIconClassName: _closeIconClassName,
  className: _className,
  children,
  ...props
}) => {
  const showCloseIcon = onCloseIconClicked ? true : false
  const className = ['modal-box', showCloseIcon && 'relative', _className].join(' ')
  if (!showCloseIcon) return <div {...props} className={className} children={children} />

  const closeIconClassName = _closeIconClassName ?? 'btn-primary btn-outline btn-sm'
  return (
    <div {...props} className={className}>
      <Div className="absolute" right="0.5rem" top="0.5rem">
        <Icon name="close" className={closeIconClassName} onClick={onCloseIconClicked} />
      </Div>
      {children}
    </div>
  )
}

export type ModalActionProps = ReactDivProps & {}
export const ModalAction: FC<ModalActionProps> = ({className: _className, ...props}) => {
  const className = ['modal-action', _className].join(' ')
  return <div {...props} className={className} />
}
```
