> 출처 : Do it 리액트 모던 웹 개발 with 타입스크립트 (저자: 전예홍)

# 3.컴포넌트 CSS 스타일링
## 03-1 리액트 컴포넌트의 CSS 스타일링
- ch03_1 프로젝트 생성

### 컴포넌트 스타일링
#### 부트스트랩 사용해 보기
- public 디렉터리의 index.html 파일에 다음처럼 붙여 넣기
```html
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
```

#### 부트스트랩 컴포넌트 구현하기
- 오류가 있는 부트스트랩 스타일링 코드
```tsx
export default function Bootstrap() {
    return <form>
        <div class="mb-3">
            <label for="exampleInputEmail1" class="form-label">Email address</label>
            <input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp">
                <div id="emailHelp" class="form-text">We'll never share your email with anyone else.</div>
        </div>
        <div class="mb-3">
            <label for="exampleInputPassword1" class="form-label">Password</label>
            <input type="password" class="form-control" id="exampleInputPassword1">
        </div>
        <div class="mb-3 form-check">
            <input type="checkbox" class="form-check-input" id="exampleCheck1">
                <label class="form-check-label" for="exampleCheck1">Check me out</label>
        </div>
        <button type="submit" class="btn btn-primary">Submit</button>
    </form>
}
```

#### 리액트 className과 htmlFor 속성
- 자바스크립트(혹은 타입스크립트) 키워드인 class와 for가 혼란을 줍니다.
  * `class` -> `className`
  * `for` -> `htmlFor`

### 웹팩과 CSS 파일 임포트
- 리액트 프로젝가 내부적으로 사용하는 웹팩은 `.css` 파일을 좀 더 쉽게 사용할 수 있게 도와줍니다.
- 웹팩은 타입스크립트 코드에서 import 문 형태로 CSS 파일을 `<link>` 태그 없으 이용할 수 있게 해줍니다.
```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css';
```
- 이 코드는 웹펙이 같은 디렉터리의 index.css 파일을 포함하여 배포하도록 합니다.

### CSS 기본 구문
- `-apple-system` 처럼 붙임표(hyphen) 기호 '-'로 시작하는 속성이나 값을 벤더 접두사라고 합니다.
- 벤더 접두사는 구글, 애플 등 웹 브라우저 제작업체에서 만든 CSS 기능으로, W3C 표준에는 없는 비표준 기능입니다.


### 선택자란?
- 전체 선택자: `*`
- 유형 선택자: `h1`, `h2`
- 클래스 선택자: `.wrapper`

### @import 규칙으로 아이콘 사용하기
- CSS는 `@import`, `@media` 등 @으로 시작하는 구문을 제공하는데, 이런 구문을 앳 규칙이라고 합니다.
- CSS의 `@import` 규칙은 `<link rel='stylesheet' href>` 대신 .css 파일에서 다른 .css 파일을 사용하고자 할 때 적용합니다.
- 다음은 `@import`로 구글 머티리얼 아이콘 세트를 사용하는 코드입니다.
  * `@import url('https://fonts.googleapis.com/icon?family=Material+Icons`);

> 참고: @규칙(At-Rule) https://uxkm.io/publishing/css/03-cssMiddleclass/07-css_atrule#gsc.tab=0
#### `@Charset`
- 스타일 시트에 쓰이는 문자 인코딩을 지정합니다.
- 스타일 시트의 첫 번째 요소여야 하며 어떤 문자가 선행되지 않아야 합니다. `@charset "utf-8";`

#### `@import`
- 스타일 시트에서 다른 스타일 규칙을 가져올 때 쓰입니다.
- 이 규칙은 `@charset` 규칙을 제외하고 모든 다른 종류의 규칙보다 선행해야 합니다.

```css
@import [ <string> | <url> ] [ <media-query-list> ];
```

#### `@namespace`
- CSS 스타일 시트에서 사용되는 XML 네임스페이스를 정의하는 at-규칙입니다.

#### `@supports`
- 하나 이상의 특정 CSS 기능에 대한 브라우저의 지원에 따라 선언을 지정할 수 있습니다. 이를 기능 쿼리라고합니다.

#### `@media`
- 장치가 미디어 질의(media query)를 사용하여 정의된 조건의 기준을 만족하면 해당 콘텐츠를 적용하는 조건부 그룹 규칙입니다.
- min-width 또는 max-width 를 활용하여 반응형 레이아웃(Responsive layout)을 구현할 수 있습니다.

#### `@page`
- 문서를 인쇄할 때 일부 CSS 속성을 수정하는 데 쓰입니다. @page로 모든 CSS 속성을 바꿀 수는 없습니다.

#### `@font-face`
- 텍스트를 표시 할 사용자 정의 글꼴을 지정합니다. 글꼴은 원격 서버나 로컬 컴퓨터에서 사용자 컴퓨터에로드 할 수 있습니다.
- 우선 웹 폰트를 서버에 올려놓고, CSS 파일에 @font-face 규칙을 사용하여 웹 폰트를 정의하고 추가합니다.
  그러면 해당 웹 페이지에 접속하는 모든 웹 브라우저는 자동으로 서버에서 웹 폰트를 내려받아 해당 글꼴을 표시하게 됩니다.
- CSS3에서 @font-face 규칙을 사용하려면 다음과 같이 지정을 해야 합니다.
  * font-family : 사용할 웹 폰트의 이름을 지정합니다. 이 이름은 폰트 파일의 이름과 일치하지 않아도 상관없습니다. 하지만 비슷하게 설정하는 것이 유지 보수에 좋습니다.
  * src : 폰트 파일의 경로와 폰트의 형식을 지정합니다. url에 폰트 파일의 경로를 설정하고, format에 폰트 파일의 형식을 설정합니다.
- @font-face 규칙을 설정한 다음 웹 폰트가 필요한 선택자(selector)의 font-family 속성에서 사용할 웹 폰트의 이름을 호출해 사용합니다.
- 만약 웹 폰트 로딩이 실패하면 다음에 선언된 폰트가 렌더링됩니다. 이 폰트를 폴백 폰트(fallback font)라 합니다.

```css
@font-face {
  font-family: MyFont;
  src: url("https://a.com/fonts/myFont.woff2") format("woff2");
}

.text {
  font-family: MyFont, sans-serif;
}
```

#### `@keyframes`
- 애니메이션 시퀀스를 따라 키 프레임 (또는 웨이 포인트)의 스타일을 정의하여 CSS 애니메이션 시퀀스의 중간 단계를 제어합니다.

#### index.css
```css
@import url('https://fonts.googleapi.com/icon?family=Material+Icons');

.meterial-icons {
  font-family: 'Material Icons';
  display: inline-block;
}
```

#### Icon.tsx
```tsx
export default function Icon() {
    return (
        <div>
            <h3>Icon</h3>
            <span className="meterial-icons">home</span>
            <span className="meterial-icons">check_circle_outline</span>
        </div>
    )
}
```

#### 아이콘 이름은 어떻게 알 수 있나요?
- 구글 머터리얼 아이콘 사이트(fonts.google.com/icons)에 나와 있습니다.
- `Check Circle Outline` 타입스크립트 코드에서 사용할 때는 `check_circle_outline`처럼 밑줄 표기법으로 작성해야 합니다.

### style 속성을 사용한 인라인 스타일링
- HTML 요소는 sytle이라는 속성에 문자열로 된 CSS 코드를 설정할 수 있으며 렌더링 때 해당 코드가 반영됩니다.
  * `<div style='width: 100px; height: 100px; background-color: blue; />`
- 리액트 컴포넌트에서는 style 속성에 설정하는 값은 문자열이 아닌 객체여야 합니다. 
  * `<div style={{width: '100px', height: '100px', backgroundColor: 'blue'}} />`

#### Style.tsx
```tsx
export default function Style() {
    return (
        <div>
            <h3>Style</h3>
            <span className="material-icons" style={{color: 'blue'}}>home</span>
            <span className="material-icons" style={{fontSize: '50px', color: 'red'}}>
                check_circle_outline
            </span>
        </div>
    )
}
```

### Node.js 패키지 방식으로 아이콘 사용하기
- `@import` 방식의 한 가지 문제점은 다른 사이트에 호스팅된 외부 CSS 파일을 가져오므로 네트워크 속도에 영향을 받을 수 있습니다.
- 대부분 웹 애플리케이션은 Node.js 패키지 형태로 구현된 CSS 프레임워크를 내장하는 형태로 배포합니다.

#### 웹 안전 글꼴과 fontsource
- `@import` 규칙은 웹에 안전한 글꼴, 즉 웹 안전 글꼴을 사용해야 한다는 제약이 있습니다.
- 여기서 웹 안전 글꼴은 데스크톱, 모바일 등 모든 장치에서 동작하는 모든 브라우저에 적용할 수 있는 글꼴입니다.
- 웹 안전 글꼴은 사용자 컴퓨터에 설치되지 않은 때에도 웹 페이지에 항상 올바르게 표시되는 글꼴을 의미합니다.
- 구글이 제공하는 모든 글꼴은 웹 안전 글꼴이므로 `@import` 규칙을 적용할 수 있습니다.
- fontsource(fontsource.org)는 구글 글꼴와 같은 오픈소스 웹 안전 글꼴을 패키지 형태로 설치해 줍니다.
  * `npm i @fontsource/스테이크-표기법-글꼴명`

#### 머터리얼 아이콘 설치하기
- https://fontsource.org/fonts 웹페이지에서 material 이란 이름이 있는 패키지를 검색하여 그 중 Material Icons 선택
- `npm i @fontsource/material-icons`

#### 머터리얼 아이콘 사용하기
- `import '@fontsource/material-icons'`

### Icon 사용자 컴포넌트 구현하기
#### component/index.ts
```ts
export * from './components'
```

#### component/Icon.tsx
```tsx
import {CSSProperties, FC} from "react";

export type IconProps = {
  name: string
  style?: CSSProperties
}

export const Icon: FC<IconProps> = ({name, style}) => {
  return <span className="material-icons" style={style}>{name}</span>
}
```

#### pages/UsingIcon.tsx
```tsx
import {Icon} from "../components";

export default function UsingIcon() {
    return (
        <div>
            <h3>UsingIcon</h3>
            <Icon name="home" style={{color: 'blue'}}/>
            <Icon name="check_circle_outline" style={{fontSize: '50px', color: 'red'}}/>
        </div>
    )
}
```

### Icon 컴포넌트 개선하기
#### 전개 연산자(spread operator)
```javascript
const obj1 = { a: 1 };
const obj2 = { b: 2, c: 3 };

const obj3 = { ...obj1, ...obj2 };

console.log(obj3) // { a: 1, b: 2, c: 3 }
```
#### 잔여 연산자(rest operator)
```javascript
function func({ a, ...otherProps }) {
  console.log(a) // 1
  console.log(otherProps) // { b: 2, c: 3 }
}

func({ a: 1, b: 2, c: 3 })
```

#### 클래스 선택자 사용하기
#### App.css
```css
.text-blue { color: blue;}
.text-red { color: red;}
```

#### pages/UsingIconWithCssClass.tsx
```tsx
import {Icon} from "../components";

export default function UsingIconWithCSSClass() {
    return (
        <div>
            <h3>UsingIconWithCSSClass</h3>
            <Icon name="home" className="text-blue" />
            <Icon name="check_circle_outline" className="text-red" style={{fontSize: '50px'}} />
        </div>
    )
};
```

#### 리액트가 제공하는 DetailedHTMLProps와 HTMLAttributes 타입
- span 요소 정의: `React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>`
- `<span>` 요소의 모든 속성을 표현하는 타입
```tsx
import type {FC, DetailedHTMLProps, HTMLAttributes} from 'react'
type ReactSpanProps = DetailedHTMLProps<HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>
```

#### 타입스크립트 교집합 타입 구문
- 함수형 언어에서는 `|` 기호를 쓰는 합집합 타입(union type)과 `&` 기호를 쓴느 교집합 타입(intersection type)이란 구문을 제공합니다.
- `A|B`는 'A 또는 B인 타입'이란 의미
- `A&B`는 'A이고 B인 타입'
- 다음 IconProps 타입은 ReactSpanProps 타입이면서 동시에 특별히 이름을 짖지 않은 `{name: string}`인 타입입니다.
```tsx
export type IconProps = ReactSpanProps & { name: string}
```
- IconProps가 이 2가지 타입의 교집합 타입이므로 다음처럼 `{name: string}` 타입의 name 속성과 ReactSpanProps 타입 props를 잔여 연산자 구문으로 각기 얻을 수 있습니다.
- `export const Icon: FC<IconProps> = ({name, ...props}) => {}`

#### 타입스크립트에서 매개변수 이름 바꾸기
- 타입스크립트는 매개변수 이름 뒤에 콜론(:)을 붙이는 방식으로 매개변수 이름을 다른 이름으로 바꿀 수 있습니다.
- `export const Icon: FC<IconProps> = ({name, className: _className, ...props}) => {}`

#### 완성된 Icon 컴포넌트
```tsx
import {CSSProperties, DetailedHTMLProps, FC, HTMLAttributes} from "react";

type ReactSpanProps = DetailedHTMLProps<HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>

export type IconProps = ReactSpanProps & { name: string}

export const Icon: FC<IconProps> = ({name, className: _className, ...props}) => {
    const className = ['material-icons', _className].join(' ')
    return <span {...props} className={className} >{name}</span>
}

```

## 03-2 테일윈드CSS 리액트 프로젝트 만들기
- 프로젝트 생성 ch03_2

### PostCSS가 탄생한 배경
- PostCSS는 ESNext 자바스크립트의 바벨이 그러하듯이 다양한 플러그인을 자유롭게 장착할 수 있도록 하여, CSS 표준에 추가되기를 요청하는 많은 기능을
표준화 이전에 실험해 볼 수 있게 하였습니다.
- PostCSS는 웹팩이 1차로 만든 CSS를 가공하여 최종 CSS를 생성해 내는 방법으로 동작합니다.
- PostCSS는 웹팩의 플러그인이면서 그 자체는 자신의 PostCSS 플러그인을 동작시키는 프로그램입니다.
- 테일윈드CSS는 PostCSS 플러그인 방식으로 동작하는 진보된 CSS 프레임워크 입니다.
- `autoprefixer`: 벤더 접두사 문재를 해결해주는 플러그인

### 테일윈드CSS 사용하기
- 테일윈드CSS는 2017년 11월에 '유틸리티 최우선'을 가치로 만든 CSS프레임워크
- 테일윈드CSS는 PostCSS 버전 8의 플러그인 형태로 동작합니다.
- 테일윈드CSS는 그 자체로도 훌륭한 프레임워크지만 테일윈드CSS를 바탕으로 한 약 16종의 고수준 CSS 프레임워크가 있다는 장접이 있습니다.

#### PostCSS와 autoprefixer, 그리고 테일윈드 CSS 설치하기
- CSS 관점에서 브라우저 호환성 문제는 `-webkit`, `-moz`, `-ms` 등으로 대표되는 벤더 접두사 문제입니다.
- CSS 표준은 `linear-gradient`지만 구글 크롬이나 애플 사파리 브라우저에서는 `-webkit-linear-gradient`, 마이크로소프트 브라우저에서는 `-ms-linear-gradient`와 같은 이름으로 사용해야하는 문제입니다.
- autoprefixer는 대표적인 PostCSS 플러그인으로 이런 벤더 접두사 문제를 해결해 주는 역할을 합니다.
- autoprefixer는 사용자 CSS가 젠더 접두사를 붙이지 않더라도 후처리 과정에서 자동으로 벤더 접두사가 붙은 CSS를 생성해 줍니다.
- autoprefixer는 테일윈드CSS와 마찬가지로 PostCSS의 플러그인 형태로 동작하므로 autoprefixer 기능을 사용하려면 PostCSS도 함께 설치해야 합니다.
  * `npm i -D postcss autoprefixer tailwindcss`
  
#### 구성파일 만들기
- 테일윈드CSS는 PostCSS의 플러그인 형태로 동작하며 PostCSS가 테일윈드CSS를 플러그인으로 동작시키려면 postcss.config.js 파일에 테일윈드CSS를 등록해야 합니다.
- 그리고 테일윈드CSS는 PostCSS와는 별도로 자신만의 구성 파일이 있어야 합니다.
- 테일윈드 CSS는 이처럼 2가지 구성파일을 쉽게 생성할 수 있도록 다음 명령을 제공합니다. `npx tailwindcss init -p`

##### postcss.config.js
```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

##### tailwind.config.js
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

#### daisyui 패키지 설치하기
- 테일윈드CSS는 부트스트랩과 같은 CSS 프레임워크를 쉽게 개발할 수 있게 해주는 저수준 프레임워크 입니다. 이에 따라 테일윈드 자체에는 `btn` `btn-primary`처럼 사용하는 소위 CSS 컴포넌트들을 제공하지 않습니다.
- 테일윈드CSS 사용해 부트스트랩처럼 CSS 컴포넌트를 제공하는 다양한 테일윈드 CSS컴포넌트가 있으며 이들은 모두 테일윈드CSS의 플러그인 형태로 동작합니다.
- 이 중 무료로 제공하는 컴포넌트가 가장 많은 daisyui 플러그인이 있습니다.
- `npm i -D daisyui`

#### tailwindcss/line-clamp 플러그인 설치하기
- 테일윈드CSS는 기본으로 제공하는 기능 외에도 다양한 새 기능을 추가할 수 있게 하는 플러그인 시스템도 제공합니다.
- 테일윈드CSs 플러그인 이름에 `@tailwindcss/`라는 접두사가 붙은 패키지는 테일윈드CSS 제작사가 직접 만들어 제공하는 것입니다.
- 이 패키지는 테일윈드CSS 기본에는 없는 기능을 추가로 사용할 수 있게 합니다.
- 여러 줄의 텍스트를 지정한 줄 수로 잘라서 표시해 주는 `@tailwindcss/line-clamp` 플러그인을 사용하겠습니다.
- `npm i -D @tailwindcss/line-clamp`
  
#### 테일윈드 구성 파일 수정하기


## 03-3 CSS 상자 모델 이해하기
## 03-4 플렉스 레이아웃 이해하기
## daisyui CSS 컴포넌트 라이브러리 이해하기
