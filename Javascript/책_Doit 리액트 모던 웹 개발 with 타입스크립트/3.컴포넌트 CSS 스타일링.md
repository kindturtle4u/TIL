> 출처 : Do it 리액트 모던 웹 개발 with 타입스크립트 (저자: 전예홍)

# 3.컴포넌트 CSS 스타일링
## 03-1 리액트 컴포넌트의 CSS 스타일링
- ch03_1 프로젝트 생성

### 컴포넌트 스타일링
#### 부트스트랩 사용해 보기
- public 디렉터리의 index.html 파일에 다음처럼 붙여 넣기
```html
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
```

#### 부트스트랩 컴포넌트 구현하기
- 오류가 있는 부트스트랩 스타일링 코드
```tsx
export default function Bootstrap() {
    return <form>
        <div class="mb-3">
            <label for="exampleInputEmail1" class="form-label">Email address</label>
            <input type="email" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp">
                <div id="emailHelp" class="form-text">We'll never share your email with anyone else.</div>
        </div>
        <div class="mb-3">
            <label for="exampleInputPassword1" class="form-label">Password</label>
            <input type="password" class="form-control" id="exampleInputPassword1">
        </div>
        <div class="mb-3 form-check">
            <input type="checkbox" class="form-check-input" id="exampleCheck1">
                <label class="form-check-label" for="exampleCheck1">Check me out</label>
        </div>
        <button type="submit" class="btn btn-primary">Submit</button>
    </form>
}
```

#### 리액트 className과 htmlFor 속성
- 자바스크립트(혹은 타입스크립트) 키워드인 class와 for가 혼란을 줍니다.
  * `class` -> `className`
  * `for` -> `htmlFor`

### 웹팩과 CSS 파일 임포트
- 리액트 프로젝가 내부적으로 사용하는 웹팩은 `.css` 파일을 좀 더 쉽게 사용할 수 있게 도와줍니다.
- 웹팩은 타입스크립트 코드에서 import 문 형태로 CSS 파일을 `<link>` 태그 없으 이용할 수 있게 해줍니다.
```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css';
```
- 이 코드는 웹펙이 같은 디렉터리의 index.css 파일을 포함하여 배포하도록 합니다.

### CSS 기본 구문
- `-apple-system` 처럼 붙임표(hyphen) 기호 '-'로 시작하는 속성이나 값을 벤더 접두사라고 합니다.
- 벤더 접두사는 구글, 애플 등 웹 브라우저 제작업체에서 만든 CSS 기능으로, W3C 표준에는 없는 비표준 기능입니다.


### 선택자란?
- 전체 선택자: `*`
- 유형 선택자: `h1`, `h2`
- 클래스 선택자: `.wrapper`

### @import 규칙으로 아이콘 사용하기
- CSS는 `@import`, `@media` 등 @으로 시작하는 구문을 제공하는데, 이런 구문을 앳 규칙이라고 합니다.
- CSS의 `@import` 규칙은 `<link rel='stylesheet' href>` 대신 .css 파일에서 다른 .css 파일을 사용하고자 할 때 적용합니다.
- 다음은 `@import`로 구글 머티리얼 아이콘 세트를 사용하는 코드입니다.
  * `@import url('https://fonts.googleapis.com/icon?family=Material+Icons`);

> 참고: @규칙(At-Rule) https://uxkm.io/publishing/css/03-cssMiddleclass/07-css_atrule#gsc.tab=0
#### `@Charset`
- 스타일 시트에 쓰이는 문자 인코딩을 지정합니다.
- 스타일 시트의 첫 번째 요소여야 하며 어떤 문자가 선행되지 않아야 합니다. `@charset "utf-8";`

#### `@import`
- 스타일 시트에서 다른 스타일 규칙을 가져올 때 쓰입니다.
- 이 규칙은 `@charset` 규칙을 제외하고 모든 다른 종류의 규칙보다 선행해야 합니다.

```css
@import [ <string> | <url> ] [ <media-query-list> ];
```

#### `@namespace`
- CSS 스타일 시트에서 사용되는 XML 네임스페이스를 정의하는 at-규칙입니다.

#### `@supports`
- 하나 이상의 특정 CSS 기능에 대한 브라우저의 지원에 따라 선언을 지정할 수 있습니다. 이를 기능 쿼리라고합니다.

#### `@media`
- 장치가 미디어 질의(media query)를 사용하여 정의된 조건의 기준을 만족하면 해당 콘텐츠를 적용하는 조건부 그룹 규칙입니다.
- min-width 또는 max-width 를 활용하여 반응형 레이아웃(Responsive layout)을 구현할 수 있습니다.

#### `@page`
- 문서를 인쇄할 때 일부 CSS 속성을 수정하는 데 쓰입니다. @page로 모든 CSS 속성을 바꿀 수는 없습니다.

#### `@font-face`
- 텍스트를 표시 할 사용자 정의 글꼴을 지정합니다. 글꼴은 원격 서버나 로컬 컴퓨터에서 사용자 컴퓨터에로드 할 수 있습니다.
- 우선 웹 폰트를 서버에 올려놓고, CSS 파일에 @font-face 규칙을 사용하여 웹 폰트를 정의하고 추가합니다.
  그러면 해당 웹 페이지에 접속하는 모든 웹 브라우저는 자동으로 서버에서 웹 폰트를 내려받아 해당 글꼴을 표시하게 됩니다.
- CSS3에서 @font-face 규칙을 사용하려면 다음과 같이 지정을 해야 합니다.
  * font-family : 사용할 웹 폰트의 이름을 지정합니다. 이 이름은 폰트 파일의 이름과 일치하지 않아도 상관없습니다. 하지만 비슷하게 설정하는 것이 유지 보수에 좋습니다.
  * src : 폰트 파일의 경로와 폰트의 형식을 지정합니다. url에 폰트 파일의 경로를 설정하고, format에 폰트 파일의 형식을 설정합니다.
- @font-face 규칙을 설정한 다음 웹 폰트가 필요한 선택자(selector)의 font-family 속성에서 사용할 웹 폰트의 이름을 호출해 사용합니다.
- 만약 웹 폰트 로딩이 실패하면 다음에 선언된 폰트가 렌더링됩니다. 이 폰트를 폴백 폰트(fallback font)라 합니다.

```css
@font-face {
  font-family: MyFont;
  src: url("https://a.com/fonts/myFont.woff2") format("woff2");
}

.text {
  font-family: MyFont, sans-serif;
}
```

#### `@keyframes`
- 애니메이션 시퀀스를 따라 키 프레임 (또는 웨이 포인트)의 스타일을 정의하여 CSS 애니메이션 시퀀스의 중간 단계를 제어합니다.

#### index.css
```css
@import url('https://fonts.googleapi.com/icon?family=Material+Icons');

.meterial-icons {
  font-family: 'Material Icons';
  display: inline-block;
}
```

#### Icon.tsx
```tsx
export default function Icon() {
    return (
        <div>
            <h3>Icon</h3>
            <span className="meterial-icons">home</span>
            <span className="meterial-icons">check_circle_outline</span>
        </div>
    )
}
```

#### 아이콘 이름은 어떻게 알 수 있나요?
- 구글 머터리얼 아이콘 사이트(fonts.google.com/icons)에 나와 있습니다.
- `Check Circle Outline` 타입스크립트 코드에서 사용할 때는 `check_circle_outline`처럼 밑줄 표기법으로 작성해야 합니다.

### style 속성을 사용한 인라인 스타일링
- HTML 요소는 sytle이라는 속성에 문자열로 된 CSS 코드를 설정할 수 있으며 렌더링 때 해당 코드가 반영됩니다.
  * `<div style='width: 100px; height: 100px; background-color: blue; />`
- 리액트 컴포넌트에서는 style 속성에 설정하는 값은 문자열이 아닌 객체여야 합니다. 
  * `<div style={{width: '100px', height: '100px', backgroundColor: 'blue'}} />`

#### Style.tsx
```tsx
export default function Style() {
    return (
        <div>
            <h3>Style</h3>
            <span className="material-icons" style={{color: 'blue'}}>home</span>
            <span className="material-icons" style={{fontSize: '50px', color: 'red'}}>
                check_circle_outline
            </span>
        </div>
    )
}
```

### Node.js 패키지 방식으로 아이콘 사용하기
- `@import` 방식의 한 가지 문제점은 다른 사이트에 호스팅된 외부 CSS 파일을 가져오므로 네트워크 속도에 영향을 받을 수 있습니다.
- 대부분 웹 애플리케이션은 Node.js 패키지 형태로 구현된 CSS 프레임워크를 내장하는 형태로 배포합니다.

#### 웹 안전 글꼴과 fontsource
- `@import` 규칙은 웹에 안전한 글꼴, 즉 웹 안전 글꼴을 사용해야 한다는 제약이 있습니다.
- 여기서 웹 안전 글꼴은 데스크톱, 모바일 등 모든 장치에서 동작하는 모든 브라우저에 적용할 수 있는 글꼴입니다.
- 웹 안전 글꼴은 사용자 컴퓨터에 설치되지 않은 때에도 웹 페이지에 항상 올바르게 표시되는 글꼴을 의미합니다.
- 구글이 제공하는 모든 글꼴은 웹 안전 글꼴이므로 `@import` 규칙을 적용할 수 있습니다.
- fontsource(fontsource.org)는 구글 글꼴와 같은 오픈소스 웹 안전 글꼴을 패키지 형태로 설치해 줍니다.
  * `npm i @fontsource/스테이크-표기법-글꼴명`

#### 머터리얼 아이콘 설치하기
- https://fontsource.org/fonts 웹페이지에서 material 이란 이름이 있는 패키지를 검색하여 그 중 Material Icons 선택
- `npm i @fontsource/material-icons`

#### 머터리얼 아이콘 사용하기
- `import '@fontsource/material-icons'`

### Icon 사용자 컴포넌트 구현하기
#### component/index.ts
```ts
export * from './components'
```

#### component/Icon.tsx
```tsx
import {CSSProperties, FC} from "react";

export type IconProps = {
  name: string
  style?: CSSProperties
}

export const Icon: FC<IconProps> = ({name, style}) => {
  return <span className="material-icons" style={style}>{name}</span>
}
```

#### pages/UsingIcon.tsx
```tsx
import {Icon} from "../components";

export default function UsingIcon() {
    return (
        <div>
            <h3>UsingIcon</h3>
            <Icon name="home" style={{color: 'blue'}}/>
            <Icon name="check_circle_outline" style={{fontSize: '50px', color: 'red'}}/>
        </div>
    )
}
```

### Icon 컴포넌트 개선하기
#### 전개 연산자(spread operator)
```javascript
const obj1 = { a: 1 };
const obj2 = { b: 2, c: 3 };

const obj3 = { ...obj1, ...obj2 };

console.log(obj3) // { a: 1, b: 2, c: 3 }
```
#### 잔여 연산자(rest operator)
```javascript
function func({ a, ...otherProps }) {
  console.log(a) // 1
  console.log(otherProps) // { b: 2, c: 3 }
}

func({ a: 1, b: 2, c: 3 })
```

#### 클래스 선택자 사용하기
#### App.css
```css
.text-blue { color: blue;}
.text-red { color: red;}
```

#### pages/UsingIconWithCssClass.tsx
```tsx
import {Icon} from "../components";

export default function UsingIconWithCSSClass() {
    return (
        <div>
            <h3>UsingIconWithCSSClass</h3>
            <Icon name="home" className="text-blue" />
            <Icon name="check_circle_outline" className="text-red" style={{fontSize: '50px'}} />
        </div>
    )
};
```

#### 리액트가 제공하는 DetailedHTMLProps와 HTMLAttributes 타입
- span 요소 정의: `React.DetailedHTMLProps<React.HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>`
- `<span>` 요소의 모든 속성을 표현하는 타입
```tsx
import type {FC, DetailedHTMLProps, HTMLAttributes} from 'react'
type ReactSpanProps = DetailedHTMLProps<HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>
```

#### 타입스크립트 교집합 타입 구문
- 함수형 언어에서는 `|` 기호를 쓰는 합집합 타입(union type)과 `&` 기호를 쓴느 교집합 타입(intersection type)이란 구문을 제공합니다.
- `A|B`는 'A 또는 B인 타입'이란 의미
- `A&B`는 'A이고 B인 타입'
- 다음 IconProps 타입은 ReactSpanProps 타입이면서 동시에 특별히 이름을 짖지 않은 `{name: string}`인 타입입니다.
```tsx
export type IconProps = ReactSpanProps & { name: string}
```
- IconProps가 이 2가지 타입의 교집합 타입이므로 다음처럼 `{name: string}` 타입의 name 속성과 ReactSpanProps 타입 props를 잔여 연산자 구문으로 각기 얻을 수 있습니다.
- `export const Icon: FC<IconProps> = ({name, ...props}) => {}`

#### 타입스크립트에서 매개변수 이름 바꾸기
- 타입스크립트는 매개변수 이름 뒤에 콜론(:)을 붙이는 방식으로 매개변수 이름을 다른 이름으로 바꿀 수 있습니다.
- `export const Icon: FC<IconProps> = ({name, className: _className, ...props}) => {}`

#### 완성된 Icon 컴포넌트
```tsx
import {CSSProperties, DetailedHTMLProps, FC, HTMLAttributes} from "react";

type ReactSpanProps = DetailedHTMLProps<HTMLAttributes<HTMLSpanElement>, HTMLSpanElement>

export type IconProps = ReactSpanProps & { name: string}

export const Icon: FC<IconProps> = ({name, className: _className, ...props}) => {
    const className = ['material-icons', _className].join(' ')
    return <span {...props} className={className} >{name}</span>
}

```

## 03-2 테일윈드CSS 리액트 프로젝트 만들기
- 프로젝트 생성 ch03_2

### PostCSS가 탄생한 배경
- PostCSS는 ESNext 자바스크립트의 바벨이 그러하듯이 다양한 플러그인을 자유롭게 장착할 수 있도록 하여, CSS 표준에 추가되기를 요청하는 많은 기능을
표준화 이전에 실험해 볼 수 있게 하였습니다.
- PostCSS는 웹팩이 1차로 만든 CSS를 가공하여 최종 CSS를 생성해 내는 방법으로 동작합니다.
- PostCSS는 웹팩의 플러그인이면서 그 자체는 자신의 PostCSS 플러그인을 동작시키는 프로그램입니다.
- 테일윈드CSS는 PostCSS 플러그인 방식으로 동작하는 진보된 CSS 프레임워크 입니다.
- `autoprefixer`: 벤더 접두사 문재를 해결해주는 플러그인

### 테일윈드CSS 사용하기
- 테일윈드CSS는 2017년 11월에 '유틸리티 최우선'을 가치로 만든 CSS프레임워크
- 테일윈드CSS는 PostCSS 버전 8의 플러그인 형태로 동작합니다.
- 테일윈드CSS는 그 자체로도 훌륭한 프레임워크지만 테일윈드CSS를 바탕으로 한 약 16종의 고수준 CSS 프레임워크가 있다는 장접이 있습니다.

#### PostCSS와 autoprefixer, 그리고 테일윈드 CSS 설치하기
- CSS 관점에서 브라우저 호환성 문제는 `-webkit`, `-moz`, `-ms` 등으로 대표되는 벤더 접두사 문제입니다.
- CSS 표준은 `linear-gradient`지만 구글 크롬이나 애플 사파리 브라우저에서는 `-webkit-linear-gradient`, 마이크로소프트 브라우저에서는 `-ms-linear-gradient`와 같은 이름으로 사용해야하는 문제입니다.
- autoprefixer는 대표적인 PostCSS 플러그인으로 이런 벤더 접두사 문제를 해결해 주는 역할을 합니다.
- autoprefixer는 사용자 CSS가 젠더 접두사를 붙이지 않더라도 후처리 과정에서 자동으로 벤더 접두사가 붙은 CSS를 생성해 줍니다.
- autoprefixer는 테일윈드CSS와 마찬가지로 PostCSS의 플러그인 형태로 동작하므로 autoprefixer 기능을 사용하려면 PostCSS도 함께 설치해야 합니다.
  * `npm i -D postcss autoprefixer tailwindcss`
  
#### 구성파일 만들기
- 테일윈드CSS는 PostCSS의 플러그인 형태로 동작하며 PostCSS가 테일윈드CSS를 플러그인으로 동작시키려면 postcss.config.js 파일에 테일윈드CSS를 등록해야 합니다.
- 그리고 테일윈드CSS는 PostCSS와는 별도로 자신만의 구성 파일이 있어야 합니다.
- 테일윈드 CSS는 이처럼 2가지 구성파일을 쉽게 생성할 수 있도록 다음 명령을 제공합니다. `npx tailwindcss init -p`

##### postcss.config.js
```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

##### tailwind.config.js
```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

#### daisyui 패키지 설치하기
- 테일윈드CSS는 부트스트랩과 같은 CSS 프레임워크를 쉽게 개발할 수 있게 해주는 저수준 프레임워크 입니다. 이에 따라 테일윈드 자체에는 `btn` `btn-primary`처럼 사용하는 소위 CSS 컴포넌트들을 제공하지 않습니다.
- 테일윈드CSS 사용해 부트스트랩처럼 CSS 컴포넌트를 제공하는 다양한 테일윈드 CSS컴포넌트가 있으며 이들은 모두 테일윈드CSS의 플러그인 형태로 동작합니다.
- 이 중 무료로 제공하는 컴포넌트가 가장 많은 daisyui 플러그인이 있습니다.
- `npm i -D daisyui`

#### tailwindcss/line-clamp 플러그인 설치하기
- 테일윈드CSS는 기본으로 제공하는 기능 외에도 다양한 새 기능을 추가할 수 있게 하는 플러그인 시스템도 제공합니다.
- 테일윈드CSs 플러그인 이름에 `@tailwindcss/`라는 접두사가 붙은 패키지는 테일윈드CSS 제작사가 직접 만들어 제공하는 것입니다.
- 이 패키지는 테일윈드CSS 기본에는 없는 기능을 추가로 사용할 수 있게 합니다.
- 여러 줄의 텍스트를 지정한 줄 수로 잘라서 표시해 주는 `@tailwindcss/line-clamp` 플러그인을 사용하겠습니다.
- `npm i -D @tailwindcss/line-clamp`
  
#### 테일윈드 구성 파일 수정하기
##### tailwind.config.js
```js
module.exports = {
  content: [
      "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [require('@tailwindcss/line-clamp', require('daisyui'))],
}
```

#### 테일윈드CSS 기능 반영하기
##### index.css
```css
@tailwind base;
@tailwind component;
@tailwind utilities

/*...*/
```

#### 테일윈드 CSS 테스트코드 작성하기
- `line-clamp-3`: 텍스트가 아무리 길어도 3줄을 넘지 말라는 의미
- `bg-black/70`: 불투명도가 70%dls rjawjd
- `text-gray-50`: 텍스트 생상은 약간 회색빛이 나는 흰색으로 표시

### 색상을 설정하는 방법
#### CSS 색상 모델과 rgb, hsl 함수
- `RGB`: 빨강-초록-파랑으로 표현
- `HSL`: 색상-채도-명도 형태의 실린더형 좌표로 표현

##### 색상 표현방식
- 검정: `rgb(0, 0, 0)`, `#000000`, `hsl(0, 100%, 0%)`
- 흰색: `rgb(255, 255, 255)`, `#ffffff`, `hsl(0, 100%, 100%)`
- 빨강: `rgb(255, 0, 0)` , `#ff00000`, `hsl(0, 100%, 50%)`

#### CSS의 opacity 스타일 속성과 rgba, hsla CSS 함수
- CSS는 색상의 불투명도를 표현할 수 있도록 opacity라는 이름의 스타일 속성을 제공합니다.
- 불투명도는 알파값으로 불리기도 하는데, 불투명도는 알파값 0~1 사이의 소수로 표현합니다. 
  * 0이면 완전히 투명함.
  * 1이면 완전희 불투명함
- CSS는 색상과 알파값을 동시에 표현할 수 있는 rgba와 hsla라는 CSS함수도 제공합니다.
  * `rgba(0, 0, 0, 0.4)`

#### 테일윈드 CSS 색상 클래스
- `bg-black/70` , `text-white`, `text-gray-50`
- 무채색 이름 규칙: `접두사-색상명/불투명도` ,불투명도 생략가능
- 유채색 이름 규칙: `접두사-색상_이름-채도/불투명도`
- 접두사는 배경색을 의미하는 `bg`, 텍스트 색상을 의미하는 `text`, 경계 색상을 의미하는 `border`등을 사용할 수 있습니다.
- 검은색과 흰색은 무채색이므로 채도 라는 개념이 없습니다. `bg-black/70` `접두사-(black 혹은 white)/불투명도`
- 빨강,파랑 등 유채색은 채도 개념이 도입되어 `text-gray-50` `접두사-색상-채도/불투명도` 형태의 이름을 가진 클래스를 제공합니다.
- 테일윈드CSS 색상의 채도 부분은 50, 100, 200, 300, 400, 500, 600, 700, 800, 900 등 10개 번호로 세분합니다. 숫자가 클수록 어두운 색상입니다.
- 불투명도는 20~100 사이에서 5나 10씩 증가하는 숫자로 제한합니다. 

##### Color.tsx
```tsx
export function Color() {
    return (
        <div className="p-4 bg-sky-700">
            <p className="w-full p-4 text-3xl text-white">Color</p>
            <div className="mb-4">
                <p className="text-white">Email address</p>
                <input type="email" className="text-gray-900 border-sky-200 border-4" />
                <p className="text-rose-500">This field is required</p>
            </div>
        </div>
    );
}
```

### 텍스트를 설정하는 방법
- `em`: 부모요소의 폰트 사이즈에 의해 자식요소의 폰트 사이즈가 결정되는 방식 (M 문자의 높이를 의미함)
- `rem`: Root의 폰트 사이즈에 의해 결정되는 방식(Root란 html이라는 선택자 또는 body 선택자를 말함, body를 Root로 잡아도 되지만 일반적으로 body 보다는 더 상위 선택자인 html 선택자를 Root로 사용합니다.) M 문자의 높이를 의미함

#### 글자 크기 설정하기
- `font-size`: 글꼴의 크기, 즉 글자의 높이를 의미
- `line-height`: 글자의 높이에 여분의 높이를 더한 값을 설정 라인의 높이
- 웹브라우저는 텍스트 표시를 담당하는 `<h1>`~`<h6>`, `<p>` 요소에 각기 다른 font-size와 ling-height 값을 기본으로 설정해 놓습니다.
- 그런데 웹 브라우저마다 이 기본 설정 값이 조금씩 달라서 디자인한 웹 페이지가 모든 브라우저에서 똑같이 보이지 않는다는 문제가 있습니다.
- 이 때문에 테일윈드CSS는 `<h1>`~`<h6>`, `<p>` 요소에 기본으로 설정된 글자 크기를 모두 초기화 합니다.
- 글자 크기를 설정하는 클래스를 제공하여 태그와 상관없이 글자 크기를 조절할 수 있게 해줍니다.
  * `text-xs`: `font-size: 0.75rem; line-height: 1rem;`
  * `text-sm`: `font-size: 0.875rem; line-height: 1.25rem;`
  * `text-base`: `font-size: 1rem; line-height: 1.5rem;`
  * `text-lg`: `font-size: 1.125rem; line-height: 1.75rem;`
  * `text-xl`: `font-size: 1.25rem; line-height: 1.75rem;`
  * `text-2xl`: `font-size: 1.5rem; line-height: 2rem;`
  * `text-3xl`: `font-size: 1.825rem; line-height: 2.25rem;`
  * `text-4xl`: `font-size: 2.25rem; line-height: 2.5rem;`
  * `text-5xl`: `font-size: 3rem; line-height: 1;`

#### 글자 굵기 설정하기
- `font-normal` 클래스는 font-weight 속성값을 400으로 설정하며 보통은 이 값이 각 글자의 굵기 입니다.
- 400보다 낮은 숫자일수록 글자가 옅게 보이며, 400보다 높을수록 글자가 진하게 보입니다.
  * `font-thin`: `font-weight: 100;`
  * `font-light`: `font-weight: 300;`
  * `font-normal`: `font-weight: 400;`
  * `font-medium`: `font-weight: 500;`
  * `font-bold`: `font-weight: 700;`
  * `font-black`: `font-weight: 900;`

#### 기울임꼴 설정하기
- `italic`: `font-style: italic;`
- `non-italic`: `font-style: normal`

#### 줄바꿈 문자 설정하기
- 줄바꿈문자 `\n`은 HTML 에서는 `화이트 스페이스(white space)`로 간주되어 무시 됩니다.
- 하지만 CSS에서는 white-space 스타일 속성값으로 웹 브라우저가 어떻게 해석할지 설정할 수 있습니다.
  * `whitespace-normal`: `white-space: normal;`
  * `whitespace-nowrap`: `white-space: nowrap;`
  * `whitespace-pre`: `white-space: pre;`
  * `whitespace-pre-line`: `white-space: pre-line;`
  * `whitespace-pre-wrap`: `white-space: pre-wrap;`
- 참고: https://developer.mozilla.org/ko/docs/Web/CSS/white-space

#### 텍스트 표시 줄 수 조절하기
- `@tailwindcss/line-clamp` 플러그인
- `line-clamp-숫자`: `line-clamp-3` 텍스트가 아무리 길어도 최대 3줄로 출력하고, 텍스트 멘 뒤에 생략 문자열 (...)을 붙이라는 의미

#### 텍스트 관련 컴포넌트 구현하기
- Title, Subtitle, Summary, Paragraph 컴포넌트를 만들어 보겠습니다.

##### components/textUtil.ts
```ts
export const makeClassName = (setting: string, _className?: string, numberOfLines?: number) =>
    [setting, numberOfLines ? `line-clamp-${numberOfLines}` : '', _className].join(' ');

```

##### components/Texts.tsx
```tsx
import {DetailedHTMLProps, FC, HTMLAttributes} from "react";
import {makeClassName} from "./textUtil";

type TextProps = DetailedHTMLProps<HTMLAttributes<HTMLParagraphElement>, HTMLParagraphElement>

export type TitleProps = TextProps & {
    numberOfLines?: number
}

export const Title: FC<TitleProps> = ({
                                          className: _className,
                                          numberOfLines,
                                          ...props
                                      }) => {
    const className = makeClassName(
        'font-bold text-5xl text-center whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}

export type SubtitleProps = TitleProps & {};
export const Subtitle: FC<SubtitleProps> = ({
                                                className: _className,
                                                numberOfLines,
                                                ...props
                                            }) => {
    const className = makeClassName(
        'font-semibold text-3xl text-center whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}

export type SummaryProps = SubtitleProps & {};
export const Summary: FC<SubtitleProps> = ({
                                               className: _className,
                                               numberOfLines,
                                               ...props
                                           }) => {
    const className = makeClassName(
        'text-sm whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}

export type ParagraphProps = SummaryProps & {};
export const Paragraph: FC<ParagraphProps> = ({
                                                  className: _className,
                                                  numberOfLines,
                                                  ...props
                                              }) => {
    const className = makeClassName(
        'font-normal text-base whitespace-pre-line',
        _className,
        numberOfLines
    )

    return <p {...props} className={className}/>
}
```

##### page/TextsTest.tsx
```tsx
import * as D from '../data'
import {Paragraph, Subtitle, Summary, Title} from "../components";

const paragraphs = D.makeArray(2).map(D.randomParagraphs).join('\n\n');
const summary = D.makeArray(3).map(D.randomSentence).join('\n')
export default function TextsTest() {
    return (
        <div>
            <Title>TextsTest</Title>
            <div>
                <Title className="text-blue-600">{D.randomTitleText()}</Title>
                <Subtitle className="text-blue-400">{D.randomSentence()}</Subtitle>
                <p className="text-xl italic text-center text-gray-900 text-bold">
                    {D.randomName()}
                </p>
                <Paragraph numberOfLines={5}>{paragraphs}</Paragraph>
                <Summary className="text-center text-gray-500">{summary}</Summary>
                <p className="text-center text-pink-400">
                    {D.randomDayMonthYear()} ({D.randomRelativeDate()})
                </p>
            </div>
        </div>
    )
}
```

## 03-3 CSS 상자 모델 이해하기
- ch03_3 프로젝트 생성

### 상자 모델이란?
- 상자모델은 HTML 태그가 웹 브라우저 화면에 모두 상자 모양으로 보이는 것을 모델링 한 것
- 이 모델에 따라 HTML 요소는 width와 height라는 스타일 속성을 가집니다.
- CSS 상자 모델 표준은 레벨 1, 2, 3이 있으며 CSS1, CSS2, CSS3등의 이름으로 레벨에 따른 CSS를 구분합니다.

### with와 height 스타일 속성
- 두 속성은 `auto`, `inherit`, `initail`, `unset` 등의 CSS 키워드값을 설정하거나
- 숫자 뒤에 픽셀을 의미하는 `px` 또는 `퍼센트`, `em`, `rem`등 단위를 붙입니다.
- 단위를 생략하면 `px` 단위로 간주합니다.

## 03-4 플렉스 레이아웃 이해하기
## daisyui CSS 컴포넌트 라이브러리 이해하기
