> 출처 : Do it 리액트 모던 웹 개발 with 타입스크립트 (저자: 전예홍)

# 4.함수 컴포넌트와 리액트 훅

## 04-1 처음 만나는 리액트 훅

- 리액트 훅과 커스텀 훅에 관헤 알아봅니다.
- 프로젝트 생성 ch04_1

### 리액트 훅이란?

- 리액트 훅은 `useState`, `useEffect`등 `use`라는 접두사가 이름에 들어가는 일련의 함수 입니다.
- 리액트 훅 함수는 반드시 함수 컴포넌트에서만 사용해야 합니다.
- 컴포넌트 데이터 관리
    * `useMemo`
    * `useCallback`
    * `useState`
    * `useReducer`
- 컴포넌트 생명 주기 대응
    * `useEffect`
    * `useLayoutEffect`
- 컴포넌트 메서드 호출
    * `useRef`
    * `useImperativeHandle`
- 컴포넌트 간의 정보 공유
    * `useContext`

#### Clock.tsx

```tsx
import type {FC} from 'react'
import {Div, Title, Subtitle} from '../components'

export type ClockProps = {
    today: Date
}

const Clock: FC<ClockProps> = ({today}) => {
    return (
        <Div className="flex flex-col items-center justify-center h-screen bg-primary text-white">
            <Title className="text-5xl">{today.toLocaleTimeString()}</Title>
            <Subtitle className="mt-4 text-2xl">{today.toLocaleDateString()}</Subtitle>
        </Div>
    )
}
export default Clock

```

### 리액트 훅의 탄생 배경

- 리액트 버전 16.8.0 이전 버전에서 사용자 컴포넌트는 클래스 기반 컴포넌트 였습니다.
- 클래스 컴포넌트는 클래스에 많은 기능이 숨어 있어 코드가 직관적이지 않습니다.
- 코드에서 생명주기메서드가 많아서 각각의 의미와 정확한 구현 방법을 알기도 어렵습니다.
- 컴포넌트에 구현한 일부 코드를 다른 컴포넌트를 구현할 때 재사용할 마땅한 방법이 없기도 합니다.
- 리액트 훅은 앞서 본 클래스 컴포넌트를 구현할 때 복잡함과 모호함을 극복할 목적으로 만들었습니다.

### 리액트 훅 코드 패턴과 의존성 목록

- 리액트 훅 함수는 여러 가지 종류가 있찌만 매개변수가 1개인 것과 2개인 것으로 나눌 수 있습니다.
- 1개
    * `useState`
    * `useRef`
    * `useImperativeHandle`
    * `useContext`
- 2개
    * `useMemo`
    * `useCallback`
    * `useReducer`
    * `useEffect`
    * `useLayoutEffect`
- 매개변수 1개인 훅 함수 코드 패턴: `훅함수<값의타입>(값)`
- null 허용 훅 함수 사용 패턴: `훅함수<값_타입 | null>(값)`
- 매개변수 2개인 훅 함수 코드 패턴: `훅함수<값의타입>(콜백함수, 의존성목록)` `useEffect(() => {}, [])`
    * 의존성 목록(dependency list)은 콜백 함수에서 사용되는 변수나 함수의 값이 일정하지 않고 수시로 변할 수 있을때, 해당 변수나 함수를 아이템으로 갖는 배열을 의미합니다.
    * 리액트 프레임워크는 의존성 목록에 있는 아이템 중 하나라도 변화가 있으면 콜백 함수를 새로 고침해 변한 값을 콜백 함수에 반영해 줍니다.

### useEffect 훅 사용하기

- useEffect는 의존성 목록에 있는 조건 중 어느 하나라도 충족되면 그 때마다 콜백 함수를 다시 실행합니다.
- 컴포넌트가 생성될 때 한번만 실행하게 하려면 의존성 목록을 `[]`로 만들면 됩니다. `useEffect(() => {}, [])`
- useEffect는 다음 처럼 함수를 반환할 수 있습니다.

```tsx
useEffect(() => {
    // 컴포넌트가 생성될 때 실행
    return () => {
    } // 컴포넌트가 소멸할 대 한 번 실행
})
```

```tsx
export default function App() {
    //const today = useClock()
    let today = useRef(new Date());
    useEffect(() => {
        console.log('useEffect called.')
        const duration = 1000;
        const id = setInterval(() => {
            today.current = new Date()
            console.log('today', today.current.toLocaleTimeString())
        }, duration)

        return () => clearInterval(id)
    }, [])

    return <Clock today={today.current}/>
}
}
```

### 인터넷 참고

- useEffect 훅이란? : 컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있도록 하는 Hook이다.
- 리액트의 useEffect 훅을 사용하면 함수 컴포넌트에서 side effect를 사용할 수 있다.
- 라이프사이클 훅을 대체할 수 있게 되었다.(componentDidMount, componentDidUpdate, componentWillUnmount...)
- 컴포넌트가 마운트 됐을 때(처음 나타났을 때), 언마운트 됐을 때(사라질 때), 그리고 업데이트 될때(특정 props가 바뀔때)

### 공식문서

- `useEffect(setup, dependencies?) `
- `setup`
    * Effect의 로직이 포함된 함수입니다. 셋업 함수는 선택적으로 클린업 함수를 반환할 수도 있습니다.
    * React는 컴포넌트가 DOM에 추가되면 셋업 함수를 실행합니다.
    * 의존성이 변경되어 다시 렌더링할 때마다 React는 (클린업 함수가 있는 경우) 먼저 이전 값으로 클린업 함수를 실행한 다음, 새 값으로 셋업 함수를 실행합니다.
    * 컴포넌트가 DOM에서 제거되면, React는 마지막으로 클린업 함수를 실행합니다.
- `dependencies`
    * setup 코드 내에서 참조된 모든 반응형 값의 목록입니다.
    * 반응형 값은 props, state, 컴포넌트 본문 내부에서 직접 선언한 모든 변수와 함수를 포함합니다.
    * React용으로 구성된 린터는 모든 반응형 값이 의존성에 잘 지정되었는지 확인합니다.
    * 의존성 목록에는 고정된 수의 항목이 있어야 하며 [dep1, dep2, dep3]과 같이 인라인으로 작성해야 합니다.
    * React는 각 의존성에 대해 Object.is로 이전 값과 비교합니다.
    * 의존성을 전혀 지정하지 않으면 컴포넌트를 다시 렌더링할 때마다 Effect가 다시 실행됩니다.
    * 의존성을 지정하면 Effect는 초기 렌더링 후 및 변경된 의존성으로 다시 렌더링한 후에 실행됩니다.
  ```ts
  useEffect(() => {
  // ...
  }, [a, b]); // Runs again if a or b are different
  ```
    * Effect가 실제로 반응형 값을 사용하지 않는 경우, 초기 렌더링 이후에만 실행됩니다.
  ```ts
  useEffect(() => {
  // ...
  }, []); // Does not run again (except once in development)
  ```
    * 의존성 배열 자체를 전달하지 않으면, 컴포넌트의 모든 렌더링(및 리렌더링) 후마다 Effect가 실행됩니다.
  ```ts
  useEffect(() => {
  // ...
  }); // Always runs again
  ```

#### 주의사항

- useEffect는 훅이므로 컴포넌트의 최상위 레벨 또는 자체 훅에서만 호출할 수 있습니다.반복문이나 조건문 내부에서는 호출할 수 없습니다.
- 필요한 경우 새 컴포넌트를 추출하고 state를 그 안으로 옮기세요.
- 외부 시스템과 동기화하려는 목적이 아니라면 Effect가 필요하지 않을지도 모릅니다.

### useRef 훅 사용하기

#### 인터넷 참고

- `const 변수명 = useRef(초기값)` 이러한 결과값으로, {current:  초기값} 을 지닌 객체가 반환된다.
- `<input ref= {변수명}/>` HTML 요소 접근
- useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다.
- 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지될 것입니다.
    * 컴포넌트가 계속해서 렌더링이 되어도 컴포넌트가 언마운드되기 전까지는 값을 그대로 유지할 수 있다
    * currnet 속성은 값을 변경해도 상태를 변경할 때 처럼 React 컴포넌트가 재렌더링 되지 않는다.
- useRef는 저장공간 또는 DOM요소에 접근하기 위해 사용되는 React Hook이다.
- 우리가 자바스크립트를 사용 할 때에는, 우리가 특정 DOM 을 선택하기 위해서 querySelector 등의 함수를 사용한다.
- React를 사용하는 프로젝트에서도 가끔씩 DOM 을 직접 선택해야 하는 상황이 필요하다. 그럴때 우리는 useRef라는 React Hook을 사용한다.
- useRef로 관리하는 값은 값이 변해도 화면이 렌더링되지 않음
- input요소에 focus를 주고 싶을때 많이 사용한다.

```tsx
const nameFocus = useRef();
nameFocus.current.focus();
//...
<input ref={nameFocus}/>
```

### useState 훅 사용하기

- useState가 반환하는 세터는 현재 값이 변경되면 자동으로 해당 컴포넌트를 다시 렌더링하는 기능이 있습니다.
- `const [현재값, 세터] = useState(초깃값)`

### 커스텀 훅이란?

- 리액트 훅은 여러 훅 함수를 조합해 마치 새로운 훅 함수가 있는 것처럼 만들 수 있는데, 이렇게 조합한 새로운 훅 함수를 **커스텀 훅** 이라고 합니다.
- 커스텀 훅은 리액트 훅뿐만 아니라 기존에 제작한 커스텀 훅 함수를 사용해서 만들 수도 있습니다.
- 커스텀 훅 함수는 '훅'이라는 의미를 강조하고자 함수 이름에 'use'라는 접두어를 붙여서 만듭니다.

#### useInterval.ts

```ts
import {useEffect} from "react";

export const useInterval = (callback: () => void, duration: number = 1000) => {
    useEffect(() => {
        const id = setInterval(callback, duration);
        return () => clearInterval(id)
    }, [callback, duration]);
}
```

#### useClock.ts

```ts
import {useState} from "react";
import {useInterval} from "./useInterval";

export const useClock = () => {
    const [today, setToday] = useState(new Date());
    useInterval(() => setToday(new Date()))
    return today;
}
```

### 리액트 훅 함수의 특징

- 같은 리액트 훅을 여러 번 호출할 수 있다.
- 함수 몸통이 아닌 몸통 안 복합 실행문의 `{}` 안에서 호출할 수 없다. (예: if문안에서, for문 안에서)
- 비동기 함수를 콜백 함수로 사용할 수 없다. `async () => // 안됨`

## 04-2 useMemo와 useCallback 훅 이해하기

- 프로젝트 생성 ch04_2

### 리액트 훅의 기본원리

#### 상태와 캐시

- 프로그래밍 분야에서 **상태(state)** 란 용어는 변수의 유효 범위와 무관하게 계속 유지하는 값을 의미합니다.
- 불변상태(immutable state): 한 번 설정되면 이후로는 값을 변경할 수 없는 '읽기 전용'
- 가변상태(mutable state): 아무때나 값을 변경할 수 있고 계속 유지
- 함수 컴포넌트는 '함수'이므로 블록 범위라는 개념 대문에 상태를 가질 수 없습니다.
- 리액트 훅은 상태를 가질 수 없는 함수 컴포넌트로 하여금 마치 상태를 가진 것처럼 동작할 수 있게 합니다.
- 이런 개념을 이용하면 캐시(cache)를 전역 변수 형태로 만들어서 구현할 수 있습니다.

#### 캐시 구현하기

#### useOrCreate.ts

```ts
const cache: Record<string, any> = {}

export const useOrCreate = <T>(key: string, callback: () => T): T => {
    if (!cache[key]) cache[key] = callback();
    return cache[key] as T
}
```

- Record 타입은 타입스크립트가 기본으로 제공하며 겍체의 속성을 '키'로, 속성값을 '값'으로 할때 `Record<키타입,값타입>` 형태로 사용하는 제네릭입니다.

#### 캐시 사용하기

#### UseOrCreateTest.tsx

```tsx
import {Title, Avatar} from '../components'
import * as D from '../data'
import {useOrCreate} from './useOrCreate'

export default function CreateOrUseTest() {
    const headTexts = useOrCreate<string[]>('headtexts', () => [
        'No.', 'Name', 'Job Title', 'Email Address'
    ]);

    const users = useOrCreate<D.IUser[]>('users', () =>
        D.makeArray(100).map(D.makeRandomUser)
    )

    const head = useOrCreate('head', () => headTexts.map(text => <th key={text}>{text}</th>))
    const body = useOrCreate('children', () =>
        users.map((user, index) => (
            <tr key={user.uuid}>
                <th>{index + 1}</th>
                <td className={"flex items-center"}>
                    <Avatar src={user.avatar} size="1.5rem"/>
                    <p className="ml-2">{user.name}</p>
                </td>
                <td>{user.jobTitle}</td>
                <td>{user.email}</td>
            </tr>
        ))
    )

    return (
        <div className="mt-4">
            <Title>CreateOrUseTest</Title>
            <div className="overflow-x-auto mt-4 p-4">
                <table className="table table-zebra table-compact w-full">
                    <thead>
                    <tr>{head}</tr>
                    </thead>
                    <tbody>{body}</tbody>
                </table>
            </div>
        </div>
    )

}
```

#### 캐시와 의존성 목록

- 리액트 훅에서는 캐시를 갱신하게 하는 요소를 **의존성(dependency)** 이라고 합니다.
- 이러한 의존성으로 구성된 배열을 **의존성 목록(dependency list)** 이라고 합니다.

#### 함수 컴포넌트와 리액트 훅을 사용하는 이유

- 함수 컴포넌트에 리액트 훅을 사용하면 리액트 프레임워크가 의존성 목록에서 변한 값이 있는지만 판단하면 되므로 다시 렌더링해야 하는 때를 판단하기가 쉽습니다.

### 데이트를 캐시하는 useMemo 훅

- react 패키지는 데이터를 캐시하는 용도로 useMemo 훅을 제공합니다.
- 과거에 계산한 값을 반복해서 사용할 때 과거에 계산한 값을 캐시해 두는 방법으로 전체 계산 속도를 높이는 코드 최적화 기법 입니다.
- `const 캐쉬된데이터 = useMemo(콜백함수, [의존성1, 의존성2,...])` `콜백함수 = () => 원본데이터`
- 선언문: `function useMemo<T>(factory: () => T, deps: DependuncyList | undefined): T`

#### Memo.tsx

```tsx
import {Title, Avatar} from '../components'
import * as D from '../data'
import {useOrCreate} from './useOrCreate'
import {useMemo} from "react";

export default function Memo() {
    const headTexts = useMemo<string[]>(() => [
        'No.', 'Name', 'Job Title', 'Email Address'
    ], []);

    const users = useMemo<D.IUser[]>(() =>
            D.makeArray(100).map(D.makeRandomUser)
        , [])

    const head = useMemo(() => headTexts.map(text => <th key={text}>{text}</th>), [headTexts])
    const body = useMemo(() =>
            users.map((user, index) => (
                <tr key={user.uuid}>
                    <th>{index + 1}</th>
                    <td className={"flex items-center"}>
                        <Avatar src={user.avatar} size="1.5rem"/>
                        <p className="ml-2">{user.name}</p>
                    </td>
                    <td>{user.jobTitle}</td>
                    <td>{user.email}</td>
                </tr>
            ))
        , [users])

    return (
        <div className="mt-4">
            <Title>CreateOrUseTest</Title>
            <div className="overflow-x-auto mt-4 p-4">
                <table className="table table-zebra table-compact w-full">
                    <thead>
                    <tr>{head}</tr>
                    </thead>
                    <tbody>{body}</tbody>
                </table>
            </div>
        </div>
    )
}
```

### 콜백 함수를 캐시하는 useCallback 훅

- useCallback 훅의 사용 개념은 useMemo와 같습니다.
- useMemo가 데이터를 캐시한다면 useCallback은 콜백 함수를 캐시한다는 차이가 있습니다.
- `const 캐시된_콜백함수 = useCallback(원본_콜백함수, 의존성목록)`
- 선언문: `function useCallback<T extends ( ...args: any[]) => any>(callback: T, deps: DependuncyList): T`
- 타입제약 T `(...arg: any[]) => any` 이는 타입 변수 T는 함수여야 함을 의미합니다.

#### callBack.tsx

```tsx
export default function Callback() {
    const onClick = useCallback(() => alert('button clicked'), [])

    const buttons = useMemo(
        () =>
            D.makeArray(3)
                .map(D.randomName)
                .map((name, index) => (
                    <Button key={index} onClick={onClick}
                            className="btn btn-primary normal-case btn-wide btn-xs">{name}</Button>
                )), [onClick]
    )

    return (
        <div className="mt-4">
            <Title>Callback</Title>
            <div className="flex justify-evenly mt-4">{buttons}</div>
        </div>
    )
}
```

#### 고차 함수 사용하기

- **고차함수(higher-order function)** 는 다른 함수를 반환하는 함수를 의미합니다.
- 리액트 개발에서 고차함수는 콜백 함수에 어떤 정보를 추가로 전달하려고 할 때 주로 사용합니다.
- ```const onClick = useCallback( (name: string) => () => alert(`${name} clicked`), [])```
- 리액트 프로그래밍에서 고차 함수를 구현하는 이ㅠ는 함수의 타입 불일치를 해결하기 위해서 입니다.
- onClick 이벤트 속성은 `() => void` 타입의 콜백 함수를 설정해야 하므로 ```() => alert(`${name} clicked`)``` 처럼 name 변수를 전달할 수 없습니다.
- 콜백 함수를 고차 함수로 구현하면 onClick이 요구하는 `() => void` 타입 함수를 반환할 수 있으면서 동시에 함수 몸통이 요구하는 name값 또한 전달할 수 있습니다.
- ```(name: string) => () => alert(`${name} clicked`)```

#### HighOrderCallback.tsx

```tsx
export default function HighOrderCallback() {
    const onClick = useCallback((name: string) => () => alert(`${name} clicked`), [])

    const buttons = useMemo(
        () =>
            D.makeArray(3)
                .map(D.randomName)
                .map((name, index) => (
                    <Button
                        key={index}
                        onClick={onClick(name)}
                        className="btn-primary normal-case btn-wide btn-xs">
                        {name}
                    </Button>
                )),
        [onClick]
    )

    return (
        <div className="mt-4">
            <Title>HighOrderCallback</Title>
            <div className="flex justify-evenly mt-4">{buttons}</div>
        </div>
    )
}
```

## 04-3 useState 훅 이해하기

- ch04_3 프로젝트 생성

### 불변 상태를 캐시하는 useState 훅

- useState 훅은 가변 상태를 캐시합니다.
- 리액트 프레임워크는 세터 함수가 호출되면 컴포넌트의 상태에 변화가 있는 것으로 판단하고 즉시 해당 컴포넌트를 다시 렌더링 합니다.
- `const [값, 값을 변경하는 세터 함수] = useState(초깃값)`
- 상태에는 타입이 있습니다. 즉, 상태는 number, boolean, string 같은 원시타입(primitive type)일 수도 있고, 객체나 배열, 튜플 타입일 수도 있습니다.
- useState 훅 선언문: `function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]`;
- `Dispatch<SetStateAction<S>>` 타입은 `setter(newValue)` 또는 `setter(previousValue => newValue)` 둘 중 하나의 함수 타입을 의미합니다.

### number 타입일 때 useState 훅 사용하기

#### count에 의존성 문제 발생

```tsx
const increment = useCallback(() => {
    setCount(count + 1) // 의존성 목록에 count 넣지 않으면 count는 항상 0이므로
}, [count])             // 의존성 목록에 count를 넣어야함
```

#### count에 의존성 문제 해결

```tsx
const increment = useCallback(() => {
    setCount(count => count + 1) // 함수를 입력 변수로 세터 호출
}, []) // 의존성 목록에 count를 넣지 않아도 됨
```

- 리액트는 세터 함수의 입력변수가 함수일 때는 현재 유지되고 있는 값을 매개변수로 하여 세터 함수를 호출합니다.

#### NumberState.tsx

```tsx
export default function NumberState() {
    const [count, setCount] = useState<number>(0)

    const increment = useCallback(() => {
        setCount(count => count + 1)
    }, [])
    const decrement = useCallback(() => {
        setCount(count => count - 1)
    }, [])

    return (
        <section className="mt-4 mb-8">
            <Title>NumberState</Title>
            <div className="flex justify-center">
                <div className="flex items-center justify-between w-1/4 mt-4 ">
                    <Icon name="add" className="btn-primary btn-lg" onClick={increment}/>
                    <p className="text-3xl text-bold text-primary">{count}</p>
                    <Icon name="remove" className="btn-accent btn-lg" onClick={decrement}/>
                </div>
            </div>
        </section>
    )
}
```

### 리액트 <Input> 컴포넌트에 훅 사용하기

- `<input>`은 boolean 타입의 checked 속성과 string이나 number 타입의 value 속성 2가지를 제공합ㄴ디ㅏ.
- 두 속성 중 값이 바뀌면 onChange 이벤트 속성에 설정한 콜백 함수를 호출합니다.

```tsx
interface InputHTMLAttributes<T> extends HTMLAttributes<T> {
    checked?: boolean | undefined;
    value?: string | ReadonlyArray<String> | number | undefined;
    onChange?: ChangeEventHandler<T> | undefined;
    // ... 생략 ...
}
```

- 리액트 방식 기본값 설정 방식

```tsx
<input type="text" defaultValue="default value"/>
<input type="checkbox" defaultValue={true}/>
```

#### InputTest.tsx

```tsx

export default function InputTest() {
    const [value, setValue] = useState<string>('')
    const [checked, setChecked] = useState<boolean>(false)

    const onChangeValue = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        //console.log(e.target.value)
        setValue(notUsed => e.target.value)
    }, [])
    const onChangeChecked = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        //console.log(e.target.checked)
        setChecked(notUsed => e.target.checked)
    }, [])
    return (
        <section className="mt-4">
            <Title>InputTest</Title>
            <div className="flex items-center justify-center p-4 mt-4">
                <Input
                    type="text"
                    value={value}
                    onChange={onChangeValue}
                    className="input-primary input-sm"
                />
                <Input
                    type="checkbox"
                    checked={checked}
                    onChange={onChangeChecked}
                    className="ml-4 checkbox checkbox-primary input-sm"
                />
            </div>
        </section>
    )
}
```

### useToggle 커스텀 훅 만들기

#### useToggle.ts

```tsx
import {useState, useCallback} from 'react'

export const useToggle = (initialChecked: boolean = false): [boolean, () => void] => {
    const [checked, setChecked] = useState<boolean>(initialChecked)
    const toggleChecked = useCallback(() => setChecked(checked => !checked), [])
    return [checked, toggleChecked]
}
```

#### ShowHideModal.tsx

```tsx
export default function ShowHideModal() {
    const [open, toggleOpen] = useToggle(false)
    const onAccept = useCallback(() => {
        toggleOpen()
        // do something
    }, [toggleOpen])

    return (
        <section className="mt-4">
            <Title>ShowHideModal</Title>
            <div className="flex justify-center p-4">
                <Button className="btn-primary" onClick={toggleOpen}>
                    open modal
                </Button>
            </div>
            <Modal open={open}>
                <ModalContent
                    closeIconClassName="btn-primary btn-outline"
                    onCloseIconClicked={toggleOpen}>
                    <Subtitle>Modal </Subtitle>
                    <p>{D.randomParagraphs()}</p>
                    <ModalAction>
                        <button className="btn btn-primary" onClick={onAccept}>
                            Accept
                        </button>
                        <button className="btn" onClick={toggleOpen}>
                            Close
                        </button>
                    </ModalAction>
                </ModalContent>
            </Modal>
        </section>
    )
}

```

### 라디오 버튼 구현 방법

#### value 속성으로 라디어 버튼 선택 로직 구현하기 RadioInputTest.tsx

```tsx
export default function RadioInputTest() {
    const jobTitles = useMemo(() => D.makeArray(4).map(D.randomJobTitle), [])
    const [selectedJobTitle, setSelectedJobTitle] = useState<string>(jobTitles[0])
    const onChange = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        setSelectedJobTitle(notUsed => e.target.value)
    }, [])
    const radioInputs = useMemo(
        () =>
            jobTitles.map((value, index) => (
                <label key={index} className="flex justify-start cursor-pointer label">
                    <input
                        type="radio"
                        name="jobs"
                        className="mr-4 radio radio-primary"
                        checked={value === selectedJobTitle}
                        defaultValue={value}
                        onChange={onChange}
                    />
                    <span className="label-text">{value}</span>
                </label>
            )),
        [jobTitles, selectedJobTitle, onChange]
    )

    return (
        <section className="mt-4">
            <Title>RadioInputTest</Title>
            <div className="flex flex-col justify-center mt-4 ">
                <Subtitle>What is your job?</Subtitle>
                <Subtitle className="mt-4">Selected Job: {selectedJobTitle}</Subtitle>
                <div className="flex justify-center p-4 mt-4">
                    <div className="flex flex-col mt-4">{radioInputs}</div>
                </div>
            </div>
        </section>
    )
}
```

#### 고차 함수로 라디오 버튼 선택 로직 구현하기 HigherOrderRadioInputTest.tsx

```tsx
export default function HigherOrderRadioInputTest() {
    const jobTitles = useMemo(() => D.makeArray(4).map(D.randomJobTitle), [])
    const [selectedIndex, setSelectedIndex] = useState<number>(0)
    const onChange = useCallback(
        (index: number) => () => setSelectedIndex(notUsed => index),
        []
    )

    const radioInputs = useMemo(
        () =>
            jobTitles.map((value, index) => (
                <label key={index} className="flex justify-start cursor-pointer label">
                    <input
                        type="radio"
                        name="higher jobs"
                        className="mr-4 radio radio-primary"
                        checked={index === selectedIndex}
                        onChange={onChange(index)}
                    />
                    <span className="label-text">{value}</span>
                </label>
            )),
        [jobTitles, selectedIndex, onChange]
    )

    return (
        <section className="mt-4">
            <Title>HigherOrderRadioInputTest</Title>
            <div className="flex flex-col justify-center mt-4 ">
                <Subtitle>What is your job?</Subtitle>
                <Subtitle className="mt-4">Selected Job: {jobTitles[selectedIndex]}</Subtitle>
                <div className="flex justify-center p-4 mt-4">
                    <div className="flex flex-col mt-4">{radioInputs}</div>
                </div>
            </div>
        </section>
    )
}
```

### HTML<form> 요소

- 리액트와 같은 SPA 방식 프런트엔드 프레임워크를 사용할 때는 백엔드 웹서버가 API 방식으로 동작하므로 굳이 `<form>`요소와 action, method, encType 등의 속성을 설정할 필요가 없습니다.
- 다만 관습적으로 사용자 입력을 받는 부분을 `<form>` 요소로 구현합니다.
- 웹 브라우저는 onSubmit 이벤트가 발생하면 `<form>`이 있는 웹페이지를 다시 랜더링함. 때문에 onSumit을 구현할 때는 반드시 e.preventDefault()를 호출해 웹페이지가 다시 랜더링되지
  않도록 해야 합니다.

```tsx
const onSumit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
}
```

### FormData 클래스

- FormData는 자바스크립트 엔진이 기본으로 제공하는 클래스로서, 사용자가 입력한 데이터들을 웹 서버에 전송할 목적으로 사용합니다.

```js
const formData = new FormData();
formData.append('name', 'Jack');
formData.append('email', 'jack@email.com')

// json 포맷으로 변환
const json = Object.fromEntries(formData);
```

#### BasicForm.tsx

```tsx
export default function BasicForm() {
    const [name, setName] = useState<string>('')
    const [email, setEmail] = useState<string>('')

    const onSubmit = useCallback(
        (e: FormEvent<HTMLFormElement>) => {
            e.preventDefault() // 매우 중요합니다

            const formData = new FormData()
            formData.append('name', name)
            formData.append('email', email)
            alert(JSON.stringify(Object.fromEntries(formData), null, 2))
        },
        [name, email]
    )

    const onChangeName = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        setName(notUsed => e.target.value)
    }, [])
    const onChangeEmail = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        setEmail(notUsed => e.target.value)
    }, [])

    // prettier-ignore
    return (
        <section className="mt-4">
            <Title>BasicForm</Title>
            <div className="flex justify-center mt-4">
                <form onSubmit={onSubmit}>
                    <div className="form-control">
                        <label className="label" htmlFor="name">
                            <span className="label-text">Username</span>
                        </label>
                        <input value={name} onChange={onChangeName} id="name" type="text"
                               placeholder="enter your name" className="input input-primary"/>
                    </div>
                    <div className="form-control">
                        <label className="label" htmlFor="email">
                            <span className="label-text">email</span>
                        </label>
                        <input value={email} onChange={onChangeEmail} id="email" type="email"
                               placeholder="enter your email" className="input input-primary"/>
                    </div>
                    <div className="flex justify-center mt-4">
                        <input type="submit" value="Submit"
                               className="w-1/2 btn btn-sm btn-primary"/>
                        <input defaultValue="Cancel" className="w-1/2 ml-4 btn btn-sm"/>
                    </div>
                </form>
            </div>
        </section>
    )
}
```

### 객체 타입 값일 때 useState 훅 사용하기

#### 객체를 상태로 만들기

```tsx
type FormType = {
    name: string
    email: string
}

const [form, setFrom] = useState<FormType>({name: '', email: ''})
```

#### 깊은 복사와 얕은 복사, 그리고 의존성 목록

- 객체, 배열 등 값의 메모리 크기를 런타임 때 알 수 없는 타입은 얕은 복사가 일어납니다.
- 한가지 예외 상황은 string타입 문자열인데, 타입스크립트에서 문자열은 항상 읽기 전용이므로 메모리 크기를 컴파일 타임 때 알 수 있습니다. 따라서 문자열은 깊은 복사가 일어납니다.
- 복사방식 비교

```tsx
const onChaneName = useCallback((e: ChangeEvent<HTMLInputElement>) => {
    const newForm = form // 얕은 복사
    // const newForm = Object.assign({}, form) // 깊은 복사

    newForm.name = e.target.value
    setForm(newForm)
}, [form]) 
```

- 리액트 프레임워크는 내부적으로 form 상태에 변화가 생겼는지를 `form == newForm` 형태로 비교합니다.
- 객채 타입의 복사는 항상 얕은 복사이므로 이 비굣값은 항상 true입니다. 변화가 없다고 간주하고 웹 페이지를 다시 렌더링하지 않으므로 input에 값을 입력해도 form에 반영되지 않습니다.

#### 객체에 적용하는 타입스크립트 전개 연산자 구문

```tsx
const onChaneName = useCallback((e: ChangeEvent<HTMLInputElement>) => {
    // 깊은 복사와 name 속성값 변경이 동시에 일어남
    const newForm = {...form, name: e.target.value}
    setForm(newForm)
}, [form])
```

#### 타입스크립트 객체 반환 구문

```tsx
const onChaneName = useCallback((e: ChangeEvent<HTMLInputElement>) => {
    setForm(form => ({...form, name: e.target.value}))
}, [])
```

#### ObjectState.tsx 파일 구현하기

```tsx
type FormType = {
    name: string
    email: string
}

export default function ObjectState() {
    const [form, setForm] = useState<FormType>({name: '', email: ''})

    const onSubmit = useCallback(
        (e: FormEvent<HTMLFormElement>) => {
            e.preventDefault() // 매우 중요합니다

            alert(JSON.stringify(form, null, 2))
        },
        [form]
    )

    const onChangeName = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        setForm(state => ({...state, name: e.target.value}))
    }, [])
    const onChangeEmail = useCallback((e: ChangeEvent<HTMLInputElement>) => {
        setForm(form => ({...form, email: e.target.value}))
    }, [])

    // prettier-ignore
    return (
        <section className="mt-4">
            <Title>ObjectState</Title>
            <div className="flex justify-center mt-4">
                <form onSubmit={onSubmit}>
                    <div className="form-control">
                        <label className="label" htmlFor="name">
                            <span className="label-text">Username</span>
                        </label>
                        <input value={form.name} onChange={onChangeName} id="name"
                               type="text" placeholder="enter your name"
                               className="input input-primary"/>
                    </div>
                    <div className="form-control">
                        <label className="label" htmlFor="email">
                            <span className="label-text">email</span>
                        </label>
                        <input value={form.email} onChange={onChangeEmail} id="email"
                               type="email" placeholder="enter your email"
                               className="input input-primary"/>
                    </div>
                    <div className="flex justify-center mt-4">
                        <input type="submit" value="Submit"
                               className="w-1/2 btn btn-sm btn-primary"/>
                        <input defaultValue="Cancel" className="w-1/2 ml-4 btn btn-sm"/>
                    </div>
                </form>
            </div>
        </section>
    )
}
```

### 배열 타입 값일 때 useState 훅 사용하기

- `const [images, setImages] = useState<string[]>([])`

#### ArrayState 컴포넌트 만들기

```tsx
export default function ArrayState() {
    const [images, setImages] = useState<string[]>([])
    const addImage = useCallback(
        () => setImages(images => [D.randomImage(200, 100, 50), ...images]),
        []
    )
    const clearImages = useCallback(() => setImages(notUsed => []), [])
    const children = useMemo(
        () =>
            images.map((image, index) => (
                <Div
                    key={index}
                    src={image}
                    className="w-1/5 m-2"
                    height="5rem"
                    minHeight="5rem"
                />
            )),
        [images]
    )
    return (
        <section className="mt-4">
            <Title>ArrayState</Title>
            <div className="flex justify-center mt-4 ">
                <div data-tip="add cards" className="tooltip">
                    <Icon name="add" onClick={addImage} className="mr-12 btn-primary"/>
                </div>
                <div data-tip="clear all" className="tooltip">
                    <Icon name="clear_all" onClick={clearImages}/>
                </div>
            </div>
            <div className="flex flex-wrap mt-4">{children}</div>
        </section>
    )
}
```

## 04-4 useEffect와 useLayoutEffect 훅 이해하기

- ch04_4 프로젝트 생성

### 컴포넌트의 생명 주기란?

- 리액트 프레임워크는 컴포넌트를 생성하고 렌더링하다가 어떤 시점이 되면 소멸합니다. 이러한 과정을 컴포넌트의 생명주기라고 표현합니다.

### 클래스 컴포넌트에서 상태 구현하기

#### 컴포넌트 마운트

- 리액트 컴포넌트는 가상 DOM 객체 형태로 생성되어 어떤 시점에 물리 DOM 트리의 멤버 객체가 되며, 이과정에서 처음 렌더링이 일어나는데
  이 시점을 컴포넌트가 마운트 되었다고 표현합니다.
- 즉, 가상 DOM 객체가 물리 DOM 객체로 바뀌는 시점을 마운트 되었다고 표현합니다.
- 리액트 클래스 컴포넌트가 `componentDidMount()`라는 메서드를 가지면 마운트되는 시점에 이 메서드를 호출해 줍니다.

#### 클래스 컴포넌트의 언마운트

- 컴포넌트가 생성되고 마운트되어 웹페이지에 나타난 후 어떤 시점이 되면 컴포넌트는 소멸합니다.
- 리액트에서는 컴포넌트가 물리 DOM 객체로 있다가 소멸하는 것을 언마운트(unmount) 되었다고 표현합니다.
- 리액트는 클래스 컴포넌트가 `componentWillUnmount()` 메서드를 구현하고 있으면 언마운트가 일어나기 직전에 이 메서드를 호출해 줍니다.

### useLayoutEffect와 useEffect 훅 알아보기

- 두 훅은 사용법이 같으며 콜백 함수는 훅이 실행될 때 처음 한 번은 반드시 실행됩니다.
- 이런 특징 대문에 의존성 목록이 빈 배열`[]`일지라도 한 번은 콜백 함수를 호출합니다.
- 이런 설계는 클래스 컴포넌트의 `componentDidMount()` 메서드를 구현한 것과 사실상 같은 효과를 보입니다.
- 두 훅이 `componentDidMount()`와 다른 점은 단 한 번만 실행되는 `componentDidMount()`와 달리, 두 훅의 의존성 목록이 변경될 때 마다 콜백함수를 계속
  실행한다는 점입니다.

```tsx
useEffect(콜백함수, 의존성목록);
useLayoutEffect(콜백함수, 의존성목록);

콜백함수 = () => {
    return 반환함수 // 언마운트될 때 한번만 호출
}
```

- 두 훅의 콜백함수는 함수를 반환할 수도 있는데, 이때 반환 함수는 컴포넌트가 언마운트 될 때 한번만 호출됩니다.

#### useLayoutEffect와 useEffect 훅의 차이점

- 리액트 프레임워크는 useLayoutEffect 훅은 동기로 실행하고, useEffect 훅은 비동기로 실행합니다.
- useLayoutEffect 훅은 콜백 함수가 끝날 때까지 프레임워크가 기다린다는 의미.
- 리액트 공식 문서에서는 될 수 있으면 useEffect 훅을 사용하고 useEffect 훅으로 구현이 안될때만 useLayoutEffect 훅을 사용하라고 권합니다.

#### useInterval 커스텀 훅 고찰해보기

```tsx
export const useInterval = (callback: () => void, duration: number = 1000) => {
    useEffect(() => {
        const id = setInterval(callback, duration)
        return () => clearInterval(id);
    }, [callback, duration])
}
```

- 의존성 목록이 빈 배열`[]`은 아니지만, callback과 duration 의존성을 사실상 변하지 않습니다.

#### useEventListener 커스텀 훅 만들기

- setInterval처럼 `addEventListener()` 메서드를 호출하면 반드시 `removeEventListener()` 메서드를 호출해 주어야 메모리 누수가 발생하지 않습니다.

#### useEventListener.ts

```ts
export const useEventListener = (
    target: EventTarget | null,
    type: string,
    callback: EventListenerOrEventListenerObject | null
) => {
    useEffect(() => {
        if (target && callback) {
            target.addEventListener(type, callback)
            return () => target.removeEventListener(type, callback)
        }
    }, [target, type, callback])
}
```

#### useWindowResize 커스텀 훅 만들기

- 웹페이지의 크기는 window 객체의 innerWidth, innerHeight 속성값으로 알 수 있습니다.
- 그리고 이벤트 타입을 resize로 하면 웹 페이지의 크기가 변경되는 것을 탐지할 수 있습니다.

#### useWindowResize.ts

```ts
import {useEventListener} from "./useEventListener";

export const useWindowResize = () => {
    const [widthHeight, setWidthHeight] = useState<number[]>([0, 0])

    useEffect(() => {
        setWidthHeight(notUsed => [window.innerWidth, window.innerHeight])
    }, []); // 컴포넌트가 마운트될 때 창 크기 결정

    useEventListener(window, 'resize', () => {
        setWidthHeight(notUsed => [window.innerWidth, window.innerHeight])
    }); // 창 크기가 변경될 때마다 설정

    return widthHeight
}
```

#### `fetch()` 함수와 `Promise` 클래스 고찰해 보기

- `fetch()`는 HTTP 프로토콜의 GET, POST, PUT, DELETE와 같은 HTTP 메서드를 프로그래밍으로 쉽게 사용하게 헤줍니다.
- Promise 클래스는 비동기 콜백 함수를 쉽게 구현하려고 만든 것으로, `then()`, `catch()`, `finally()` 메서드를 제공합니다.

```js
fetch('https://randomuse.me/api/')
    .then(res => res.json())
    .then((data: unknown) => console.log(data))
    .catch((err: Error) => console.log(err.message))
    .finally(() => console.log("always called"))
```

##### fetchRandomUser.ts

```ts
export type IRandomUser = {
    email: string
    name: { title: string; first: string; last: string }
    picture: { large: string }
}
const convertRandomUser = (result: unknown) => {
    const {email, name, picture} = result as IRandomUser
    return {email, name, picture}
}
export const fetchRandomUser = (): Promise<IRandomUser> =>
    new Promise((resolve, reject) => {
        fetch('https://randomuser.me/api/')
            .then(res => res.json())
            .then((data: unknown) => {
                console.log(data) // convertRandomUser를 구현하고자 할 때 사용합니다
                const {results} = data as { results: IRandomUser[] }
                resolve(convertRandomUser(results[0]))
            })
            .catch(reject)
    })
```

#### API 서버에서 가져온 사용자 정보 화면에 표시하기

#### FetchTest.tsx

```tsx
export default function FetchTest() {
    const [loading, toggleLoading] = useToggle()
    const [randomUser, setRandomUser] = useState<D.IRandomUser | null>(null)
    const [error, setError] = useState<Error | null>(null)

    const getRandomUser = useCallback(() => {
        toggleLoading()
        D.fetchRandomUser().then(setRandomUser).catch(setError).finally(toggleLoading)
    }, [toggleLoading])
    useEffect(getRandomUser, [getRandomUser])

    return (
        <section className="mt-4">
            <Title>FetchTest</Title>
            <div className="flex justify-center mt-4">
                <button className="btn btn-sm btn-primary" onClick={getRandomUser}>
                    <Icon name="get_app"/>
                    <span>get random user</span>
                </button>
            </div>
            {loading && (
                <div className="flex items-center justify-center">
                    <button className="btn btn-circle loading"></button>
                </div>
            )}
            {error && (
                <div className="p-4 mt-4 bg-red-200">
                    <p className="text-3xl text-red-500 text-bold">{error.message}</p>
                </div>
            )}
            {randomUser && (
                <div className="flex justify-center p-4 mt-4">
                    <Avatar src={randomUser.picture.large}/>
                    <div className="ml-4">
                        <p className="text-xl text-bold">
                            {randomUser.name.title}. {randomUser.name.first} {randomUser.name.last}
                        </p>
                        <p className="italic text-gray-600">{randomUser?.email}</p>
                    </div>
                </div>
            )}
        </section>
    )
}
```

## 04-5 useRef와 useImperativeHandle 훅 이해하기

- `useRef`와 `useImperativeHandle`은 `ref`라는 속성에 적용하는 값을 만들어 주는 훅입니다.
- 사실 리액트와 리액트 네이티브가 제공하는 컴포넌트는 모두 `ref`라는 이름의 속성을 가지고 있습니다.
- 이절에서는 `ref` 속성과 관련된 `useRef`와 `useImperativeHandle` 훅 그리고 `forwardRef()` 함수에 관해 알아봅니다.
- 프로젝트 생성: ch04_5

### ref 속성이란?

- 모든 리액트 컴포넌트는 reference의 앞 3글자를 단 ref속성을 제공합니다.
- 그런데 ref 속성값은 사용자 코드에서 설정하는 것이 아니라 어떤 시점에 리액트 프레임워크 내부에서 설정해 줍니다.
- ref 속성은 초기에는 null 이었다가 마운트되는 시점에서 물리 DOM 객체의 값이 됩니다. 즉, ref는 물리 DOM 객체의 참조입니다.
- ref 속성값은 물리 DOM 상태의 값이므로 ref로 얻은 값(즉, DOM 객체)을 사용해 click()과 같은 메서드를 호출할 수 있습니다.

### useRef 훅 알아보기

```tsx
const divRef = useRef < HTMLDivElement | null
)
(null)
// ...
< div
ref = {divRef} >
```

#### `<input>`의 클릭 메서드 호출하기

- `useRef` 훅 호출로 얻는 `inputRef`의 `current` 속성은 그 값이 변해도 다시 렌더링되지 않도록 설계되었습니다. 이처럼 리렌더링이 필요 없을 때는 의존성 목록에 포함하지 않습니다.

#### ClickTest.tsx

```tsx
import {useRef, useCallback} from 'react'
import {Title} from '../components'

export default function ClickTest() {
    const inputRef = useRef<HTMLInputElement>(null)
    const onClick = useCallback(() => inputRef.current?.click(), [])

    return (
        <section className="mt-4">
            <Title>ClickTest</Title>
            <div className="mt-4 flex justify-center items-center">
                <button className="btn btn-primary mr-4" onClick={onClick}>
                    Click Me
                </button>
                <input ref={inputRef} className="hidden" type="file" accept="image/*"/>
            </div>
        </section>
    )
}
```

#### FileList 클래스와 Array.from() 함수

- FileList는 File타입의 리스트 입니다. FileList는 자바스크립트 배열이 아닙니다.
- 자바스크립트에서는 FileList와 같은 클래스들을 유사배열객체 라고 부릅니다.
- 자바스크립트에서 유사 배열 객체는 다음처럼 Array.from() 함수를 사용해 배열로 변환할 수 있습니다.
- `const fileArray: File[] = Array.from(files)`

#### FileReader 클래스로 File 타입 객체 읽기

- 자바스크립트 엔진은 File 타입 객체를 읽을 수 있도록 FileReader라는 클래스를 기본으로 제공합니다.
- FileReader 클래스는 `readAsDataUrl()` 메서드를 제공하는데 이 메서드는 File타입 객체를 읽어서 문자열로된 이미지를 재공하는데 이를 base64인코딩이라고 합니다.

```tsx
const fileReader = new FileReader();
fileReader.onload = (e: ProgressEvent<FileReader>) => {
    if (e.target) {
        const result = e.target.result // base64 인코딩 결과
    }
}
fileReader.readAsDataURL(file);
```

- load 이벤트의 핸들러. 이 이벤트는 읽기 동작이 성공적으로 완료되었을 때마다 발생한다.

#### imageFileReaderP 유틸리티 함수 만들기 imageFileReaderP.ts

```ts
export const imageFileReaderP = (file: Blob) =>
    new Promise<string>((resolve, reject) => {
        const fileReader = new FileReader()
        fileReader.onload = (e: ProgressEvent<FileReader>) => {
            const result = e.target?.result

            if (result && typeof result === 'string') resolve(result)
            else reject(new Error(`imageFileReaderP: can't read image file`))
        }

        fileReader.readAsDataURL(file)
    })
```

#### FileDrop 컴포넌트 만들기 FileDrop.tsx

```tsx
import type {ChangeEvent, DragEvent} from 'react'
import {useState, useRef, useCallback, useMemo} from 'react'
import {useToggle} from '../hooks'
import {Title, Div} from '../components'
import {imageFileReaderP} from '../utils'

export default function FileDrop() {
    const [imageUrls, setImageUrls] = useState<string[]>([])
    const [error, setError] = useState<Error | null>(null)
    const [loading, toggleLoading] = useToggle(false)

    const inputRef = useRef<HTMLInputElement>(null)
    const onDivClick = useCallback(() => inputRef.current?.click(), [])

    const makeImageUrls = useCallback(
        (files: File[]) => {
            const promises = Array.from(files).map(imageFileReaderP)
            toggleLoading()
            Promise.all(promises)
                .then(urls => setImageUrls(imageUrls => [...urls, ...imageUrls]))
                .catch(setError)
                .finally(toggleLoading)
        },
        [toggleLoading]
    )

    const onInputChange = useCallback(
        (e: ChangeEvent<HTMLInputElement>) => {
            setError(null)
            const files = e.target.files
            files && makeImageUrls(Array.from(files))
        },
        [makeImageUrls]
    )

    const onDivDragOver = useCallback((e: DragEvent) => e.preventDefault(), [])
    const onDivDrop = useCallback(
        (e: DragEvent) => {
            e.preventDefault()
            setError(null)
            const files = e.dataTransfer?.files
            files && makeImageUrls(Array.from(files))
        },
        [makeImageUrls]
    )

    // prettier-ignore
    const images = useMemo(() =>
        imageUrls.map((url, index) => (
            <Div key={index} src={url}
                 className="m-2 bg-transparent bg-center bg-no-repeat bg-contain"
                 width="5rem" height="5rem"/>
        )), [imageUrls])

    // prettier-ignore
    return (
        <section className="mt-4">
            <Title>FileDrop</Title>
            {error && (
                <div className="p-4 mt-4 bg-red-200">
                    <p className="text-3xl text-red-500 text-bold">{error.message}</p>
                </div>
            )}

            <div onClick={onDivClick}
                 className="w-full mt-4 bg-gray-200 border border-gray-500">
                {loading && (
                    <div className="flex items-center justify-center">
                        <button className="btn btn-circle loading"></button>
                    </div>
                )}

                <div onDragOver={onDivDragOver} onDrop={onDivDrop}
                     className="flex flex-col items-center justify-center h-40 cursor-pointer">
                    <p className="text-3xl font-bold">drop images or click me</p>
                </div>
                <input ref={inputRef} onChange={onInputChange}
                       multiple className="hidden" type="file" accept="image/*"/>
            </div>

            <div className="flex flex-wrap justify-center">{images}</div>
        </section>
    )
}
```

#### `<input>` 요소의 ref 속성 사용하기

- 포커싱: `useEffect(() => inputRef.current?.focus(), [])`

#### useState 호출 없이 <input>의 value 속성값 얻기

```tsx
export default function InputValueTest() {
    const inputRef = useRef<HTMLInputElement>(null)

    const getValue = useCallback(() => alert(`input value: ${inputRef.current?.value}`), [])

    // prettier-ignore
    return (
        <section className="mt-4">
            <Title>InputValueTest</Title>
            <div className="flex justify-center mt-4 ">
                <div className="flex flex-col w-1/3 p-2">
                    <input ref={inputRef} className="input input-primary"/>
                    <button onClick={getValue} className="mt-4 btn btn-primary">
                        get value
                    </button>
                </div>
            </div>
        </section>
    )
}
```

### forwardRef 함수 이해하기

- forwardRef 함수는 이름대로 부모 컴포넌트에서 생성한 ref를 자식 컴포넌트로 전달해주는 역할을 합니다.

```tsx
// prettier-ignore
export type ReactInputProps = DetailedHTMLProps<
    InputHTMLAttributes<HTMLInputElement>,
    HTMLInputElement>

export type InputProps = ReactInputProps & {}

export const Input = forwardRef<HTMLInputElement, InputProps>((props, ref) => {
    const {className: _className, ...inputProps} = props
    const className = ['input', _className].join(' ')
    return <input ref={ref} {...inputProps} className={className}/>
})
```

### useImperativeHandle 훅이란?

- `useImperativeHandle` 훅은 컴포넌트 기능을 JSX가 아니라 타입스크립트 코드에서 사용합니다.

#### useImperativeHandle 훅의 타입

- `useMemo` 훅과 `useImperativeHandle` 훅 코드의 사용법이 유사

```tsx
const object = useMemo(() => ({}), [])
const handle = useImperativeHandler(ref, () => ({}), [])
```

- 첫번째 매개변수 `ref`는 forwardRef 함수를 호출해 얻는 ref를 사용해야 합니다.
- `useImperativeHandle` 훅은 다른 훅과 달리 앞서만든 Input과 같은 컴포넌트 내부에서만 사용해야 한다는 것을 의미합니다.

#### ValidatableInput.tsx

```tsx

export type ValidatableInputMethods = {
    validate: () => [boolean, string]
}

export const ValidatableInput = forwardRef<ValidatableInputMethods, ReactInputProps>(
    ({type, className: _className, ...inputProps}, methodsRef) => {
        const className = useMemo(() => ['input', _className].join(' '), [_className])
        const inputRef = useRef<HTMLInputElement>(null)

        useImperativeHandle(
            methodsRef,
            () => ({
                validate: (): [boolean, string] => {
                    const value = inputRef.current?.value
                    if (!value || !value.length) return [false, '사용자가 입력한 내용이 없습니다']

                    switch (type) {
                        case 'email': {
                            const regEx =
                                /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i
                            const valid = regEx.test(value)
                            return valid ? [true, value] : [false, '틀린 이메일 주소입니다']
                        }
                    }
                    return [true, value]
                }
            }),
            [type]
        )

        return <input {...inputProps} className={className} ref={inputRef}/>
    }
)

```

#### ValidatableInputTest.tsx

```tsx
export default function ValidatableInputTest() {
    const methodsRef = useRef<ValidatableInputMethods>(null)

    const validateEmail = useCallback(() => {
        if (methodsRef.current) {
            const [valid, valueOrErrorMessage] = methodsRef.current.validate()
            if (valid) alert(`${valueOrErrorMessage}는 유효한 이메일 주소입니다.`)
            else alert(valueOrErrorMessage)
        }
    }, [])

    // prettier-ignore
    return (
        <section className="mt-4">
            <Title>ValidatableInputTest</Title>
            <div className="flex justify-center mt-4 ">
                <div className="flex flex-col w-1/3 p-2">
                    <ValidatableInput type="email" ref={methodsRef} className="input-primary"/>
                    <button onClick={validateEmail} className="mt-4 btn btn-primary">
                        validate
                    </button>
                </div>
            </div>
        </section>
    )
}
```

## 04-6 useContext 훅 이해하기

- 컨텍스트는 리액트가 제공하는 가장 막강한 기능으로 리액트 라우터, 리덕스 등 많은 라이브러리 설계의 근간이 되었습니다.
- 프로젝트 생성 ch04_6

### 컨텍스트(Context)란?

- 컨텍스트의 속성은 부모 컴포넌트가 자식 컴포넌트로 어떤 정보를 전달하려고 할 때 사용하는 매커니즘 입니다.
- 그런데 부모 컴포넌트가 직계 자식이 아닌, 손자나 증손자 컴포넌트에 정보를 전달하려고 하면 번거로운 속성 전달을 해야합니다.
- 리액트는 이런 속성 전달의 번거로움을 해소하고자 컨텍스트 라는 매커니즘을 구현해 놓았습니다.
- 리액트나 리액트 네이티브에서 컨텍스트는 createContext와 useContext 훅으로 이뤄집니다.
    * 부모컴포넌트 `createContext` : 공유할 정보 설정
    * 자식(자식,손자,증손자..) 컴포넌트: `useContext` 공유정보 취득

### createContext 함구 탐구

```ts
type ContextType = {
    // 공유할 데이터 속성   
}

const defaultContextValue: ContextType = {
    // 공유할 데이터 속성 초깃값
}

const SomeContext = createContext<ContextType>(defaultContextValue)
```

### 테일윈드 CSS 중단점 접두사 이애하기

- 테일윈드 CSS뿐만 아니라 부트스트랩 등 대다수 CSS 프레임워크는 sm, md, lg, xl등을 사용해 웹 화면 크기를 표현합니다.
- 즉, 다음 표에서 보는 키워드들은 CSS 프레임워크가 제공하는 반응형 디자인 기능을 사용할 때 씁니다.

| 키워드 | 의미            | 최소 크기  | CSS @media 규칙             |
|-----|---------------|--------|---------------------------|
| sm  | small         | 640px  | @media(min-width: 640px)  |
| md  | medium        | 768px  | @media(min-width: 768px)  |
| lg  | large         | 1024px | @media(min-width: 1024px) |
| xl  | extra large   | 1280px | @media(min-width: 1280px) |
| 2xl | 2 extra large | 1536px | @media(min-width: 1536px) |
- 예를 들어 다음 `<img>` 요소의 className에 설정된 클래스의 의미를 살펴보면
  * 보통: 4rem (w-16) 
  * 웹브라우저폭이 768px보다 클 때: 8rem(md:w-32)
  * 웹브라우저폭이 1024px보다 클 때: 12rem(md:w-48)
- 여기서 콜론(:) 앞의 md 등을 중단점이라고 하고, 중단점에 콜론 기호를 붙인 `md:`을 중단점 접두사라고 합니다.
- `<img className="w-16 md:w-32 lg:w-48"/>`
   
### 반응형 컨텍스트 만들기
#### ResponsiveContext.tsx
```tsx
import {createContext} from 'react'

type ContextType = {
    breakpoint: string // 공유할 데이터 속성
}

const defaultContextValue: ContextType = {
    breakpoint: '' // 공유할 데이트 속성 초기값
}

export const ResponsiveContext = createContext<ContextType>(defaultContextValue)
```

#### 컨텍스트가 제공하는 Provider 컴포넌트
- createContext 함수로 호출로 생성된 컨텍스트 객체는 Provider와 Consumer라는 컴포넌트를 제공합니다.
- Provider는 컨텍스트의 기능을 제공할 컴포넌트이고, Consumer는 Provider가 제공한 기능을 사용하고 싶은 클래스 컴포넌트 입니다.
- 컴포넌트를 함수 형태로 구현하므로 Consumer는 무시해도 됩니다. useContext 훅을 사용하면 되기 때문

### useContext 훅 알아보기
- 컨택스트 객채가 재공하는 Provider 컴포넌트의 value 속성값을 얻을 수 있게 하는 목적으로 사용되는 훅 입니다.

#### ResponsiveContext.tsx
```tsx
import type {FC, PropsWithChildren} from 'react'
import {createContext, useContext} from 'react'
import {useWindowResize} from '../hooks'

type ContextType = {
    breakpoint: string // 공유 시키려는 데이터 속성
}
const defaultContextValue: ContextType = {
    breakpoint: '' // 공유 시키려는 데이터 속성 초기값
}
export const ResponsiveContext = createContext<ContextType>(defaultContextValue)

type ResponsiveProviderProps = {}
export const ResponsiveProvider: FC<PropsWithChildren<ResponsiveProviderProps>> = ({
                                                                                       children,
                                                                                       ...props
                                                                                   }) => {
    const [width] = useWindowResize()
    // prettier-ignore
    const breakpoint = width < 640 ? 'sm' :
            width < 768 ? 'md' :
            width < 1024 ? 'lg' :
            width < 1280 ? 'xl' : '2xl'

    const value = {
        breakpoint // breakpoint: breakpoint를 간결하게 구현한 것입니다.
    }
    return <ResponsiveContext.Provider value={value} children={children}/>
}

export const useResponsive = () => {
    const {breakpoint} = useContext(ResponsiveContext)
    return breakpoint
}
```

#### ResponsiveContextTest.tsx
```tsx
import {Title, Subtitle} from '../components'
import {useResponsive} from '../contexts'

export default function ResponsiveContextTest() {
  const breakpoint = useResponsive()
  return (
    <section className="mt-4">
      <Title>ResponsiveContextTest</Title>
      <div className="mt-4">
        <Subtitle>breakpoint: {breakpoint}</Subtitle>
      </div>
    </section>
  )
}

```
