> 출처 : Do it 리액트 모던 웹 개발 with 타입스크립트 (저자: 전예홍)

# 4.함수 컴포넌트와 리액트 훅
## 04-1 처음 만나는 리액트 훅
- 리액트 훅과 커스텀 훅에 관헤 알아봅니다.
- 프로젝트 생성 ch04_1

### 리액트 훅이란?
- 리액트 훅은 `useState`, `useEffect`등 `use`라는 접두사가 이름에 들어가는 일련의 함수 입니다.
- 리액트 훅 함수는 반드시 함수 컴포넌트에서만 사용해야 합니다.
- 컴포넌트 데이터 관리
  * `useMemo`
  * `useCallback`
  * `useState`
  * `useReducer`
- 컴포넌트 생명 주기 대응
  * `useEffect`
  * `useLayoutEffect`
- 컴포넌트 메서드 호출
  * `useRef`
  * `useImperativeHandle`
- 컴포넌트 간의 정보 공유
  * `useContext`

#### Clock.tsx
```tsx
import type {FC} from 'react'
import {Div, Title, Subtitle} from '../components'

export type ClockProps = {
  today: Date
}

const Clock: FC<ClockProps> = ({today}) => {
  return (
    <Div className="flex flex-col items-center justify-center h-screen bg-primary text-white">
      <Title className="text-5xl">{today.toLocaleTimeString()}</Title>
      <Subtitle className="mt-4 text-2xl">{today.toLocaleDateString()}</Subtitle>
    </Div>
  )
}
export default Clock

```

### 리액트 훅의 탄생 배경
- 리액트 버전 16.8.0 이전 버전에서 사용자 컴포넌트는 클래스 기반 컴포넌트 였습니다.
- 클래스 컴포넌트는 클래스에 많은 기능이 숨어 있어 코드가 직관적이지 않습니다.
- 코드에서 생명주기메서드가 많아서 각각의 의미와 정확한 구현 방법을 알기도 어렵습니다.
- 컴포넌트에 구현한 일부 코드를 다른 컴포넌트를 구현할 때 재사용할 마땅한 방법이 없기도 합니다.
- 리액트 훅은 앞서 본 클래스 컴포넌트를 구현할 때 복잡함과 모호함을 극복할 목적으로 만들었습니다.

### 리액트 훅 코드 패턴과 의존성 목록
- 리액트 훅 함수는 여러 가지 종류가 있찌만 매개변수가 1개인 것과 2개인 것으로 나눌 수 있습니다.
- 1개
  * `useState`
  * `useRef`
  * `useImperativeHandle`
  * `useContext`
- 2개
  * `useMemo`
  * `useCallback`
  * `useReducer`
  * `useEffect`
  * `useLayoutEffect`
- 매개변수 1개인 훅 함수 코드 패턴: `훅함수<값의타입>(값)`
- null 허용 훅 함수 사용 패턴: `훅함수<값_타입 | null>(값)`
- 매개변수 2개인 훅 함수 코드 패턴: `훅함수<값의타입>(콜백함수, 의존성목록)` `useEffect(() => {}, [])`
  * 의존성 목록(dependency list)은 콜백 함수에서 사용되는 변수나 함수의 값이 일정하지 않고 수시로 변할 수 있을때, 해당 변수나 함수를 아이템으로 갖는 배열을 의미합니다.
  * 리액트 프레임워크는 의존성 목록에 있는 아이템 중 하나라도 변화가 있으면 콜백 함수를 새로 고침해 변한 값을 콜백 함수에 반영해 줍니다.

### useEffect 훅 사용하기
- useEffect는 의존성 목록에 있는 조건 중 어느 하나라도 충족되면 그 때마다 콜백 함수를 다시 실행합니다.
- 컴포넌트가 생성될 때 한번만 실행하게 하려면 의존성 목록을 `[]`로 만들면 됩니다. `useEffect(() => {}, [])`
- useEffect는 다음 처럼 함수를 반환할 수 있습니다.
```tsx
useEffect( () => {
    // 컴포넌트가 생성될 때 실행
    return () => {} // 컴포넌트가 소멸할 대 한 번 실행
})
```
```tsx
export default function App() {
  //const today = useClock()
  let today = useRef(new Date());
  useEffect(() => {
    console.log('useEffect called.')
    const duration = 1000;
    const id = setInterval(() => {
      today.current = new Date()
      console.log('today', today.current.toLocaleTimeString())
    }, duration)

    return () => clearInterval(id)
  }, [])
  
  return <Clock today={today.current} />
}
}
```

### 인터넷 참고 
- useEffect 훅이란? : 컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있도록 하는 Hook이다.
- 리액트의 useEffect 훅을 사용하면 함수 컴포넌트에서 side effect를 사용할 수 있다.
- 라이프사이클 훅을 대체할 수 있게 되었다.(componentDidMount, componentDidUpdate, componentWillUnmount...)
- 컴포넌트가 마운트 됐을 때(처음 나타났을 때), 언마운트 됐을 때(사라질 때), 그리고 업데이트 될때(특정 props가 바뀔때)

### 공식문서
- `useEffect(setup, dependencies?) `
- `setup`
  * Effect의 로직이 포함된 함수입니다. 셋업 함수는 선택적으로 클린업 함수를 반환할 수도 있습니다. 
  * React는 컴포넌트가 DOM에 추가되면 셋업 함수를 실행합니다. 
  * 의존성이 변경되어 다시 렌더링할 때마다 React는 (클린업 함수가 있는 경우) 먼저 이전 값으로 클린업 함수를 실행한 다음, 새 값으로 셋업 함수를 실행합니다. 
  * 컴포넌트가 DOM에서 제거되면, React는 마지막으로 클린업 함수를 실행합니다.
- `dependencies`
  * setup 코드 내에서 참조된 모든 반응형 값의 목록입니다. 
  * 반응형 값은 props, state, 컴포넌트 본문 내부에서 직접 선언한 모든 변수와 함수를 포함합니다. 
  * React용으로 구성된 린터는 모든 반응형 값이 의존성에 잘 지정되었는지 확인합니다. 
  * 의존성 목록에는 고정된 수의 항목이 있어야 하며 [dep1, dep2, dep3]과 같이 인라인으로 작성해야 합니다. 
  * React는 각 의존성에 대해 Object.is로 이전 값과 비교합니다. 
  * 의존성을 전혀 지정하지 않으면 컴포넌트를 다시 렌더링할 때마다 Effect가 다시 실행됩니다.
  * 의존성을 지정하면 Effect는 초기 렌더링 후 및 변경된 의존성으로 다시 렌더링한 후에 실행됩니다.
  ```ts
  useEffect(() => {
  // ...
  }, [a, b]); // Runs again if a or b are different
  ```
  * Effect가 실제로 반응형 값을 사용하지 않는 경우, 초기 렌더링 이후에만 실행됩니다.
  ```ts
  useEffect(() => {
  // ...
  }, []); // Does not run again (except once in development)
  ```
  * 의존성 배열 자체를 전달하지 않으면, 컴포넌트의 모든 렌더링(및 리렌더링) 후마다 Effect가 실행됩니다.
  ```ts
  useEffect(() => {
  // ...
  }); // Always runs again
  ```
  
#### 주의사항
- useEffect는 훅이므로 컴포넌트의 최상위 레벨 또는 자체 훅에서만 호출할 수 있습니다.반복문이나 조건문 내부에서는 호출할 수 없습니다. 
- 필요한 경우 새 컴포넌트를 추출하고 state를 그 안으로 옮기세요.
- 외부 시스템과 동기화하려는 목적이 아니라면 Effect가 필요하지 않을지도 모릅니다.

### useRef 훅 사용하기
#### 인터넷 참고
- `const 변수명 = useRef(초기값)` 이러한 결과값으로, {current:  초기값}  을 지닌 객체가 반환된다.
- `<input ref= {변수명}/>` HTML 요소 접근
- useRef는 .current 프로퍼티로 전달된 인자(initialValue)로 초기화된 변경 가능한 ref 객체를 반환합니다. 
- 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지될 것입니다.
  * 컴포넌트가 계속해서 렌더링이 되어도 컴포넌트가 언마운드되기 전까지는 값을 그대로 유지할 수 있다
  * currnet 속성은 값을 변경해도 상태를 변경할 때 처럼 React 컴포넌트가 재렌더링 되지 않는다.
- useRef는 저장공간 또는 DOM요소에 접근하기 위해 사용되는 React Hook이다.
- 우리가 자바스크립트를 사용 할 때에는, 우리가 특정 DOM 을 선택하기 위해서 querySelector 등의 함수를 사용한다.
- React를 사용하는 프로젝트에서도 가끔씩 DOM 을 직접 선택해야 하는 상황이 필요하다. 그럴때 우리는 useRef라는 React Hook을 사용한다.
- useRef로 관리하는 값은 값이 변해도 화면이 렌더링되지 않음
- input요소에 focus를 주고 싶을때 많이 사용한다.
```tsx
const nameFocus = useRef();
nameFocus.current.focus();
//...
<input ref={nameFocus}/>
```

### useState 훅 사용하기
- useState가 반환하는 세터는 현재 값이 변경되면 자동으로 해당 컴포넌트를 다시 렌더링하는 기능이 있습니다.
- `const [현재값, 세터] = useState(초깃값)`

### 커스텀 훅이란?
- 리액트 훅은 여러 훅 함수를 조합해 마치 새로운 훅 함수가 있는 것처럼 만들 수 있는데, 이렇게 조합한 새로운 훅 함수를 **커스텀 훅** 이라고 합니다.
- 커스텀 훅은 리액트 훅뿐만 아니라 기존에 제작한 커스텀 훅 함수를 사용해서 만들 수도 있습니다.
- 커스텀 훅 함수는 '훅'이라는 의미를 강조하고자 함수 이름에 'use'라는 접두어를 붙여서 만듭니다.

#### useInterval.ts
```ts
import {useEffect} from "react";

export const useInterval = (callback: () => void, duration: number = 1000) => {
  useEffect(() => {
    const id = setInterval(callback, duration);
    return () => clearInterval(id)
  }, [callback, duration]);
}
```

#### useClock.ts
```ts
import {useState} from "react";
import {useInterval} from "./useInterval";

export const useClock = () => {
  const [today, setToday] = useState(new Date());
  useInterval(() => setToday(new Date()))
  return today;
}
```

### 리액트 훅 함수의 특징
- 같은 리액트 훅을 여러 번 호출할 수 있다.
- 함수 몸통이 아닌 몸통 안 복합 실행문의 `{}` 안에서 호출할 수 없다. (예: if문안에서, for문 안에서)
- 비동기 함수를 콜백 함수로 사용할 수 없다. `async () => // 안됨`

## 04-2 useMemo와 useCallback 훅 이해하기
- 프로젝트 생성 ch04_2

### 리액트 훅의 기본원리
#### 상태와 캐시
- 프로그래밍 분야에서 **상태(state)** 란 용어는 변수의 유효 범위와 무관하게 계속 유지하는 값을 의미합니다.
- 불변상태(immutable state): 한 번 설정되면 이후로는 값을 변경할 수 없는 '읽기 전용'
- 가변상태(mutable state): 아무때나 값을 변경할 수 있고 계속 유지
- 함수 컴포넌트는 '함수'이므로 블록 범위라는 개념 대문에 상태를 가질 수 없습니다.
- 리액트 훅은 상태를 가질 수 없는 함수 컴포넌트로 하여금 마치 상태를 가진 것처럼 동작할 수 있게 합니다.
- 이런 개념을 이용하면 캐시(cache)를 전역 변수 형태로 만들어서 구현할 수 있습니다.

#### 캐시 구현하기
#### useOrCreate.ts
```ts
const cache: Record<string, any> = {}

export const useOrCreate= <T>(key: string, callback: () => T ): T => {
  if (!cache[key]) cache[key] = callback();
  return cache[key] as T
}
```
- Record 타입은 타입스크립트가 기본으로 제공하며 겍체의 속성을 '키'로, 속성값을 '값'으로 할때 `Record<키타입,값타입>` 형태로 사용하는 제네릭입니다.

#### 캐시 사용하기
#### UseOrCreateTest.tsx
```tsx
import {Title, Avatar} from '../components'
import * as D from '../data'
import {useOrCreate} from './useOrCreate'

export default function CreateOrUseTest() {
    const headTexts = useOrCreate<string[]>('headtexts', () => [
        'No.', 'Name', 'Job Title', 'Email Address'
    ]);

    const users = useOrCreate<D.IUser[]>('users', () =>
        D.makeArray(100).map(D.makeRandomUser)
    )

    const head = useOrCreate('head', () => headTexts.map(text => <th key={text}>{text}</th>))
    const body = useOrCreate('children', () =>
        users.map( (user, index) => (
            <tr key={user.uuid}>
                <th>{index + 1}</th>
                <td className={"flex items-center"}>
                    <Avatar src={user.avatar} size="1.5rem" />
                    <p className="ml-2">{user.name}</p>
                </td>
                <td>{user.jobTitle}</td>
                <td>{user.email}</td>
            </tr>
        ))
    )

    return (
        <div className="mt-4">
            <Title>CreateOrUseTest</Title>
            <div className="overflow-x-auto mt-4 p-4">
                <table className="table table-zebra table-compact w-full">
                    <thead>
                        <tr>{head}</tr>
                    </thead>
                    <tbody>{body}</tbody>
                </table>
            </div>
        </div>
    )

}
```
#### 캐시와 의존성 목록
- 리액트 훅에서는 캐시를 갱신하게 하는 요소를 **의존성(dependency)** 이라고 합니다.
- 이러한 의존성으로 구성된 배열을 **의존성 목록(dependency list)** 이라고 합니다.

#### 함수 컴포넌트와 리액트 훅을 사용하는 이유
- 함수 컴포넌트에 리액트 훅을 사용하면 리액트 프레임워크가 의존성 목록에서 변한 값이 있는지만 판단하면 되므로 다시 렌더링해야 하는 때를 판단하기가 쉽습니다.

### 데이트를 캐시하는 useMemo 훅
- react 패키지는 데이터를 캐시하는 용도로 useMemo 훅을 제공합니다.
- 과거에 계산한 값을 반복해서 사용할 때 과거에 계산한 값을 캐시해 두는 방법으로 전체 계산 속도를 높이는 코드 최적화 기법 입니다.
- `const 캐쉬된데이터 = useMemo(콜백함수, [의존성1, 의존성2,...])` `콜백함수 = () => 원본데이터`
- 선언문: `function useMemo<T>(factory: () => T, deps: DependuncyList | undefined): T`

#### Memo.tsx
```tsx
import {Title, Avatar} from '../components'
import * as D from '../data'
import {useOrCreate} from './useOrCreate'
import {useMemo} from "react";

export default function Memo() {
    const headTexts = useMemo<string[]>( () => [
        'No.', 'Name', 'Job Title', 'Email Address'
    ],[]);

    const users = useMemo<D.IUser[]>( () =>
        D.makeArray(100).map(D.makeRandomUser)
    ,[])

    const head = useMemo(() => headTexts.map(text => <th key={text}>{text}</th>),[headTexts])
    const body = useMemo( () =>
        users.map( (user, index) => (
            <tr key={user.uuid}>
                <th>{index + 1}</th>
                <td className={"flex items-center"}>
                    <Avatar src={user.avatar} size="1.5rem" />
                    <p className="ml-2">{user.name}</p>
                </td>
                <td>{user.jobTitle}</td>
                <td>{user.email}</td>
            </tr>
        ))
    ,[users])

    return (
        <div className="mt-4">
            <Title>CreateOrUseTest</Title>
            <div className="overflow-x-auto mt-4 p-4">
                <table className="table table-zebra table-compact w-full">
                    <thead>
                    <tr>{head}</tr>
                    </thead>
                    <tbody>{body}</tbody>
                </table>
            </div>
        </div>
    )
}
```

### 콜백 함수를 캐시하는 useCallback 훅
- useCallback 훅의 사용 개념은 useMemo와 같습니다.
- useMemo가 데이터를 캐시한다면 useCallback은 콜백 함수를 캐시한다는 차이가 있습니다.
- `const 캐시된_콜백함수 = useCallback(원본_콜백함수, 의존성목록)`
- 선언문: `function useCallback<T extends ( ...args: any[]) => any>(callback: T, deps: DependuncyList): T`
- 타입제약 T `(...arg: any[]) => any` 이는 타입 변수 T는 함수여야 함을 의미합니다.

#### callBack.tsx
```tsx
export default function Callback() {
  const onClick = useCallback(() => alert('button clicked'), [])

  const buttons = useMemo(
          () =>
                  D.makeArray(3)
                          .map(D.randomName)
                          .map((name,index) => (
                                  <Button key={index} onClick={onClick} className="btn btn-primary normal-case btn-wide btn-xs">{name}</Button>
                          )) , [onClick]
  )

  return (
          <div className="mt-4">
            <Title>Callback</Title>
            <div className="flex justify-evenly mt-4">{buttons}</div>
          </div>
  )
}
```

#### 고차 함수 사용하기
- **고차함수(higher-order function)** 는 다른 함수를 반환하는 함수를 의미합니다.
- 리액트 개발에서 고차함수는 콜백 함수에 어떤 정보를 추가로 전달하려고 할 때 주로 사용합니다.
- ```const onClick = useCallback( (name: string) => () => alert(`${name} clicked`), [])```
- 리액트 프로그래밍에서 고차 함수를 구현하는 이ㅠ는 함수의 타입 불일치를 해결하기 위해서 입니다.
- onClick 이벤트 속성은 `() => void` 타입의 콜백 함수를 설정해야 하므로 ```() => alert(`${name} clicked`)``` 처럼 name 변수를 전달할 수 없습니다.
- 콜백 함수를 고차 함수로 구현하면 onClick이 요구하는 `() => void` 타입 함수를 반환할 수 있으면서 동시에 함수 몸통이 요구하는 name값 또한 전달할 수 있습니다.
- ```(name: string) => () => alert(`${name} clicked`)```

#### HighOrderCallback.tsx
```tsx
export default function HighOrderCallback() {
  const onClick = useCallback((name: string) => () => alert(`${name} clicked`), [])

  const buttons = useMemo(
          () =>
                  D.makeArray(3)
                          .map(D.randomName)
                          .map((name, index) => (
                                  <Button
                                          key={index}
                                          onClick={onClick(name)}
                                          className="btn-primary normal-case btn-wide btn-xs">
                                    {name}
                                  </Button>
                          )),
          [onClick]
  )

  return (
          <div className="mt-4">
            <Title>HighOrderCallback</Title>
            <div className="flex justify-evenly mt-4">{buttons}</div>
          </div>
  )
}
```
## 04-3 useState 훅 이해하기
- ch04_3 프로젝트 생성

### 불변 상태를 캐시하는 useState 훅
- useState 훅은 가변 상태를 캐시합니다.
- 리액트 프레임워크는 세터 함수가 호출되면 컴포넌트의 상태에 변화가 있는 것으로 판단하고 즉시 해당 컴포넌트를 다시 렌더링 합니다.
- `const [값, 값을 변경하는 세터 함수] = useState(초깃값)`
- 상태에는 타입이 있습니다. 즉, 상태는 number, boolean, string 같은 원시타입(primitive type)일 수도 있고, 객체나 배열, 튜플 타입일 수도 있습니다.
- useState 훅 선언문: `function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]`;
- `Dispatch<SetStateAction<S>>` 타입은 `setter(newValue)` 또는 `setter(previousValue => newValue)` 둘 중 하나의 함수 타입을 의미합니다.

### number 타입일 때 useState 훅 사용하기
- 

## 04-4 useEffect와 useLayoutEffect 훅 이해하기

## 04-5 useRef와 useImperativeHandle 훅 이해하기

## 04-6 useContext 훅 이해하기
