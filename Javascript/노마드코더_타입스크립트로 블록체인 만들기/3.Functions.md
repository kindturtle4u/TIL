> 출처 : 노마드코더 타입스크립트로 블록체인 만들기 - 니꼬

# 3.Functions

## 3.0 Call Signatures
```ts
type Add = (a:number, b:number) => number;

const add: Add = (a, b) => a+b;
```
## 3.1 Overloading
- 패키지나 라이브러리에서 Overloading을 많이 사용함.
- 오버로딩은 여러 call signatures가 있는 함수
```ts
type Add = {
  (a: number, b: number) : number
  (a: number, b: string) : number
}

const add: Add = (a, b) => {
    if (typeof b === "string") return a
  
    return a+b;
}
```

```ts
type Config = {
    path: string,
  state: object
}

type Push = {
  (path: string): void
  (config: Config): void
}

const push: Push = (config) => {
    if (typeof config === "string") {
        console.log(config)
    } else {
        console.log(config.path)
    }
}
```
- 파라미터 게수가 다를때 optional를 표시해줘야함.
```ts
type Add = {
  (a: number, b: number): number
  (a: number, b: number, c:number): number
}

const add:Add = (a, b, c?:number) => {
    if (c) return a + b + c;
    return a + b;
}
```

## 3.2 Polymorphism
- `poly`뜻 : `many`, `several`, `much`, `multi`
- `morpho`뜻: `form`, `structure`
- call signatrue를 작성할 때, 여기 들어올 확실한 타입을 모를 때 generic을 사용
```ts
type SuperPrint = {
    <TypePlaceholder>(arr: TypePlaceholder[]) : void
}

const superPrint: SuperPrint = (arr) => {
    arr.forEach(i => console.log(i));
}

superPrint([1, 2, 3, 4])
superPrint([true, false, true])
superPrint([1, 2, true, false, "abcd"])
```
## 3.3 Generics Recap

## 3.4 Conclusions
- 라이브러리를 만들거나, 다른 개발자가 사용할 기능을 개발하는 경우엔 제네릭이 유용
- 그 외 대부분의 경우에는 제네릭을 직접 작성할 일은 거의 없음, 대부분의 경우 제네릭을 사용만 하게 됨
```ts
function superPrint<T>(a: t[]) {
    return a[0];
}

superPrint([1, 2, 3, 4])
superPrint([true, false, true])
superPrint([1, 2, true, false, "abcd"])
```
```ts
type Player<E> = {
    name: string,
    extraInfo : E
}

type NicoExtra = {
    favFood: string,
}

type NicoPlayer = Player<NicoExtra>;

const nico: NicoPlayer = {
    name: "nico",
    extraInfo: {
        favFood: "kimchi"
    }
}

const lynn: Player<null> = {
    name: "lynn",
    extraInfo: null
}
```
```ts
type A = Array<number>

let a: A = [1, 2, 3, 4]
```
