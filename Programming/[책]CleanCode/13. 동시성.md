> 출처 : Clean Code 읽으면서 정리

# 13. 동시성
동시성과 깔끔한 코드는 양립하기 어렵다. 아주 어렵다. 스레드를 하나만 실행하는 코드는 짜기가 쉽다.
겉으로 보기에는 멀쩡하나 깊숙한 곳에 문제가 있는 다중 스레드 코드도 짜기 쉽다. 이런 코드는 시스템이 부하를 받기 전까지 
멀쩡하게 돌아간다.

## 동시성이 필요한 이유?
동시성은 결합(Coupling)을 없애는 전략이다. 즉, 무엇(what)과 언제(when)를 분리하는 전략이다.
- 미신과 오해
    * 동시성은 항상 성능을 높여준다.
    * 동시성을 구현해도 설계는 변하지 않는다.
    * 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.  
    
  동시성과 관련된 타탕한 생각
    * 동시성은 다소 부하를 유발한다.
    * 동시성은 복잡하다.
    * 일반적으로 동시성 버그는 재현하기 어렵다.
    * 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.
    
## 난관
## 동시성 방어 원칙
- 단일 책임 원칙
SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다.
동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 
즉, 동시성 관련 코드는 다른 코드와 분리해야 한다는 뜻이다.

- 따름정리(corollary): 자료 범위를 제한하라
공유객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라고 권장한다.

- 따름정리: 자료 사본을 사용하라
공유 자료를 줄일려면 처음부터 공유하지 않는 방법이 제일 좋다. 
어떤 경우에는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.

- 따름정리 : 스레드는 가능한 독립적으로 구현하라

## 라이브러리를 이해하라
- 스레드 환경에서 안전한 컬렉션
java.util.concurrent 패키지가 제공하는 클래스는 다중 스레드 환경에서 사용해도 안전하며, 성능도 좋다.
실제로 ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다.    

    |  |  |     
    |---|---|
    | ReentrantLock  | 한 메서드에서 잠그고 다른 메서드에서 푸는 락(lock)이다|
    | Semaphore      | 전형석인 세마포다.개수(count)가 있는 락이다.|
    | CountDownLatch | 지정한 수만큼 이벤트가 발생하고나서야 대기 중인 스레드를 모두 해재 하는락이다. |

## 실행모델을 이해하라
- 생상자-소비자(producer-Consumer)
- 읽기-쓰기(Readers-Writers)
- 식사하는 철학자들

## 동기화 하는 메서드 사이에 존재하는 의존성을 이해하라
공유 클래스 하나에 동기화된 메서드가 여럿이라면 구현이 올바른지 다시 한 번 확인하기 바란다.
권장사항 : 공유 객체 하나에는 메서드 하나만 사용하라

## 동기화하는 부분을 작게 만들어라
## 올바른 종료 코드는 구현하기 어렵다
## 스레드 코드 테스트하기
- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 프로세서 수보다 많은 스레드를 돌려보라
- 다른 플랫폼에서 돌려보라
- 코드에 보조코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라
- 직접 구현하기
- 자동화

## 결론


    
    

