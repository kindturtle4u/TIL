> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 2. 리팩터링 원칙
## 2.1 리팩터링 정의
- *리팩터링* 이란 용어는 명사로도 쓸 수 있고, 동사로도 쓸 수있다.
    * 리팩터링: [명사]소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부를 변경하는 기법
    * 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
- 리팩터링은 성능 최적화와 비슷하다. 둘다 코드륿 ㅕㄴ경하지만 프로그램의 전반적인 기능은 그대로 유지한다.
    * 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.
    * 성능 최적화는 오로지 속도 개선에만 신경 쓴다.

## 2.2 두 개의 모자
- 나는 소프트웨어를 개발할 때 목적이 '기능추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다.

## 2.3 리팩터링하는 이유
- 리팩터링하면 소프트웨어 설계가 좋아진다.
- 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
- 리팩터링하면 버그를 쉽게 찾을 수 있다.
- 리팩터링하면 프로그래밍 속도를 높일 수 있다.

## 2.4 언제 리팩터링해야 할까?
- 3의 법칙 ( 돈 로버츠가 내게 제시한 가이드다)
    * 처음에는 그냥한다.
    * 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
    * 비슷한 일을 세 번째 하게 되면 리팩터링한다.
    
- 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
- 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기
- 쓰레기 줍기 리팩터링 : 코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다.
- 계획된 리팩터링과 수시로 하는 리팩터링
- 오래 걸리는 리팩터링
- 코드 리뷰에 리팩터링 활용하기
- 관리자에게는 뭐라고 말해야 할까?
- 리팩터링하지 말아야 할 때
  * 굳이 수정할 필요가 없다면 리팩터링 하지 않는다. 외부 API 다로듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다. 내부 동작을 이해햐야 할 시점에
    리팩터링해야 효과를 제대로 볼 수 있다.
  * 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.
  
## 2.5 리팩터링 시 고려할 문제
- 새 기능 개발 속도 저하
  * 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
  * 코드베이스가 건강하면 기존 코드를 새로운 방식으로 조합하기 쉬워서 복잡한 새 기능을 더 빨리 추가할 수 있다.
  * 사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린코드'나 '바람직한 엔지니이ㅓ링 습관'처럼 도덕적인 이유로 정당화 하는 것이다.
    리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 리팩터링은 개발 기간을 단축하고자 하는 것이다.
-  코드 소유권
  * 코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다.
- 브랜치
  * 기능별 브랜치의 통합 주기를 짧게 관리해야 한다고 주장하는 사람이 많다. 이방식을 지속적 통합(CI), 
    또는 트렁크 기반 개발 (Trunk-Based Development:TBD) 이라 한다.
- 테스팅
  * 리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다. 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다.
  * 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 한다는 뜻이다.
- 레거시 코드
- 데이터베이스
  
## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
- 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다.
  가량 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있다. 그래서 다양한 예상 시나리오에 대응하기 위한 매개변수를 추가한다.
  이런 매개변수가 바로 유연성 매커니즘이다.
- 리팩터링을 미루면 훨씬 힘들어진다는확인이 들 때만 유연성 메커니즘을 미리 추가한다.
- 이런식으로 설계하는 방식을 간결한설계, 점직적설계 YAGNI("you aren't going to need it") 등으로 부른다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스
- 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(Test-Driven Development:TDD)이라 한다.
- 리팩터링의 첫 번째 토대는 자가 테스트 코드다. 다시 말해 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다.

## 2.8 리팩터링과 성능
- '직관적인 설계 vs 성능'은 중요한 주제다. 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
- 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬오지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.

## 2.9 리팩터링의 유래
## 2.10 리팩터링 자동화
- 리팩터링과 관련하여 지난 수십 년 사이에 일어난 가장 큰 변화는 자동 리팩터링을 지원하는 도구가 등장한 것이다.

## 2.11 더 알고 싶다면
- 최신 자료를 보고 싶다면 이 책의 [깃허브 지원 페이지](https://github.com/WegraLee/Refactoring)와 [리팩터링 웹사이트](https://refactorign.com/)를 참고하기 바란다. 


  

