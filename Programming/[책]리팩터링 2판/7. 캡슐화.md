> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 7. 캡슐화
- 모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다.
- 이러한 비밀 중 대표적인 형태인 데이터 구조는 **레코드 캡슐화하기(7.1절)** 와 **컬렉션 캡슐화하기(7.2절)** 로 캡슐화해서 숨길 수 있다. 심지어 기본형 데이터도 기본형을 객체로 바꾸기로 캡슐화할 수 있다.
- 리팩터링할 때는 임시 변수가 자주 걸리적거리는데, 이럴 때는 **임시변수를 질의 함수로 바꾸기(7.4절)** 가 상당히 도움이 된다.
- 클래스는 본래 정보를 숨기는 용도로 설계되었다. 흔히 사용하는 추출하기/인라인하기 리팩터링의 클래스 버전인 **클래스 추출하기(5.7절)** 와 
**클래스 인라인하기(7.6절)** 도 활용할 수 있다.
- 클래스는 내부 정보뿐 아니라 클래스 사이의 연결관계를 숨기는 데도 유용한다. 이 용도로는 **위임 숨기기(7.7절)** 가 있다. 
하지만 너무 많이 숨기려다 보면 인터페이스가 비대해질 수 있으니 반대 기법인 **중개자 제거하기(7.8절)** 도 필요하다. 
- 가장 큰 캡슐화 단위는 클래스와 모듈이지만 함수도 구현을 캡슐화한다. 때로는 알고리즘을 통째로 바꿔야 할 때가 있는데, **함수 추출하기(6.1절)** 로
알고리즘 전체를 함수 하나에 담은 뒤 **알고리즘 교체하기(7.9절)** 를 적용하면 된다.
- 
## 7.1 레코드 캡슐화하기 (Encapsulate Record)
```javascript
organization = {name : "애크미 구스베리", country : "GB"};
```
```javascript
class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }
    
    get name() { return this._name;}
    set name(arg) {this._name = arg;} 
    get country() {return this._country;}
    set country(arg) {this._country = arg;}
}
```

### 배경
- 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로 전달할 수 있게 해준다.
- 나는 '가변' 데이터일 때 객체를 선호한다고 했다. 값이 불변이면 단순히 '시작'과 '끝'과 '길이'를 모두 구해서 레코드에 저장한다.

### 절자
- 레코드를 담은 변수를 캡슐화 한다. ( 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.)
- 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 
변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
- 테스트한다.
- 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
- 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다.
적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다. ( 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터를 갱신하는 클라이언트들에 주의해서
살펴본다. 클라이언트가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기전용 프락시를 반환할지 고려해 보자. )
- 클래스에서 원본 데이터를 반환하는 접근자와 (1에서 검색하기 쉬운 이름을 붙여둔) 원본 레코드를 반환하는 함수들을 제거한다.
- 테스트한다.
- 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

## 7.2 컬렉션 캡슐화 하기 (Encapsulate Collection)
```javascript
class Person {
    get courses() {return this._courses;}
    set courses(aList) {this._courses = aList;}
}
```
```javascript
class Person {
    get courses() { return this._courses.slice();}
    addCourse(aCourse) {}
    removeCourse(aCourse){}
}
```

### 배경
- 나는 가변 데이터를 모두 캡슐화하는 편이다. 그러면 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬워서 필요한 시점에 데이터 구조를 변경하기도
쉬워지기 때문이다.
- 컬렉션 변수로의 접근을 캡슐화하면서 게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이
바뀌어 버릴 수 있다.
- 나는 이런 문제를 방지하기 위해 컬렉션을 감싼 클래스에 흔히 add()와 remove()라는 이름의 컬렉션 변경자 메서드를 만든다. 이렇게 항상 컬렉션 소유한
클래스를 통해서만 원소를 변경하도록 하면 프로그램을 개선하면서 컬렉션 변경 방식도 원하는대로 수정할 수 있다.
- 컬렉션 게터가 원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는게 낫다.
- 가장 흔히 사용하는 방식은 아마도 컬렉션 게터를 제공하되 내부 컬렉션의 복제본을 반환하는 것이다.

### 절차
- 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기 부터 한다.
- 컬렉션에 원소를 추가/제거하는 함수를 추가한다. 
(컬렉션 자체를 통째로 바꾸는 세터는 제거한다. 세터를 제거할 수 업삳면 인수로 받은 컬렉션을 복제해 저장하도록 만든다.)
- 정적 검사를 수행한다.
- 컬렉션을 참조하는 부분을 모두 찾는다. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다. 
하나씩 수정할 때마다 테스트한다.
- 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기전용 프락시나 복제본을 반환하게 한다.
- 테스트한다.

## 7.3 기본형을 객체로 바꾸기 ( Replace Primitive with Object)
```javascript
orders.filter( o => "high" === o.priority || "rush" === o.priority);
```
```javascript
orders.filter( o => o.priority.higherThan(new Priority("normal")));
```

### 배경
- 개발 초기에는 단순한 정보를 숫자나 문자열 같은 간단한 데이터 항목으로 표현할 때가 많다. 그러다 개발이 진행되면서 간단했던 이 정보들이 더 이상
간단하지 않게 변한다.
- 나는 단순한 출력 이상의 기능이 필요해지는 순간 그 데이터를 표현하는 전용 클래스를 정의하는 편이다. 시작은 기본형 데이터를 단순히 감싼 것과
큰 차이가 없을 것이라 효과가 미미하다.
- 초보 프로그래머에게는 직관에 어긋나 보일 수 있다. 하지만 경험 많은 개발자들은 여러가지 리팩터링 중에서도 가장 유용한 것으로 손꼽는다.

### 절차
- 아직 변수를 캡슐화하지 않았다면 캡슐화 한다.
- 단순한 값 클래스를 만든다. 생성자는 기존 값을 인수로 받아서 저장하고, 이 값을 반환하는 게터를 추가한다.
- 정적 검사를 수행한다.
- 값 클래스의 인스턴스를 새로 만들어서 필드에 저장하도록 세터를 수정한다. 이미 있다면 필드의 타입을 적절히 변경한다.
- 새로 만든 클래스의 게터를 호출한 결과를 반환하도록 게터를 수정한다.
- 테스트한다.
- 함수 이름을 바꾸면 원본 접근자의 동작을 더 잘 드러낼 수 있는지 검토한다.

## 7.4 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)
```javascript
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
    return basePrice * 0.95;
else 
    return basePrice * 0.98;
```
```javascript
get basePrice() { this._quantity * this._itemPrice;}
/*...*/
if ( this.basePrice > 1000)
    return this.basePrice * 0.95;
else 
    return this.basePrice * 0.98;
```

### 배경
- 함수 안에서 어떤 코드의 결괏값을 뒤에서 다시 참조할 목적으로 임시 변수를 쓰기도 한다. 임시 변수를 사용하면 값을 계산하는 코드가 반복되는 걸
줄이고 (변수 이름을 통해) 값의 의미를 설명할 수 있어서 유용한다. 그런데 한 걸음 더 나아가 아예 함수를 만들어서 사용하는 편이 나을 때가 많다.

### 절차
- 변수가 사용되기 전에 값이 확실히 결정되는지, 변수를 사용할 때마다 계산 로직이 매번 다른 결과를 내지는 않는지 확인한다.
- 읽기전용으로 만들 수 있는 변수는 읽기 전용으로 만든다.
- 테스트한다.
- 변수 대입문을 함수로 추출한다.
- 테스트한다
- 변수 인라인하기로 임시 변수를 제거한다.

## 7.5 클래스 추출하기 (Extract Class)
```javascript
class Person {
    get officeAreaCode() { return this._officeAreaCode;}
    get officeNumber() {return this._officeNumber;}
}
```
```javascript
class Person {
    get officeAreaCode() { return this._telephoneNumber.areaCode;}
    get officeNumber() { return this._telephoneNumber.number;}
}
class TelephoneNumber {
    get areaCode() { return this._areaCode;}
    get number() { return this._number;}
}
```

### 배경 
- 클래스는 반시드 명확하게 추상화하고 소수의 주어진 역할만 처리해야 한다는 가이드라인을 들어봤을 것이다.
- 메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다.

### 절차
- 클래스의 역할을 분리할 방법을 정한다.
- 분리될 역할을 담당할 클래스를 새로 만든다. ( 원래 클래스에 남은 역할과 클래스 이름이 어울리지 않는다면 적절히 바꾼다.)
- 원래 클래스의 생성자에서 새로운 클래스의 인스턴스를 생성하여 필드에 저장해둔다.
- 분리될 역할에 필요한 필드들을 새 클래스로 옮긴다(필드 옮기기). 하나씩 옮길 때마다 테스트한다.
- 메서드들도 새 클래스로 옮긴다(함수 옮기기). 이때 저 수준 메서드, 즉 다른 메서드를 호출하기 보다는 호출 당하는 일이 많은 메서드부터 옮긴다.
하나씩 옮길 때마다 테스트한다.
- 양쪽 클래스의 인터페이스를 살펴보면서 불필요한 메서드를 제거하고, 이름도 새로운 환경에 맞게 바꾼다.
- 새 클래스를 외부로 노출할지 정한다. 노출하려거든 새 클래스에 참조를 값으로 바꾸기를 적용할지 고민해본다.

## 7.6 클래스 인라인하기(Inline Class)