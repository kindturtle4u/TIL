> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 7. 캡슐화
- 모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다.
- 이러한 비밀 중 대표적인 형태인 데이터 구조는 **레코드 캡슐화하기(7.1절)** 와 **컬렉션 캡슐화하기(7.2절)** 로 캡슐화해서 숨길 수 있다. 심지어 기본형 데이터도 기본형을 객체로 바꾸기로 캡슐화할 수 있다.
- 리팩터링할 때는 임시 변수가 자주 걸리적거리는데, 이럴 때는 **임시변수를 질의 함수로 바꾸기(7.4절)** 가 상당히 도움이 된다.
- 클래스는 본래 정보를 숨기는 용도로 설계되었다. 흔히 사용하는 추출하기/인라인하기 리팩터링의 클래스 버전인 **클래스 추출하기(5.7절)** 와 
**클래스 인라인하기(7.6절)** 도 활용할 수 있다.
- 클래스는 내부 정보뿐 아니라 클래스 사이의 연결관계를 숨기는 데도 유용한다. 이 용도로는 **위임 숨기기(7.7절)** 가 있다. 
하지만 너무 많이 숨기려다 보면 인터페이스가 비대해질 수 있으니 반대 기법인 **중개자 제거하기(7.8절)** 도 필요하다. 
- 가장 큰 캡슐화 단위는 클래스와 모듈이지만 함수도 구현을 캡슐화한다. 때로는 알고리즘을 통째로 바꿔야 할 때가 있는데, **함수 추출하기(6.1절)** 로
알고리즘 전체를 함수 하나에 담은 뒤 **알고리즘 교체하기(7.9절)** 를 적용하면 된다.
- 
## 7.1 레코드 캡슐화하기 (Encapsulate Record)
```javascript
organization = {name : "애크미 구스베리", country : "GB"};
```
```javascript
class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }
    
    get name() { return this._name;}
    set name(arg) {this._name = arg;} 
    get country() {return this._country;}
    set country(arg) {this._country = arg;}
}
```
