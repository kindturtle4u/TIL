> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 7. 캡슐화
- 모듈을 분리하는 가장 중요한 기준은 아마도 시스템에서 각 모듈이 자신을 제외한 다른 부분에 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있을 것이다.
- 이러한 비밀 중 대표적인 형태인 데이터 구조는 **레코드 캡슐화하기(7.1절)** 와 **컬렉션 캡슐화하기(7.2절)** 로 캡슐화해서 숨길 수 있다. 심지어 기본형 데이터도 기본형을 객체로 바꾸기로 캡슐화할 수 있다.
- 리팩터링할 때는 임시 변수가 자주 걸리적거리는데, 이럴 때는 **임시변수를 질의 함수로 바꾸기(7.4절)** 가 상당히 도움이 된다.
- 클래스는 본래 정보를 숨기는 용도로 설계되었다. 흔히 사용하는 추출하기/인라인하기 리팩터링의 클래스 버전인 **클래스 추출하기(5.7절)** 와 
**클래스 인라인하기(7.6절)** 도 활용할 수 있다.
- 클래스는 내부 정보뿐 아니라 클래스 사이의 연결관계를 숨기는 데도 유용한다. 이 용도로는 **위임 숨기기(7.7절)** 가 있다. 
하지만 너무 많이 숨기려다 보면 인터페이스가 비대해질 수 있으니 반대 기법인 **중개자 제거하기(7.8절)** 도 필요하다. 
- 가장 큰 캡슐화 단위는 클래스와 모듈이지만 함수도 구현을 캡슐화한다. 때로는 알고리즘을 통째로 바꿔야 할 때가 있는데, **함수 추출하기(6.1절)** 로
알고리즘 전체를 함수 하나에 담은 뒤 **알고리즘 교체하기(7.9절)** 를 적용하면 된다.
- 
## 7.1 레코드 캡슐화하기 (Encapsulate Record)
```javascript
organization = {name : "애크미 구스베리", country : "GB"};
```
```javascript
class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }
    
    get name() { return this._name;}
    set name(arg) {this._name = arg;} 
    get country() {return this._country;}
    set country(arg) {this._country = arg;}
}
```

### 배경
- 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로 전달할 수 있게 해준다.
- 나는 '가변' 데이터일 때 객체를 선호한다고 했다. 값이 불변이면 단순히 '시작'과 '끝'과 '길이'를 모두 구해서 레코드에 저장한다.

### 절자
- 레코드를 담은 변수를 캡슐화 한다. ( 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.)
- 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 
변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
- 테스트한다.
- 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
- 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다.
적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다. ( 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터를 갱신하는 클라이언트들에 주의해서
살펴본다. 클라이언트가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기전용 프락시를 반환할지 고려해 보자. )
- 클래스에서 원본 데이터를 반환하는 접근자와 (1에서 검색하기 쉬운 이름을 붙여둔) 원본 레코드를 반환하는 함수들을 제거한다.
- 테스트한다.
- 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

## 7.2 컬렉션 캡슐화 하기 (Encapsulate Collection)
```javascript
class Person {
    get courses() {return this._courses;}
    set courses(aList) {this._courses = aList;}
}
```
```javascript
class Person {
    get courses() { return this._courses.slice();}
    addCourse(aCourse) {}
    removeCourse(aCourse){}
}
```

### 배경
- 나는 가변 데이터를 모두 캡슐화하는 편이다. 그러면 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬워서 필요한 시점에 데이터 구조를 변경하기도
쉬워지기 때문이다.
- 컬렉션 변수로의 접근을 캡슐화하면서 게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이
바뀌어 버릴 수 있다.
- 나는 이런 문제를 방지하기 위해 컬렉션을 감싼 클래스에 흔히 add()와 remove()라는 이름의 컬렉션 변경자 메서드를 만든다. 이렇게 항상 컬렉션 소유한
클래스를 통해서만 원소를 변경하도록 하면 프로그램을 개선하면서 컬렉션 변경 방식도 원하는대로 수정할 수 있다.
- 