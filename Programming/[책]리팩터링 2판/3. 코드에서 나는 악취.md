> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 3. 코드에서 나는 악취
- 리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다.

## 3.1 기이한 이름 (Mysterious Name)
- 코드를 명료하게 표현하는데 가장 중요한 요소 하나는 바로 *이름*이다.
- 이름 짓기는 프로그래밍에서 가장 어렵기로 손꼽히는 두 가지 중 하나다. 그 때문에 우리가 가장 많이 사용하는 리팩토링도 함수 선언 바꾸기,
  변수 이름 바꾸기, 필드 이름 바꾸기처럼 이름을 바꾸는 리팩터링들이다.
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드(Duplicated Code)
- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.

## 3.3 긴 함수 (Long Function)
- 우리의 경험에 비춰보면 오랜기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
그러기 위해서는 훨씬 적극적으로 함수르 쪼개야 한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
- 함수이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 짓는다. '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.

## 3.4 긴 매개변수 목록 (Long Parameter List)
- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.

## 3.5 전역 데이터(Global Data)
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는게 문제다.

## 3.6 가변 데이터(Mutable Data)
- 데이터를 변경했더니 예상치 못한 결과나 골치 아픈 버그로 이어지는 경우가 종종 있다.
- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터르 변경하려면 반드시(원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서
반환한다는 개념을 기본으로 삼고 있다.
- 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래미가 더 많다. 그렇다고 해서 불변성이 주는
장점을 포기할 필요는 없다.

## 3.7 뒤엉킨 변경(Divergent Change)
- 우리는 소프트웨어의 구조를 변경하기 쉬운 형태로 조직한다.
- 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다. 이렇게 할 수 없다면(서로 밀접한 악취인) 뒤엉킨 변경과
산탄총 수술 중 하나가 풍긴다.
  
## 3.8 산탄총 수술(shotgun Surgery)
- 산탄총 수술은 뒤엉킹 변경과 비슷하면서도 정반대다.
- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼저 있다면 찾기도 어렵고
꼭 수정해야 할 곳을 지나치기 쉽니다.
  
## 3.9 기능 편애(Feature Envy)
- 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다.
- 기능편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용하는 일이 더 많을 때 풍기는 냄새다.

## 3.10 데이터 뭉치(Data Clumps)
- 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있따. 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께
발견되기도 한다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅한다.
  
## 3.11 기본형 집착(Primitive Obsession)
- 프로그래머 중에는 자신에게 저어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다.
- 기본형을 객체로 바꾸기를 적용하면 기본형만이 거주하는 구석기 동굴을 의미 있는 자료형들이 사는 최신 온돌식 코드로 탈바꿈시킬 수 있다.

## 3.12 반복되는 switch 문 (Repeated Switches)
- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.
이럴 때 다형성은 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기인 셈이다.
  
## 3.13 반복문(Loops)
- 지금은 일급함수를 지원하는 언어가 많아졌기 때문에 반복문을 파이프라인으로 바꾸기를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있게 됐다.
- 필터(filter)나 맵(map) 같은 파이프라인 연산을 사용하면 코드에서 각 원소들이 어뗳게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소 (Lazy Element)
- 본문코드를 그대로 쓰는 것과 진배없는 함수도 있고, 실질적으로 메서드가 하나뿐인 클래스도 있다. 
  사정이 어떠하든 이런 프로그램 요소는 고이 보내드리는게 좋다.
  
## 3.15 추측성 일반화
- 이 냄새는 '나중에 필요할 거야'라는 생각으로 당장은 필요없는 모든 종류으 후킹(hooking) 포인트와 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다.
- 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않는다면 쓸데 없는 낭비일 뿐이다.
- 추축성 일반화는 테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있다. 이런 코드를 발견하면 테스트 케이스부터 삭제한 뒤에
  죽은 코드 제거하기로 날려 버리자.

## 3.16 임시 필드 (Temporary Field)
- 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 임시 필드를 갖도록 작성하면 코드를 이해하기 어렵다.
  사용자는 쓰이지 않는 것처럼 보이는 필드가 존재하는 이유를 파악하느라 머리를 싸매게 된다.

## 3.17 메시지 체인 (Message Chains)
- 메세지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 시긍로, 다른 객체를 요청하는 작업이
  연쇄적으로 이어지는 코드를 말한다.
- 이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다. 그래서 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.

## 3.18 중개자 (Middle Man)
- 캡슐화화는 과정에서는 위임이 자주 활용된다. 하지만 지나치면 문제가 된다. 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 어떤가?
이럴 때는 중개자 제거하기를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.
  
## 3.19 내부자 거래(Insider Trading)
- 모듈 사이의 데이터 거래가 많으면 결합도(coupling)가 높아진다고 투덜된다. 
  이를 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다.
  
## 3.20 거대한 클래스 (Large Class)
- 한 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
이럴 때는 클래스 추출하기로 필드들 일부를 따로 묶는다. 같은 컴포넌트에 모아두는 것이 합당해 보이는 필드들을 선택하면된다.
- 가장 간다한 해법은 그 클래스 안에서 자체적으로 중복을 제거하는 것이다.

## 3.21 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces) 
- 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단, 교체하려면 인터페이스가 같아야 한다.

## 3.22 데이터 클래스 (Data Class)
- 데이터 클래스란 데이터 필드와 게터/세터 메서드만으로 구성된 클래스를 말한다.
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다. 이런경우라면 클라이언트 코드를 데이터 클래스로 옮기기만 해도 대폭 개선된다.

## 3.23 상속 포기 (Refused Bequest)
- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을때 특히 심하게 난다.
이럴 때는 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용해서 아예 상속 메커니즘에서 벗어나 보자
  
## 3.24 주석 (Comments)
- 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩토링 해본다.


