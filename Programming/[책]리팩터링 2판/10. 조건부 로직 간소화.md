> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 10. 조건부 로직 간소화
## 10.1 조건문 분해하기 (Decompose Conditional)
```javascript
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
    charge = quantity * plan * plan.summerRate;
else
    charge = quantity * plan.regularRate + plan.regularServiceCharge;
```
```javascript
if (summer()) 
    charge = summerCharge();
else 
    charge = regularCharge();
```

### 배경
- 복잡한 조건부 로직은 프로그램을 복잡하게 만드는 가장 흔한 원흉에 속한다.
- 조건을 검사하고 그 결과에 따른 동작을 표현한 코든는 무슨 일이 일어나는지 이야기해주지만 '왜' 일어나는지 제대로 말해주지 않을 때가 많은 것이 문제다.

## 10.2 조건식 통합하기 (Consolidate Conditional Expression)
```javascript
if (anEmployee.seniority < 2) return 0;
if (anEmployee.monthsDisabled > 12) return 0;
if (anEmployee.isPartTime) return 0;
```
```javascript
if (isNotEligibleForDisability()) return 0;

function isNotEligibleForDisability() {
    return ((anEmployee.seniority < 2)
        || (anEmployee.monthsDisabled > 12)
        || (anEmployee.isPartTime));
}
```

### 배경
- 비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들이 더러 있는데, 어차피 같은 일을 할 거라면 조건 검사도 하나로 통합하는게 낫다.
- 하나의 검사라고 생각할 수 없는, 다시 말해 진짜로 독립된 검사들이라고 판단되면 이 리팩터링을 해서는 안된다.

## 10.3 중첩 조건문을 보호 구문으로 바꾸기 (Replace Nested Conditional with Guard Clauses)
```javascript
function getPayAmount() {
    let result;
    if (isDead)
        result = deadAmount();
    else {
        if (isSeprated)
            result = separatedAmount();
        else {
            if (isRetried)
                result = retriedAmount();
            else
                result = normalPayAmount();
        }
    }
    return result;
}
```
```javascript
function getPayAmount() {
    if (isDead) return deadAmount();
    if (isSeparated) return separatedAmount();
    if (isRetired) return retiredAmount();
    return normalPayAmount();
}
```

### 배경
- 조건문 한쪽만 정상이라면 비정상 조건을 if에서 검사한 다음, 조건이 참이면(비정상이면) 함수에서 빠져나온다.
- 진입점이 하나라는 조건은 최신 프로그래밍 언어에서는 강제된다. 그런데 반환점이 하나여야 한다는 규칙은, 정말이지 유용하지 않다.
  코드에서는 명확함이 핵심이다. 반환점이 하나일 때 함수의 로직이 더 명백하다면 그렇게 하자. 그렇지 않다면 하지 말자. 