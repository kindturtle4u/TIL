> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 9. 데이터 조직화
## 9.1 변수 쪼개기(Split Variable)
```javascript
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);
```
```javascript
const perimeter = 2 * (height + width);
console.log(perimeter);
const area = height * width;
console.log(area);
```

### 배경
- 변수에는 값을 단 한번만 대입해야 한다. 대입이 두번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다.
- 역할디 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다. 역할 하나당 변수 하나다. 여러 용도로 쓰인 변수는 코드를 읽는 이에게 커다른 혼란을 주기 때문이다.

## 9.2 필드 이름 바꾸기 (Rename Field)
```javascript
class Organization {
    get name() {}
}
```
```javascript
class Organization {
    get title(){}
}
```

### 배경
- 이름은 중요하다. 그리고 프로그램 곳곳에서 쓰이는 레코드 구조체의 필드 이름들은 특히 더 중요하다.
- 데이터 구조가 중요한 만큼 반드시 깔끔하게 관리해야 한다. 다른 요소와 마찬가지로 개발을 진행할수록 데이터를 더 잘 이애하게 된다.
따라서 그 깊어진 이해를 프로그램에 반드시 반영해야 한다.

## 9.3 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)
```javascript
get discountedTotal() { return this._discountedTotal}
set discount(aNumber) {
    const old = this._discount;
    this._discount = aNumber;
    this._discountedTotal += old - aNumber;
}
```
```javascript
get discountedTotal() {return this._baseTotal - this._discount;}
set discount(aNumber) {this._discount = aNumber;}
```

### 배경
- 가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속한다. 가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데
예컨데 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원인을 찾기 어려운 문제를 야기하기도 한다.
- 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다고 힘주어 주장해본다.

## 9.4 참조를 값으로 바꾸기( Chage Reference to Value)
```javascript
class Product {
    applyDiscount(arg) {this._price.amount -= arg;}
}
```
```javascript
class Product {
    applyDiscount(arg) {
        this._price = new Money(this._price.amount - arg, this._price.currency);
    }
}
```

### 배경
