> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 4. 테스트 구축하기
- 리팩터링을 제대로 하려면 불가피하게 저지르는 실수를 잡아주는 견고한 테스트 스위트가 뒷받침돼야 한다.

## 4.1 자가 테스트 코드의 가치
- 프로그래머들이 어떻게 일하는지 가만히 살펴보면 실제로 코드를 작성하는 시간의 비중은 그리 크지 않음을 발견할 수 있다.
현재 상황을 파악하기도 하고, 설계를 고민하기도 한다. 물론 대부분의 시간은 디버깅에 쓴다.
- 모든 테스르를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자. 이렇게 하니 테스트가 컴파일만큼 쉬워졌다.
그래서 다음부터는 컴파일 할때마다 테스트도 함께 했고, 곧바로 생산성이 급상승했다.
- 테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 
- TDD에서는 (처음에는 통과하지 못할) 테스트를 작성하고, 이 테스트를 통과하게끔 코드를 작성하고, 결과 코드를 최대한 깔끔하게 리팩터링 하는 과정을
짧은 주기로 반복한다.
  
## 4.2 테스트할 샘플 코드
- 비즈니스 로직 코드는 클래스 두 개로 구성된다. 하나는 생산자를 표현하는 Producer이고, 다른 하나는 지역 전체를 표현하는 Province다.
- Province의 생성자는 JSON 문서로부터 만들어진 자바스크립트 객체를 인수로 받는다.
```javascript
// Province 클래스...
constructor(doc) {
    this._name = doc.name;
    this._producers = [];
    this._totalProduction = 0;
    this._demand = doc.demand;
    this._price = doc.price;
    doc.producers.forEach(d => this.addProducer(new Producer(this, d)));
}

addProducer(arg) {
    this._producers.push(arg);
    this._totalProduction += arg.production;
}
```
```javascript
// 앞 생성자의 인수로 쓸 JSON 데이터
function sampleProvinceData() {
    return {
        name:"Asia",
        producers: [
            {name: "Byzantium", cost: 10, production: 9},
            {name: "Attalia", cost: 12, production: 10},
            {name: "Sinope", cost: 10, production: 6},
        ],
        demand: 30,
        price: 20
    };
}
```

```javascript
// Province 클래스에는 다양한 데이터에 대한 접근자들이 담겨 있다.
get name() {return this._name;}
get producers() {return this._producers.slice();}
get totalProduction() {return this._totalProduction;}
set totalProduction(arg) {this._totalProduction = arg;}
get demand() {return this._demand;}
set demand(arg) {this._demand = parseInt(arg);} // 숫자로 파싱해서 저장
get price() {return this._price;}
set price(arg) {this._price = parseInt(arg);} // 숫자로 파싱해서 저장
```
```javascript
// producer 클래스
constructor(aProince, data) {
    this._province = aProvince;
    this._cost = data.cost;
    this._name = data.name;
    this._production = data.production || 0;
}

get name() { return this._name;}
get cost() { return this._cost;}
set cost(arg) { this._cost = parseInt(arg);}

get production() { return this._production;}
set production(amountStr) {
    const amount = parseInt(amountStr);
    const newProduction = Number.isNaN(amount) ? 0 : amount;
    this._province.totalProduction += newProduction - this._production;
    this._production = newProduction;
}
```

```javascript
// 생산 부족분 
// Province 클래스
get shortfall() {
    return this._demand - this.totalProduction;
}
```

```javascript
// 수익 계산 코드
// Province 클래스
get profit() {
    return this.demandValue - this.demandCost;
}

get demandValue() {
    return this.satisfiedDemand * this.price;
}

get satisfiedDemand() {
    return Math.min(this._demand, this.totalProduction);
}

get demandCost() {
    let remainingDemand = this.demand;
    let result = 0;
    this.producers
        .sort((a,b) => a.cost -b.cost)
        .forEach(p => {
            const contribution = Math.min(remainingDemand, p.production);
            remainingDemand -= contribution;
            result += contribution * p.cost;
        });
    return result;
}
```

## 4.3 첫 번째 테스트