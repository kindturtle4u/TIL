> 출처 : 리팩토링 2판: 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기 (저자: 마틴 파울러)

# 6. 기본적인 리팩터링
- 내가 가장 많이 사용하는 리팩터링은 *함수 추출하기(6.1절)* 와 *변수 추출하기(6.3절)* 다. 리팩터링은 본래 코드를 변경하는 작업인 만큼, 이 두 리팩터링을
  반대로 진행하는 *함수 인라인하기(6.2절)* 와 *변수 인라인하기(6.4)절* 도 자주 사용한다.
- *함수 선언 바꾸기(6.5절)* 는 함수의 이름을 변경할 때 많이 쓰인다. 함수의 인수를 추가하거나 제거할 때도 이 리팩터링을 적용한다.
- 바꿀 대상이 변수라면 *변수 이름 바꾸기(6.7절)*를 사용하는데, 이는 *변수 캡슐화하기(6.6절)* 와 관련이 깊다. 자주 함께 뭉쳐 다니는 인수들은 
*매개변수 객체 만들기(6.8절)* 를 적용해 객체 하나로 묶으면 편리할 때가 많다.
- 일단 함수를 만들고 나면 다시 고수준 모듈로 묶어야 한다. 이렇게 함수를 그룹으로 묶을 때는 *여러 함수를 클래스로 묶기(6.9절)* 를 이용한다.
이때 이 함수들이 사용하는 데이터도 클래스로 함께 묶는다.
- 또 다른방법으로 *여러 함수를 변환 함수로 묶기(6.10절)* 도 있는데, 읽기전용 데이터를 다룰 때 특히 좋다.
- 나는 한걸음 더 나아가, 한데 묶은 모듈들을 작업 처리 과정을 명확한 단계(phase)로 구분 짓는 *단계 쪼개기(6.11절)* 를 적용할 때도 많다.

## 6.1 함수 추출하기(Extract Function)
- 반대 리팩터링: 함수 인라인하기(6.2절)

```javascript
function printOwing(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    
    // 세부 사항 출력
    console.log(`고객명: ${invoice.customer}`);
    console.log(`채무액: ${outstanding}`);
}
```

```javascript
function printOwing(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    printDetails(outstanding);
    
    function printDetails(outstanding) {
        console.log(`고객명 : ${invoice.customer}`);
        console.log(`채무액 : ${outstanding}`);
    }
}
```

### 배경
- 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
- 코드를 언제 독립된 함수로 묶어야 할지에 관한 의견은 수없이 많다.
  * 먼저 길이를 기준으로 삼을 수 있다. 가령 함수 하나가 한 화면을 넘어가서는 안된다는 규칙을 떠올릴 수 있다.
  * 재사용성을 기준으로 할 수도 있다. 두 번 이상 사용될 코든느 함수로 만들고, 한 번만 쓰이는 코드는 인라인 상태로 놔두는 것이다.
- 하지만 내 눈에는 '목적과 구현을 분리' 하는 방식이 가장 합리적인 기준으로 보인다.
코드를 보고 무슨일을 하는지 파악하는데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다. 이렇게 해두면 나중에
코드를 다시 읽을 때 함수의 목적이 눈에 확 들어오고, 본문코드(그 함수가 목적을 이루기 위해 구체적으로 수행하는 일)에 대해서는 더 이상 신경쓸 일이 거의 없다.
- 이러한 짧은 함수의 이점은 이름을 잘 지어야만 발휘되므로 이름 짓기에 특별히 신경 써야 한다. 이름을 잘 짓기까지는 어느 정도 훈련이 필요하다.
하지만 일단 요령을 터득한 후에는 별도 문서 없이 코드 자체만으로 내용을 충분히 설명되게 만들 수 있다.

### 절차
- 함수를 새로 만들고 목적을 잘 드러내는 이름을 붙인다('어떻게'가 아닌 '무엇을' 하는지가 드러나야 한다.)
- 추출할 코드를 원본 함수에서 복사하여 새 함수에 붙여 넣는다.
- 추출한 코드 중 원본 함수의 지역 변수를 참조하거나 추출한 함수의 유효범위를 벗어나는 변수는 없는지 검사한다. 있다면 매개변수로 전달한다.
- 변수를 다 처리 했다면 컴파일한다.
- 원본 함수에서 추출한 코드 부분을 새로 만든 함수를 호출하는 문장으로 바꾼다(즉, 추출한 함수로 일을 위임한다).
- 테스트한다.
- 다른 코드에 방금 추출한 것과 똑같거나 비슷한 코드가 없는지 살핀다. 
있다면 방금 추출한 새  함수를 호출하도록 바꿀지 검토한다(인라인 코드를 함수 호출로 바꾸기(8.5절))

## 6.2 함수 인라인하기 (Inline Function)
```javascript
function getRating(driver) {
    return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
    return driver.numberOfLateDeliveries > 5;
}
```
```javascript
function getRating(driver) {
    return (driver.numberOfLateDeliveries > 5) ? 2 : 1;
}
```

### 배경
- 이 책은 목적이 분명히 드러나는 이름의 짤막한 함수를 이용하기를 권한다. 그래야 코드가 명료해지고 이해하기 쉬워지기 때문이다.
하지만 때로는 함수 본문이 이름만큼 명확한 경우도 있다. 또는 함수 본문 코드를 이름만큼 깔끔하게 리팩터링 할 때도 있다. 
이럴 때는 그 함수를 제거한다. 간접 호출은 유용할 수도 있지만 쓸데없는 간접호출은 거슬릴 뿐이다.
- 리팩터링 과정에서 잘못 추출된 함수들도 다시 이라인한다.
- 간접 호출을 너무 과하게 쓰는 코드도 흔한 인라인 대상이다. 가령 다른 함수로 단순히 위임하기만 하는 함수들이 너무 많아서 위임 관계가 복잡하게
얽혀 있으면 인라인 해버린다.

### 절차
- 다형 메서드(polymorphic method)인지 확인한다. (서브클래스에서 오버라이드하는 메서드는 인라인하면 안된다.)
- 인라인할 함수를 호출하는 곳을 모두 찾는다.
- 각 호출문을 함수 본문으로 교체한다.
- 하나씩 교체할 때마다 테스트한다.
  (인라인 작업을 한 번에 처리할 필요는 없다. 인라인 하기 까다로운 부분이 있다면 일단 남겨두고 여유가 생길 때마다 틈틈이 처리한다.)
- 함수 정의(원래 함수)를 삭제한다.

재귀호출, 반환문이 여러 개인 함수, 접근자가 없는 다른 객체에 메서드를 인라인하는 방법등 상황이 그정도로 복잡하다면 함수 인라인하기를 적용하면 안됨

## 6.3 변수 추출하기 (Extract Variable)
- 반대 리팩터링: 변수 인라인하기(6.4절)
```javascript
return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100);
```
```javascript
const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(basePrice * 0.1, 100);
return basePrice - quantityDiscount + shipping;
```

### 배경
- 복잡한 로직을 구성하는 단계마다 이름을 붙일 수 있어서 코드의 목적을 훨씬 명확하게 드러낼 수 있다.
- 이 과정에서 추가한 변수는 디버깅에도 도움된다. 디버거에 중단점을 지정하거나 상태를 출력하는 문장을 추가할 수 있기 때문이다.
- 함수를 벗어난 넓은 문맥에서 까지 의미가 된다면 그 넓은 범위에서 통용되는 이름을 생각해야 한다. 다시 말해 변수가 아닌 (주로) 함수로 추출해야 한다.
- 이름이 통용되는 문맥을 넓히면 다른 코드에서 사용할 수 있기 때문에 같은 표현식을 중복해서 작성하지 않아도 된다. 그래서 중복이 적으면 의도가 잘
드러내는 코드를 작성할 수 있다.

## 절차
- 추출하려는 표현식에 부작용은 없는지 확인한다.
- 불변 변수를 하나 선언하고 이름을 붙일 표현식의 복제본을 대입한다.
- 원본 표현식을 새로 만든 변수로 교체한다.
- 테스트한다.
- 표현식을 여러 곳에서 사용한다면 각각을 새로 만든 변수로 교체한다. 하나 교체할 때마다 테스트한다.

## 6.4 변수 인라인하기 (Inline Variable)
- 반대 리팩터링: 변수 추출하기(6.3절)
- 1판에서의 이름: 임시변수 내용 직접 삽입
```javascript
let basePrice = anOrder.basePrice;
return (basePrice > 1000);
```
```javascript
return anOrder.basePrice > 1000;
```

### 배경
- 변수는 함수 안에서 표현식으 가리키는 이름으로 쓰이며, 대체로 긍정적인 효과를 준다. 하지만 그 이름이 원래 표현식과 다를 바 없을 때도 있다.
또 변수가 주변 코드를 리팩터링 하는데 방해가 되기도 한다. 이럴 때는 그 변수를 인라인하는 것이 좋다.

### 절차
- 대입문의 우변(표현식)에서 부작용이 생기지 않는지 확인한다.
- 변수가 불변으로 선언되지 않았다면 불변으로 만든 후 테스트한다. ( 이렇게 하면 변수에 값이 단 한 번만 대입되었는지 확인할 수 있다.)
- 이 변수를 가장 처음 사용하는 코드를 찾아서 대입문의 우변의 코드로 바꾼다.
- 테스트한다.
- 변수를 사용하는 부분을 모두 교체할 때까지 이 과정을 반복한다.
- 변수 선언문과 대입문을 지운다.
- 테스트한다.

## 6.5 함수 선언 바꾸기 (Change Function Declaration)
- 다른 이름: 함수 이름 바꾸기, 시그니처 바꾸기
```javascript
function circum(radius) {}
```
```javascript
function circumference(radius) {}
```

### 배경
- 함수는 프로그램을 작은 부분으로 나누는 주된 수단이다. 함수 선언은 각 부분이 서로 맞물리는 방식을 표현하며, 실질적으로 소프트웨어 시스템의
구성 요소를 조립하는 연결부 역할을 한다.
- 이러한 연결부에서 가장 중요한 요소는 함수의 이름이다. 이름이 좋으면 함수의 구현코드를 살펴볼 필요 없이 호출만만 보고도 무슨 일을 하는지 파악할수 있다.
- 이름이 잘못된 함수를 발견하면 더 나은 이름이 떠오르는 즉시 바꾸라는 명령으로 받아들인다. 그래야 나중에 그 코드를 다시 볼 때 무슨일을 하는지 '또'
고민하지 않게 된다.
- 함수의 매개변수도 마찬가지다. 매개변수는 함수가 외부 세계와 어우러지는 방식을 정의한다. 매개변수는 함수를 사용하는 문맥을 설정한다. 예컨데
전화번호 포매팅 함수가 매개변수로 사람을 받는다고 해보자. 그러면 회사 전화번호 포매팅에는 사용할 수 없게 된다. 사람 대신 전화번호 자체를 받도록 정의하면
이 함수의 활용 범위를 넓힐 수 있다.

### 절차
- 함수 선언 바꾸기는 '간단한 절차'만으로 충분할 때도 많지만, 더 세분화된 '마이그레이션 절차'가 훨씬 적합한 경우도 많기 때문이다.
 
#### 간단한 절차
- 매개변수를 제거하러겨든 먼저 함수 본문에서 제거 대상 매개변수를 참조하는 곳은 없는지 확인한다.
- 메서드 선언을 원하는 형태로 바꾼다.
- 기존 메서드 선언을 참조하는 부분을 모두 찾아서 바뀐 형태로 수정한다.
- 테스트한다.

#### 마이그레이션 절차
- 이어지는 추출 단계를 수월하게 만들어야 한다면 함수의 본문을 적절히 리팩터링한다.
- 함수의 본문을 새로운 함수로 추출(6.1절)한다. (새로 만들 함수 이름이 기존 함수와 같다면 일단 검색하기 쉬운 이름을 임시로 붙여둔다.)
- 추출한 함수에 매개변수를 추가해야 한다면 '간단한 절차'를 따라 추가한다.
- 테스트한다.
- 기존 함수를 인라인(6.2절)한다.
- 이름을 임시로 붙여뒀다면 함수 선언 바꾸기를 한 번 더 적용해서 원래 이름으로 되돌린다.
- 테스트한다.

## 6.6 변수 캡슐화하기 (Encapsulate Variable)
```javascript
let defaultOwner = {firstName: "마틴", lastName: "파울러"};
```
```javascript
let defaultOwnerData = {firstName: "마틴", lastName: "파울러"};
export function defaultOwner() {return defaultOwnerData;}
export function setDefaultOwner(arg) {defaultOwnerData = arg;}
```

### 배경
- 리팩터링은 결국 프로그램의 요소를 조작하는 일이다. 함수는 데이터 보다 다루기가 수월하다.
- 반면에 데이터는 함수보다 다루기가 까다로운데, 데이터는 참조하는 모든 부분을 한 번에 바꿔야 코드가 제대로 작동한다.
유효범위가 넓어질수록 다루기 어려워진다. 전역 데이터가 골칫거리인 이유도 여기에 있다.
- 그래서 접근할 수 있는 범위가 넓은 데이터를 옮길 때는 먼저 그 데이터로의 접근을 독점하는 함수를 만드신 식으로 캡슐화하는것이 가장 좋은 방법일 때가 많다.

### 절차
- 변수로의 접근과 갱신을 전담하는 캡슐화 함수들을 만든다.
- 정적 검사를 수행한다.
- 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 함수 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
- 변수의 접근 범위를 제한한다.
- 테스트한다.
- 변수 값이 레코드라면 레크도 캡슐화하기를 적용할지 고려해본다.

## 6.7 변수 이름 바꾸기 (Rename Variable)
```javascript
let a = height * width;
```
```javascript
let area = height * width;
```

### 배경
- 명확한 프로그래밍의 핵심은 이름 짓기다. 변수는 프로그래머가 하려는 일에 관해 많은 것을 설명해준다.
- 함수 호출 한 번으로 끝나지 않고 값이 영속되는 필드라면 이름에 더 신경 써야 한다.

### 절차
- 폭넓게 쓰이는 변수라면 변수 캡슐화하기를 고려한다.
- 이름을 바꿀 변수를 참조하는 곳을 모두 찾아서, 하나씩 변경한다.
- 테스트한다.

## 6.8 매개변수 객체 만들기(introduce Parameter Object)
```javascript
function amountInvoiced(startDate, endDate) {}
function amountReceived(startDate, endDate) {}
function amountOverdue(startDate, endDate) {}
```
```javascript
function amountInvoiced(aDateRange) {}
function amountReceived(aDateRange) {}
function amountOverdue(aDateRange) {}
```

### 배경
- 데이터 항목 여러개가 이 함수에서 저 함수로 함께 몰려다느니는 경우를 자주 본다. 나는 이런 데이터 무리를 발견하면 데이터 구조 하나로 모아주곤 한다.
- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계까 명확해진다.
- 함수가 이 데이터 구조를 받게 하면 매개변수 수가 줄어든다. 같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 똑같은 이름을 사용하기
때문에 일관성도 높여준다.

### 절차
- 적당한 데이터 구조가 아직 마련되어 있지 않다면 새로 만든다. ( 개인적으로 클래스로 만드는 걸 선호한다. 나중에 동장까지 함께 묶기 좋기 때문이다.)
- 테스트한다.
- 함수 선언 바꾸기로 새 데이터 구조를 매개변수로 추가한다.
- 테스트한다.
- 함수 호출 시 새로운 데이터 구조 인스턴스를 넘기도록 수정한다. 하나씩 수정할 때마다 테스트한다.
- 기존 매개변수를 사용하던 코드를 새 데이터 구조의 원소를 사용하도록 바꾼다.
- 다 바꿨다면 기존 매개변수를 제거하고 테스트한다.

## 6.9 여러 함수를 클래스로 묶기 (Combine Functions into Class)
```javascript
function base(aReading) {}
function taxableCharge(aReading) {}
function calculaterBaseCharge(aReading) {}
```
```javascript
class Reading {
    base() {}
    taxableCharge() {}
    calculateBaseCharge() {}
}
```

### 배경
- 클래스는 데이터와 함수를 하나의 공유환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.
클래스는 객체 지향 언어의 기본인 동시에 다른 패러다임 언어에도 유용하다.
- 이 리팩터링은 이미 만들어진 함수들을 재구성할 때는 물론, 새로 만든 클래스와 관련하여 놓친 연산을 찾아서 새 클래스의 메서드로 뽑아내는 데도 좋다.

### 절차
- 함수들이 공유하는 공통 데이터 레코드를 캡슐화 한다.
- 공통 레코드를 사용하는 함수 각각을 새 클래스로 옮긴다(함수 옮기기)
- 데이터를 조작하는 로직들은 함수로 추출해서 새 클래스로 옮긴다.

## 6.10 여러 함수를 변환 함수로 묶기 (Combine Functions into Transform)
```javascript
function base(aReading) {}
function taxableCharge(aReading) {}
```
```javascript
function enrichReading(argReading) {
    const aReading = _.cloneDeep(argReading);
    aReading.baseCharge = base(aReading);
    aReading.taxableCharge = taxableCharge(aReading);
    return aReading;
}
```
 
### 배경
- 변환함수는 원본 데이터를 입력받아서 필요한 정보를 모두 도출한 뒤, 각각의 출력 데이터의 필드에 넣어 반환한다.
- 이렇게 해두면 도출 과정을 검토할 일이 생겼을 때 변환 함수만 살펴보면 된다.
- 이 리팩터링 대신 여러 함수를 클래스로 묶기로 처리해도 된다. 둘 중 어느 것을 적용해도 좋다.
그런데 둘 사이에는 중요한 차이가 하나 있다. 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다.
- 여러 함수를 한데 묶는 이유 하나는 도출되는 로직이 중복되는 것을 피하기 위해서다. 이 로직을 함수로 추출 하는 것만으로도 같은 효과를 볼 수 있지만,
데이터 구조와 이를 사용하는 함수가 근처에 있지 않으면 함수를 발견하기 어려울 때가 많다. 변환 함수(또는 클래스)로 묶으면 이런 함수들을 쉽게 찾아 쓸 수 있다.

### 절차
- 변환할 레코드를 입력받아서 값을 그대로 반환하는 변환 함수를 만든다. (이 작업은 대체로 깊은 복사로 처리해야 한다.)
- 묶을 함수 중 함수 하나를 골라서 본문 코드를 변환 함수로 옮기고, 처리 결과를 레코드에 새 필드로 기록한다. 
그런 다음 클라이언트 코드가 이 필드를 사용하도록 수정한다.
- 테스트한다.
- 나머지 관련 함수도 위 과정에 따라 처리한다.

### 예시
- 참고로 나는 본질은 같고 부가 정보만 덧붙이는 변환 함수의 이름을 "enrich"라 하고, 형태가 변할 때만 "transform"이라는 이름을 쓴다.

## 6.11 단계 쪼개기 (Split Phase)
```javascript
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split("-")[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;
```
```javascript
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString) {
    const values = aString.split(/\s+/);
    return ({
      productID : values[0].splict("-")[1],
      quantity: parseInt(values[1]),
    });
}

function price(order, priceList) {
    return order.quantity * priceList[order.productID];
}
```

### 배경
- 나는 서로 다른 두 대상을 한꺼번에 다루는 코드를 발견하면 각각을 별개 모듈로 나누는 방법을 모색한다.
- 코드를 수정해야 할 때 두 대상을 동시에 생각할 필요 없이 하나에만 집중하기 위해서다.

### 절차
- 두 번째 단계에 해당하는 코드를 독립 함수로 추출한다.
- 테스트한다.
- 중간 데이터 구조를 만들어서 앞에서 추출한 함수의 인수로 추가한다.
- 테스트한다.
- 추출한 두 번째 단계 함수의 매개변수를 하나씩 검토한다. 그 중 첫 번째 단계에서 사용되는 것은 중간 데이터 구조로 옮긴다. 하나씩 옮길 때마다 테스트한다.
- 첫 번째 단계 코드를ㄹ 함수로 추출하면서 중간 데이터 구조를 반환하도록 만든다.


