> 출처 :  모두의 리눅스 읽으면서 정리 

# 14. 고도의 텍스트 처리 
## 14.1 sed 명령어: 스트림 에디터
### 14.1.1 비대화형 에디터란
- Stream Editor의 약자인 sed는 그 이름에서 알 수 있듯이 에디터 입니다. 하지만 sed는 비대화형 에디터 입니다. 따라서
대화형 에디터인 윈도우의 메모장이나 리눅스의 Vim과는 동작 방식이 크게 다릅니다.
- 비대화형 에디터인 sed는 다음과 같이 동작합니다.
  * 셀에서 편집 내용을 인자로 지정하여 sed 명령어를 실행합니다.
  * sed가 편집을 수행합니다.
  * 편집이 완료된 내용을 표준 출력으로 출력합니다.
- sed는 편집한 내용을 표준 출력으로 출력만 할 뿐 원래 파일의 내용을 바꾸지 않습니다. 따라서 원본 파일이 손상되는 것에 대해서 걱정하지 않아도
됩니다. 
- 그리고 sed도 필터 명령어이므로 편집할 파일을 지정하지 않으면 표준 입력을 읽습니다. 그래서 파이프를 사용하여 다른 명령어의 출력 결과를
편집하는 목적으로도 많이 사용됩니다.

### 14.1.2 sed 명령어의 형식
- sed로 텍스트 편집 `sed [옵션] <스크립트> <대상파일>`
- 여기서 `<스크립트>` 는 주소와 명령어를 조합한 문자열입니다. 주소를 지정하지 않으면 입력으로 들어오는 모든 행에 대해 명령어가 실행됩니다.
그리고 명령어에는 인자느 플래그를 지정할 수 있습니다.
```shell
$ sed 1,5d sample.txt
# 1,5d : 스크립트
# 1,4: 주소
# d: 명령어
# sample.txt: 대상파일

$ sed 's/aaa/bbb/g' sample.txt
# `s/aaa/bbb/g`: 스크립트
# s: 주소
# g: 플래그
# sample.txt: 대상파일
```
- 행을 지우는 `d`, 행을 표시하는 `p`, 행을 치환하는 `s`

### 14.1.3 행 삭제
- `d`는 행을 삭제하는 명령어 입니다. 
- 첫번째 행을 삭제 `sed 1d drink2.txt`
- 2행에서 5행까지 삭제 `sed 2,5d drink2.txt`
- 3행에서 마지막 행까지 삭제 `sed 3,$d drink2.txt` $는 마지막 행을 의미
- 모든 행을 삭제 `sed d drink2.txt` 주소를 지정하지 않으면 모든 행에 적용됩니다.
- B로 시작하는 행을 삭제 `sed /^B/d drink2.txt`

### 14.1.4 행 출력
- p는 행을 출력하는 명령어 입니다. 
- 첫번째 행을 출력하도록 지정 했는데 모든 행이 출력됨
```shell
$ sed 1p drink2.txt
Ber
Ber
Beer
BeerBeer
BeerBeerBeer
Beeeeeeeeer!!!
My Vodka
My Wine
```
- sed가 기본적으로 패턴 스페이스를 출력하기 때문입니다. sed는 한 행일 읽으면 먼저 패턴 스페이스라는 장소에 복사하고 편집 명령어를
실행한 뒤 패턴 스페티스의 니용을 출력합니다. 즉, 위예에서 첫 번째 행의 Ber는 1p라는 스크립트로 출력된 것이고 2번째 행인 Ber부터 마지막
행인 My Wine은 패턴 스페이스의 내용이 출력된 것입니다.
- 패턴 스페이스의 내용을 출력하지 않으려면 `-n` 옵션을 사용해야 합니다. 그래서 -n 옵션과 p 명령어를 함께 사용하면 특정 행만 출력할 수 있습니다.
- 첫 번째 행을 출력 `sed -n 1p drink.txt`

### 14.1.5 행 치환
- s는 행을 치환하는 명령어 입니다. sed는 주로 치환을 위해 사용되기 때문에 무척 자주 사용되는 명령어입니다.
- sed로 문자열 치환 `s/치환 전 문자열/치환 후 문자열/옵션`
- Beer를 Whiskey로 치환
```shell
$ sed 's/Beer/Whisky/' drink2.txt
Ber
Whisky
WhiskyBeer
WhiskyBeerBeer
Beeeeeeeeer!!!
My Vodka
My Wine
```
- 3번째 행과 4번째 행에 여전히 Beer가 남아 있는것을 알수 있습니다. 이는 sed가 각 행에서 처음 발견한 문자열만 치환했기 때문입니다.
- 발견한 모든 문자열을 치환하려면 `g`라는 옵션을 지정해야합니다.
- `g` 옵션을 지정하여 모든 Beer을 Whisky로 치환
```shell
$ sed 's/Beer/Whisky/g' drink2.txt
Ber
Whisky
WhiskyWhisky
WhiskyWhiskyWhisky
Beeeeeeeeer!!!
My Vodka
My Wine
```
- 정규 표현식을 사용하여 치환
```shell
$ sed 's/B.*r/Whisky/g' drink2.txt
Whisky
Whisky
Whisky
Whisky
Whisky!!!
My Vodka
My Wine
```
- !를 삭제 `$ sed 's/!//g' drink2.txt`
- 패턴 스페이스를 출력하지 않는 `-n` 옵션과 치환이 발생한 경우에만 출력하는 `p` 옵션을 지정하면 다음과 같이 치환이 발생한 행만 출력할 수 있습니다.
- 치환한 행만 표시
```shell
$ sed -n 's/!//gp' drink2.txt
Beeeeeeeeer
```
#### sed에서의 확장 정규 표현식
- sed에서 확장 정규표현식을 사용하려면 `-r`옵션을 지정해야 합니다. `$ sed -r 's/Be+r/Whisky/' drink2.txt `

#### 후방참조
- 정규 표현식을 사용하여 치환할 때 검색된 문자열의 일부를 치환하고 싶은 경우에는 후방 참조를 사용합니다.
- 후방 참조란 정규표현식에서 `()`을 사용하여 그룹화 한 뒤 \1 같이 참조하는 것을 말합니다.
- 그룹을 지정하고 치환될 문자열에서 참조
```shell
$ sed 's/My \(.*\)/--\1--/' drink2.txt
```

#### 주소지정
- s 명령어로 치환할 때도 주소를 지정하여 치환할 행을 한정할 수 있습니다. 파일의 일부만 치환하고 싶을 때 사용합니다.
- 주소 지정하여 치환 
```shell
$ sed '1,3s/Beer/Whisky/g' drink2.txt
Ber
Whisky
WhiskyWhisky
BeerBeerBeer
Beeeeeeeeer!!!
My Vodka
My Wine
```
- 구분자 변경
- 치환할 문자열 안에서 /를 사용하려면 \를 앞에 붙여서 \/라고 입력하면됩니다.
- Beer를 /Beer/로 치환 `sed 's/Beer/\/Beer\//g drink2.txt`
- s명령어를 사용할때 /가 구분자로 사용되었는데 이는 s 바로 뒤에 나오는 문자가 구분자로 사용된 것일 뿐입니다.
즉, s뒤에 다른문자를 지정하면 해당 문자가 구분자로 사용됩니다. 보통 구분자로 / 외에 ! 또는 %가 많이 사용됩니다.
- 구분자 !로 사용하여 치환
```shell
sed 's!Beer!/Beer/!g' drink2.txt
Ber
/Beer/
/Beer//Beer/
/Beer//Beer//Beer/
Beeeeeeeeer!!!
My Vodka
My Wine
```

## 14.2 awk 명령어: 패턴 검색 및 처리 언어
- awk는 텍스트 검색, 추출, 가공과 같은 편집 작업을 위한 명령어 입니다. '오크'라고 발음합니다.
- sed가 비대화형 에디터인 반면, awk는 좀 더 고도의 기능을 제공하여 텍스트 처리에 특화된 프로그래밍 언어라고 까지 인정받고 있습니다.
- 현재는 텍스트 편집을 위해 루비나 파이썬 같은 스크립트 언어가 많이 사용되고 있지만, awk도 여전히 많이 사용되고 있습니다. 
awk의 사용법을 잘 익혀 두면 리눅스를 사용할 때 도움이 많이 됩니다.

### 14.2.1 awk 명령어의 형식
- awk도 sed와 마찬가지로 `awk <스크립트> <대상파일>` 형식으로 실행합니다. 
- awk의 스크립트 `패턴 { 액션 }`

- 패턴에 액션을 실핼하지 여부를 결정하는 조건을 기술합니다. awk는 대상 텍스트의 행마다 이 조건에 부합하는지를 확인합니다.
여기서 텍스트의 한행을 awk에서는 레코드라 부릅니다.
- 액션에는 텍스트 추출, 치환, 삭제 등의 처리를 지정하며 패턴이 일치할 때만 액션이 실행됩니다. 만약 패턴이 생략되면 모든 레코드에 대해 액션이 실행됩니다.

### 14.2.2 print와 필드 변수
- awk는 특정 필드를 추출할 때 많이 사용됩니다. 여기서는 `ls -l` 명령어의 결과 중에서 파일 크기와 파일 이름만 출력해 보겠습니다.
- ls 명령어의 결과에서 5번째와 9번째의 필드를 출력
```shell
$ ls -l /usr/bin | awk '{print $5,$9}'
ls -l /usr/bin | awk '{print $5,$9}'

54840 [
29 alias
6 apropos
38208 arch
21056 aulast
12728 aulastlog
12560 ausyscall
42040 authselect
33504 auvirt
4 awk
59048 b2sum
42440 base32
42448 base64
38272 basename
...
```
- awk는 각 레코드를 필드로 자동으로 분리하여 각각 $1.. 과 같이 변수에 대입합니다. 그리고 레코드 전체에 대해서는 $0에 대입합니다.
- 공백이나 탭을 구분자로 사용하여 필드를 분할합니다. 이때 공백이 여러 개로 이어지면 하나로 간주하기 때문에 ls 명령어의 출력 결과처럼 공백이 불규칙하게 사용된 경우에도
문제없습니다.
- print할 때 변수 여러개를 쉼표로 구분하여 지정하면 각 값 사이에 공백이 표시되어 출력됩니다. 쉼표 대신 공백으로 구분하면 지정한 값 사이에 공백이 표시되지 않으니
주의합니다.
- 변수를 나열할 때 공백을 사용하면 값들 사이에 공백 없이 출력됨
```shell
$ ls -l /usr/bin | awk '{print $5 $9}'

54840[
29alias
6apropos
38208arch
21056aulast
12728aulastlog
12560ausyscall
42040authselect
33504auvirt
....
```
- 필드 변수와 함께 자주 사용하는 변수로 NF 변수가 있습니다. NF는 레코드의 필드 개수를 담고 있는 변수입니다. 그래서 $NF를 print하면
레코드의 마지막 필드가 출력되며 위 예에서 $9대신 $NF를 지정해도 동일한 결과가 출력됩니다.
- 마지막 필드와 마지막에서 두 번째 필드를 출력 `$ ls -l /usr/bin | awk '{print $(NF-1),$NF}`

### 14.2.3 패턴 지정
- awk에서는 확장 정규표현식을 사용하는 것이 가능합니다. 이때 정규표현식은 슬래쉬(/)로 감싸야합니다. 그리고 정규 표현식을 확인할 필드를 지정하기 위해 ~(틸드)를 사용합니다.
- 파일이름이 cp로 시작하는 행만 출력의 대상이 됨 `ls -l /usr/bin | awk '$9 ~ /^cp/ {print $5,$9}`
```shell
$ ls -l /usr/bin | awk '$9 ~ /^cp/ {print $5,$9}'
151528 cp
163416 cpio
68440 cpupower
```
- 정규 표현식을 확인할 필드를 지정하지 않을 수도 있는데, 그러면 레코드 전체가 정규 표현식에 해당하는지 확인하게 됩니다. 
- l로 시작하는 행만 액션의 대상으로 지정하기 `$ ls -l /usr/bin | awk '/^l/ {print $5, $9}`

### 14.2.4 액션 생략
- 액션을 생략하면 단순히 레코드를 출력합니다. 즉 , `{print $0}`이 실행됩니다. 그리고 print에 아무런 인자를 지정하지 않으면 레코드 전체가 출력됩니다.
- 다음 세 가지 사용법은 동일한 결과를 출력합니다.
  * `awk '$9 ~/^cp/'`
  * `awk '$9 ~/^cp/ {print}`
  * `awk '$9 ~/^cp/ {print $0}`

### 14.2.5 실전예제: CSV 파일의 점수 집계
```shell
# score.csv
1,mina,39
2,jieun,74
3,dabin,59
4,ina,12
5,yuri,98
6,minsoo,41
```
- 구분자를 ,로 지정
```shell
$ awk -F, '{print $1,$2,$3}' score.csv
1 mina 39
2 jieun 74
3 dabin 59
4 ina 12
5 yuri 98
6 minsoo 41
```
- 점수 총합을 표시
```shell
$ awk -F, '{sum += $NF} END {print sum}' score.csv
```
- END 안에 있는 액션은 모든 입력 파일에 대한 처리가 끝난 뒤 마지막에 한번 실행됩니다.
- 입력 파일의 행수는 변수 NR에 담겨 있습니다. 
- 평균 값을 계산
```shell
$ awk -F, '{sum += $NF} END {print "Average:",sum/NR}' score.csv
Average: 53.8333
```
- 이렇게 만든 awk 스크립트를 파일로 저장하면 나중에 불러 쓸 수 있습니다. -f 옵션으로 awk 스크립트가 적힌 파일을 지정하면 됩니다.
```shell
$ cat average.awk
{sum += $NF} END{print "Average:", sum/NR}
$ awk -F, -f average.awk score.csv
Average: 53.8333
```
