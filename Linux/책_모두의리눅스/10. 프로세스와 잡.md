> 출처 :  모두의 리눅스 읽으면서 정리 

# 10. 프로세스와 잡
## 10.1 프로세스란?
- 명령어의 실체는 디스크에 있는 파일입니다. 셸에서 명령어를 입력하면 커널이 디스크에 있는 해당 파일을 읽어서 메모리에 올린뒤
CPU가 프로그램을 실행합니다. 여기서 메모리 위에 올린 프로그램을 프로세스라 합니다.
- 같은 프로그램을 실행하더라고 각 프로세스는 별도의 메모리 영역을 가집니다.
- 파일 소유자 외에는 해당 파일에 대한 조작 권한이 제한되는 것과 비슷하게 프로세스를 실행한 사용자 외에는 해당 프로세스를 조작할 수 있는
권한이 제한됩니다.
- 리눅스 커널은 각 프로세스에게 프로세스 ID라는 고유한 번호를 할당해서 관리합ㄴ디ㅏ. 프로세를 관리하는 것은 리눅스 커널의
중요한 기능 중 하나 입니다.
- 리눅스에서 새로운 프로세스는 이미 기존에 존재하는 별도의 프로세스를 기반으로 만들어입니다. 여기서 새로운 프로세스를 만드는
프로세스를 부모 프로세스라고 하며, 새롭게 만들어지는 프로세스를 자식 프로세스라고 합니다. 예를 들어 셸에서 ls 명령어를 실행하면
셸이 부모 프로세스이며, ls 명령어는 자식 프로세스가 됩니다.

### 10.1.1 ps 명령어: 프로세스 목록 표시
- PS 명령어는 현재 시스템에서 실행 중인 프로세스 목록을 출력합니다. 아무런 인자 없이 ps를 실행하면 현재 접속한 터미널에서 실행한 프로세스만 출력합니다.
- `PID`: 프로세스 ID
- `CMD`: 실행한 명령어
- 프로세스 ID는 프로세스가 종료하기 전까지 바뀌지 않습니다. 따라서 특정 프로세스를 지정할 때 프로세스 ID를 사용합니다.

#### 현재 접속한 터미널 이외의 프로세스를 출력하고 싶은 경우
- 다른 터미널에서 실행 중인 프로세스나 터미널과 무관하게 돌아가는 프로세스인 데몬(deamon)을 출력하려면 x옵션을 사용합니다. 그러면 사용자가 현재 실행중인
모든 프로세스를 확인할 수 있습니다.
- 사용자가 실행중인 모든 프로세스 출력 `ps xf` 옵션 `f` 프로세스간 부모 자식 관계 표시
- 한편 `TTY`는 터미널을 의미합니다. SSH 접속을 담당하는 프로세스인 sshd의 TTY는 ?로 표시되고 있습니다. 이는 해당 프로세스가 터미널에 접속되어 있지 않은
데몬임을 의미합니다.


#### 옵션 형식
- 리눅스의 `ps`명령어는 역사적인 이유로 두 종류의 옵션 형식을 제공합니다.
  * UNIX 옵션: -을 사용하여 옵션을 지정합니다. 예) `ps -aef`
  * BSD 옵션: -없이 옵션을 지정합니다. 예) `ps xf`
- `-` 유무에 따라 옵션 문자가 가지는 의미가 전혀 달라서 완전히 다른 옵션 체계라고 볼 수 있습니다. 이책에서는 주류인 BSD 옵션을 사용합니다.

#### 모든 프로세스 표시
- 사용자가 실행한 프로세스 외에도 시스템을 위해 동작중인 프로세스들이 있습니다. 이러한 프로세스들은 대부분 슈퍼 사용자의 권한으로 실행됩니다.
이러한 프로세스들도 함께 확인하려면 앞서 설명한 x옵션과 함꼐 a옵션을 지정하면 됩니다.

## 10.2 잡
- 프로세스는 리눅스 커널의 입장에서 바라본 처리 단위 입니다. 한편 셸에서 바라본 처리 단위를 잡(job)이라고 합니다. 셸의 커맨드 라인에 입력한 한 행이 곧 잡 하나에
해당됩니다.
- 커맨드 라인에서 명령어 하나만 입력했다면 프로세스와 잡이 같습니다. 복수의 명령어를 파이프(11장참고)로 연결 했다면 프로세스는 명령어마다 만들어지지만 잡은 하나만 만들어집니다.
- `ls -l | cat -n | less`: 생성되는 프로세스는 3개, 잡은 1개
- 잡은 일시 정지하거나 백그라운드에서 실행할 수 있습니다. 즉, 여러 작업을 병행시켜 효율적으로 처리할 수 있습니다.

### 10.2.1 명령어를 일시 정지하는법
```shell
man bash # man 실행

# 출력된 매뉴얼을 읽던중 ~/.bashrc 파일을 편집하고 싶다면 q를 입력하여 man을 종료한뒤 편집을 진행하고 다시 man을 기동하여 읽던 위치를 찾아야 합니다.
# 이때 q를 누르는 대신에 Ctrl + Z를 눌러봅니다. 그러면 다음과 같이 정지라고 표시되면서 프롬프트가 표시됩니다. 즉, 셸에 명령어를 입력할 수 있게 됩니다.

#[1]+  Stopped                 man bash


#마치 man 명령어가 종료된 것 처럼 보이지만 실은 그렇지 않습니다. 대신에 man bash라는 잡이 정지 상태가 되었을 뿐입니다. 일시 정지된 잡은 다시 정지한 상태에서부터 실행하는 것이 가능합니다.
# 그러면 이상태에서 에디터를 기동하여 ~/.bashrc를 편집해 보겠습니다.

vim ~/.bashrc

# 파일 편집을 하다가 다시 bash 매뉴얼을 확인하고 싶다면 이번에도 Vim을 종료하는 것이 아니라 Ctrl+Z를 누릅니다.

#[2]+  Stopped                 vim ~/.bashrc

#jobs 명령어로 현자 잡 목록 확인
$ jobs
[1]-  Stopped                 man bash
[2]+  Stopped                 vim ~/.bashrc

# 앞쪽에 표시되는 [1]이나 [2]는 잡 번호를 의미합니다. 위 예에서는 man bash가 1, vim ~/.bashrc가 2 입니다. 
# 잡 번호뿐만 아니라 프로세스 ID도 표시하려면 l 옵션을 지정합니다.

$ jobs -l
[1]- 275986 Stopped                 man bash
[2]+ 276012 Stopped                 vim ~/.bashrc
```

### 10.2.2 fg 명령어: 잡을 포어그라운드로 전환
- 사용자의 입력을 받아들일 수 있는 잡의 상태를 포어그라운드(foreground)라고 합니다. 정지 상태에 있는 bash 매뉴얼을 다시 확인하기 위해서는 포어그라운드로 되돌려야 합니다.
- 잡을 포어그라운드로 전환: `fg %<잡번호>`
- fg 명령어를 사용할 때 잡번호를 생략하면 현재잡(jobs 명령에서 +로 표시된 잡)이 포어그라운드가 됩니다.

### 10.2.3 bg 명령어: 잡을 백그라운드로 전환
- `Ctrl + z`로 잡을 정지하면 해당 잡이 동작을 멈춥니다. 예를 들어 다음과 같이 cp 명령어로 파일을 복사하는 중에 `Ctrl + z`를 누르면 복사처리가 정지되어
한없이 기다려도 복사가 완료되지 않습니다.
- 포어 그라운드와 반대로 사용자가 조작할 수 없는 잡의 상태를 백그라운드(background)라고 합니다.
- 잡을 백그라운드에서 실행하는 명령어로 bg가 있습니다. `bg %<잡번호>`
```shell
$ bg %1
[1]+ cp file1 file2 &
$
```
- 시간이 걸리는 작업을 백그라운드로 실행하면 작업이 끝나는 것을 기다리지 않고도 다른 작업을 진행 할 수 있습니다.
- 백그라운드에서 진행중인 잡도 jobs 명령어로 상태를 확인할 수 있습니다.
```shell
$ jobs
[1]+ 실행 중 cp file1 file2 &
```
- 잡을 일시 정지했을때는 '멈춤'이라고 표시되었지만 이번에는 '실행 중'이라고 표시되었습니다. 즉, 복사 작업이 진행되고 있음을 의미합니다.
마지막에 표시된 &는 잡이 백그라운드로 돌고 있음을 의미합니다.
- 백그라운드 잡 종료 메시지 : `[1]+ 완료 cp file1 file2`
- cp 명령어를 백그라운드로 실행: `cp file1 file2 &`

### 10.2.4 잡의 전이 상태
- 포어그라운드: 사용자가 조작하면서 실행 중인 상태
- 백그라운드: 사용자가 조작할 수 없지만 실행 중인 상태
- 정지: 처리를 일시적으로 중단된 상태
- 셸의 내장 명령어인 jobs, fg, bg
```shell
$ type jobs fg bg
jobs is a shell builtin
fg is a shell builtin
bg is a shell builtin
```

## 10.3 잡과 프로세스의 종료
### 10.3.1 잡 종료
- 포어그라운드로 실행중인 잡을 종료하기 위해서는 `Ctrl + c`를 입력하면 됩니다. 많은 프로그램이 `Ctrl + c`를 입력받으면 종료되도록 설계 되어 있습니다.
- 백그라운드에서 실행중인 잡을 종료하려면 잡 번호를 지정하여 kill 명령어를 실행합니다. `kill %<잡번호>`

### 10.3.2 프로세스 종료
- 프로세스 종료: `kill <프로세스 ID>`
- 다른 사용자가 실행 중인 프로세스는 함부로 종료할 수 없습니다. 예외적으로 슈퍼 사용자는 모든 사용자의 프로세스를 강제로 종료할 수 있습니다.

### 10.3.3 kill 명령어: 시그널 전송
- kill 명령어는 사실 잡이나 프로세스를 종료하는 명령어가 아니라 시그널을 전송하는 명령어입니다. 여기서는 시그널에 관해 알아보겠습니다.
- 시그널이란 말 그대로 프로세스에게 전송되는 신호입니다. 프로세스는 전달받은 시그널의 종류에 따라 종료, 정지, 재기동 등의 처리를 수행합니다.
즉, 시그널을 통해 프로세스에게 메시지를 보내는 것 입니다.
- 전송할 시그널의 종류는 `kill <시그널 이름>`과 같이 지정할 수 있습니다. 시그널 이름을 지정하지 않으면 기본값으로 TERM 이라는 시그널이 전송됩니다.
즉, 다음 두 명령어는 동일합니다. `kill 4695 = kill -TERM 4695`
- 시그널에는 고유 번호가 있어 이를 지정하는 것도 가능합니다. TERM 시그널의 경우 15번입니다. `kill -15 4695`
TERM이라는 시그널은 terminate, 즉 종료 시그널입니다.
- 포어그라운드에서 동작하는 잡에게 입력한 `Ctrl + z`나 `Ctrl + c`도 사실은 내부적으로 시그널을 전송합니다. 
`Ctrl + z`는 TSTP , `Ctrl + c`는 INT라는 시그널을 전송합니다.
- 시그널의 전체 목록은 kill 명령어에 -l 옵션을 붙여 확인할 수 있습니다. 이때 시그널 이름 앞에 SIG라는 문자열이 붙어 표시됩ㄴ다.
- 시그널의 종류
```shell
$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
```
- 9)SIGKILL은 다소 예외적인 시그널입니다. 이 시그널만큼은 프로세스에 전달되지 않고 리눅스 커널이 처리합니다. 리눅스 커널은 이 시그널을 받으면
지정한 프로세스를 강제 종료합니다. 즉, TERM 시그널을 받아도 종료하지 않는 상태에 빠진 프로세스를 종료하기 위한 시그널입니다.
- SIGKILL 시그널은 마지막 수단으로 생각해야 합니다. 프로그램의 구현에 따라 TERM 시그널을 수신 받으면 현재 상태를 보존하거나 임시파일을 지우는 등 종료전에
수행해야 할 작업을 수행하고 종료합니다. 하지만 KILL 시그널을 전송받으면 이러한 종료처리를 수행하지 않고 곧바로 프로세스가 종료됩니다.
- 따라서 프로세스를 종료하고 싶을때는 먼저 TERM 시그널을 보내보고 그래도 종료하지 않으면 KILL 시그널을 사용하는 것이 바람직하빈다.
